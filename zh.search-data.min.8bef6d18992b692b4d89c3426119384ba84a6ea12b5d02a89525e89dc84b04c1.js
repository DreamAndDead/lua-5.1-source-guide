'use strict';(function(){const indexCfg={encode:false,tokenize:function(str){return str.replace(/[\x00-\x7F]/g,'').split('');}};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/lua-5.1-source-guide/docs/example/','title':"Example Site",'section':"Docs",'content':"Introduction #  Ferre hinnitibus erat accipitrem dixi Troiae tollens #  Lorem markdownum, a quoque nutu est quodcumque mandasset veluti. Passim inportuna totidemque nympha fert; repetens pendent, poenarum guttura sed vacet non, mortali undas. Omnis pharetramque gramen portentificisque membris servatum novabis fallit de nubibus atque silvas mihi. Dixit repetitaque Quid; verrit longa; sententia mandat quascumque nescio solebat litore; noctes. Hostem haerentem circuit plenaque tamen.\n Pedum ne indigenae finire invergens carpebat Velit posses summoque De fumos illa foret  Est simul fameque tauri qua ad #  Locum nullus nisi vomentes. Ab Persea sermone vela, miratur aratro; eandem Argolicas gener.\nMe sol #  Nec dis certa fuit socer, Nonacria dies manet tacitaque sibi? Sucis est iactata Castrumque iudex, et iactato quoque terraeque es tandem et maternos vittis. Lumina litus bene poenamque animos callem ne tuas in leones illam dea cadunt genus, et pleno nunc in quod. Anumque crescentesque sanguinis progenies nuribus rustica tinguet. Pater omnes liquido creditis noctem.\nif (mirrored(icmp_dvd_pim, 3, smbMirroredHard) != lion(clickImportQueue, viralItunesBalancing, bankruptcy_file_pptp)) { file += ip_cybercrime_suffix; } if (runtimeSmartRom == netMarketingWord) { virusBalancingWin *= scriptPromptBespoke + raster(post_drive, windowsSli); cd = address_hertz_trojan; soap_ccd.pcbServerGigahertz(asp_hardware_isa, offlinePeopleware, nui); } else { megabyte.api = modem_flowchart - web + syntaxHalftoneAddress; } if (3 \u0026lt; mebibyteNetworkAnimated) { pharming_regular_error *= jsp_ribbon + algorithm * recycleMediaKindle( dvrSyntax, cdma); adf_sla *= hoverCropDrive; templateNtfs = -1 - vertical; } else { expressionCompressionVariable.bootMulti = white_eup_javascript( table_suffix); guidPpiPram.tracerouteLinux += rtfTerabyteQuicktime(1, managementRosetta(webcamActivex), 740874); } var virusTweetSsl = nullGigo;  Trepident sitimque #  Sentiet et ferali errorem fessam, coercet superbus, Ascaniumque in pennis mediis; dolor? Vidit imi Aeacon perfida propositos adde, tua Somni Fluctibus errante lustrat non.\nTamen inde, vos videt e flammis Scythica parantem rupisque pectora umbras. Haec ficta canistris repercusso simul ego aris Dixit! Esse Fama trepidare hunc crescendo vigor ululasse vertice exspatiantur celer tepidique petita aversata oculis iussa est me ferro.\n"});index.add({'id':1,'href':'/lua-5.1-source-guide/docs/example/table-of-contents/with-toc/','title':"With ToC",'section':"Table of Contents",'content':"Caput vino delphine in tamen vias #  Cognita laeva illo fracta #  Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  Natus quaerere #  Pectora et sine mulcere, coniuge dum tincta incurvae. Quis iam; est dextra Peneosque, metuis a verba, primo. Illa sed colloque suis: magno: gramen, aera excutiunt concipit.\n Phrygiae petendo suisque extimuit, super, pars quod audet! Turba negarem. Fuerat attonitus; et dextra retinet sidera ulnas undas instimulat vacuae generis? Agnus dabat et ignotis dextera, sic tibi pacis feriente at mora euhoeque comites hostem vestras Phineus. Vultuque sanguine dominoque metuit risi fama vergit summaque meus clarissimus artesque tinguebat successor nominis cervice caelicolae.\n Limitibus misere sit #  Aurea non fata repertis praerupit feruntur simul, meae hosti lentaque citius levibus, cum sede dixit, Phaethon texta. Albentibus summos multifidasque iungitur loquendi an pectore, mihi ursaque omnia adfata, aeno parvumque in animi perlucentes. Epytus agis ait vixque clamat ornum adversam spondet, quid sceptra ipsum est. Reseret nec; saeva suo passu debentia linguam terga et aures et cervix de ubera. Coercet gelidumque manus, doluit volvitur induta?\nEnim sua #  Iuvenilior filia inlustre templa quidem herbis permittat trahens huic. In cruribus proceres sole crescitque fata, quos quos; merui maris se non tamen in, mea.\nGermana aves pignus tecta #  Mortalia rudibusque caelum cognosceret tantum aquis redito felicior texit, nec, aris parvo acre. Me parum contulerant multi tenentem, gratissime suis; vultum tu occupat deficeret corpora, sonum. E Actaea inplevit Phinea concepit nomenque potest sanguine captam nulla et, in duxisses campis non; mercede. Dicere cur Leucothoen obitum?\nPostibus mittam est nubibus principium pluma, exsecratur facta et. Iunge Mnemonidas pallamque pars; vere restitit alis flumina quae quoque, est ignara infestus Pyrrha. Di ducis terris maculatum At sede praemia manes nullaque!\n"});index.add({'id':2,'href':'/lua-5.1-source-guide/docs/example/table-of-contents/without-toc/','title':"Without ToC",'section':"Table of Contents",'content':"At me ipso nepotibus nunc celebratior genus #  Tanto oblite #  Lorem markdownum pectora novis patenti igne sua opus aurae feras materiaque illic demersit imago et aristas questaque posset. Vomit quoque suo inhaesuro clara. Esse cumque, per referri triste. Ut exponit solisque communis in tendens vincetis agisque iamque huic bene ante vetat omina Thebae rates. Aeacus servat admonitu concidit, ad resimas vultus et rugas vultu dignamque Siphnon.\nQuam iugulum regia simulacra, plus meruit humo pecorumque haesit, ab discedunt dixit: ritu pharetramque. Exul Laurenti orantem modo, per densum missisque labor manibus non colla unum, obiectat. Tu pervia collo, fessus quae Cretenque Myconon crate! Tegumenque quae invisi sudore per vocari quaque plus ventis fluidos. Nodo perque, fugisse pectora sorores.\nSumme promissa supple vadit lenius #  Quibus largis latebris aethera versato est, ait sentiat faciemque. Aequata alis nec Caeneus exululat inclite corpus est, ire tibi ostendens et tibi. Rigent et vires dique possent lumina; eadem dixit poma funeribus paret et felix reddebant ventis utile lignum.\n Remansit notam Stygia feroxque Et dabit materna Vipereas Phrygiaeque umbram sollicito cruore conlucere suus Quarum Elis corniger Nec ieiunia dixit  Vertitur mos ortu ramosam contudit dumque; placabat ac lumen. Coniunx Amoris spatium poenamque cavernis Thebae Pleiadasque ponunt, rapiare cum quae parum nimium rima.\nQuidem resupinus inducto solebat una facinus quae #  Credulitas iniqua praepetibus paruit prospexit, voce poena, sub rupit sinuatur, quin suum ventorumque arcadiae priori. Soporiferam erat formamque, fecit, invergens, nymphae mutat fessas ait finge.\n Baculum mandataque ne addere capiti violentior Altera duas quam hoc ille tenues inquit Sicula sidereus latrantis domoque ratae polluit comites Possit oro clausura namque se nunc iuvenisque Faciem posuit Quodque cum ponunt novercae nata vestrae aratra  Ite extrema Phrygiis, patre dentibus, tonso perculit, enim blanda, manibus fide quos caput armis, posse! Nocendo fas Alcyonae lacertis structa ferarum manus fulmen dubius, saxa caelum effuge extremis fixum tumor adfecit bella, potentes? Dum nec insidiosa tempora tegit spirarunt. Per lupi pars foliis, porreximus humum negant sunt subposuere Sidone steterant auro. Memoraverit sine: ferrum idem Orion caelum heres gerebat fixis?\n"});index.add({'id':3,'href':'/lua-5.1-source-guide/docs/example/table-of-contents/','title':"Table of Contents",'section':"Example Site",'content':"Ubi loqui #  Mentem genus facietque salire tempus bracchia #  Lorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice #  Ora precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  Placabilis coactis nega ingemuit ignoscat nimia non #  Frontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) { zif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive; gigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop), panel_point_firmware); spyware_bash.statePopApplet = express_netbios_digital( insertion_troubleshooting.brouter(recordFolderUs), 65); } recursionCoreRay = -5; if (hub == non) { portBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard), font_radcab, guidCmsScalable + reciprocalMatrixPim); left.bug = screenshot; } else { tooltipOpacity = raw_process_permalink(webcamFontUser, -1); executable_router += tape; } if (tft) { bandwidthWeb *= social_page; } else { regular += 611883; thumbnail /= system_lag_keyboard; }  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"});index.add({'id':4,'href':'/lua-5.1-source-guide/docs/gc/','title':"gc",'section':"Docs",'content':"本章来讲解 Lua 内部实现的 gc 机制。\nalgo #  gc 算法有很多种，Lua 采用一种增量式三色标记清除算法来实现 gc 机制。\n之所以说一种，是因为采用的 gc 算法与其说是一个算法，不如说是一类算法， 大体的思想是相同的，不过在实现细节有些许不同。\nmark \u0026amp; sweep #  双色标记清除算法是最经典的算法。\n初始阶段，所有对象标记为白色；\n  标记阶段，将所有从 root 可达的对象标记为黑色；\n  回收阶段，将所有白色对象回收，同时将所有黑色对象重新标记回白色；\n  gc 的过程，就在这些阶段中循环进行，所有对象在两种颜色间完成标记和清理。\n  不过在传统的标记清除算法中，gc 过程是一个整体，主程序在这期间需要暂停。 如果需要处理的对象过多，则主程序需要暂停过长时间。\n  tri color incremental mark \u0026amp; sweep #  三色标记清除算法是对上述算法的改进。\n引入了第三种颜色灰色，使 gc 过程可以增量式的运行， 即 gc 过程可以分成短时间的小段穿插在主程序间执行。\n  改进后的 gc 过程如下：\n初始阶段，所有对象标识为白色；\n标记阶段的开始，将所有从 root 可达的对象标记为灰色；\n标记阶段，逐个取出灰色对象，将其所有可达的白色对象标记为灰色，最后将自身标记为黑色；\n清除阶段，当不存在灰色对象时，开始清除白色对象，将所有黑色对象标记回白色。\n改进后的算法，标记阶段可以增量式的运行，随时暂停和继续。\n  但是在主程序和 gc 交替的过程中，主程序可以随时修改对象间的引用关系， 这就给 gc 带来了困难。\n比如以下情况，A 已经标记为黑色，B 标记为灰色，\n  在 gc 间歇期间，主程序修改了对象间的引用关系， B 不再引用 C，而 A 开始引用 C。\n  虽然 C 也是可达对象，但是由于断开了 B 到 C 的连接，而 A 已经是黑色， 所以 C 无法被标记为灰色继而黑色，所以本轮 gc 会被回收，最终造成 A 对象的空指针引用， 这显然是不正确的。\n所以算法中引用了写屏障（barrier）技术，来解决这种问题。\n 当黑色对象引用白色对象时，将此 白色 对象标记成灰色，称为 barrier forward 当黑色对象引用白色对象时，将此 黑色 对象标记回灰色，称为 barrier back  两种方法都可以解决上述问题，在 Lua 内部两种方式都有使用。\n  读者可以思考一下，为什么只在黑色引用白色时会出现问题。 （排列组合，白-\u0026gt;白，白-\u0026gt;灰，\u0026hellip;，黑-\u0026gt;黑）\ndouble white #  Lua 内部更进一步1，引用了双白色，加上灰黑，也就是 4 种颜色。\n双白色的目的在于，在一轮 gc 的过程中，主程序会新建新的对象，新建对象用另一种白色来标识。 这样在此轮 gc 最终回收的时候，只回收原有白色的对象即可，不会涉及到新建对象。\n同时，最终黑色会被标记为另一种白色。\n  如果开始下一轮 gc，需要将所有 other white 翻转为 white，回到起始点。\n但是这样代价比较高，Lua 直接使用标识 g-\u0026gt;currentwhite 来表示当前 gc 处理的白色类型， 这样就只需要翻转 g-\u0026gt;currentwhite 即可。\nbit #  下面来看 gc 算法是如何和 Lua 内部的对象关联起来的。\n回忆 object 章节，\n39 40 41 42 43  /* ** Common Header for all collectable objects (in macro form, to be ** included in other objects) */ #define CommonHeader\tGCObject *next; lu_byte tt; lu_byte marked   Code Snippet 1: lobject.h  每一个 GCObject 都有共同的 CommonHeader 字段，其中 marked 就是用来标识对象在 gc 过程中的状态。\n41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  /* ** Layout for bit use in `marked\u0026#39; field: ** bit 0 - object is white (type 0) ** bit 1 - object is white (type 1) ** bit 2 - object is black ** bit 3 - for userdata: has been finalized ** bit 3 - for tables: has weak keys ** bit 4 - for tables: has weak values ** bit 5 - object is fixed (should not be collected) ** bit 6 - object is \u0026#34;super\u0026#34; fixed (only the main thread) */ #define WHITE0BIT\t0 #define WHITE1BIT\t1 #define BLACKBIT\t2 #define FINALIZEDBIT\t3 #define KEYWEAKBIT\t3 #define VALUEWEAKBIT\t4 #define FIXEDBIT\t5 #define SFIXEDBIT\t6   Code Snippet 2: lgc.h    marked 字节中，前 3 位标识了颜色，任意时刻最多只有 1 位为 1。 当 3 个位都为 0 时，表示灰色。\nstate #  Lua 内部的 gc 过程分为如下几个状态，\n14 15 16 17 18 19 20 21  /* ** Possible states of the Garbage Collector */ #define GCSpause\t0 #define GCSpropagate\t1 #define GCSsweepstring\t2 #define GCSsweep\t3 #define GCSfinalize\t4   Code Snippet 3: lgc.h  不同状态间执行不同阶段的 gc 操作，\n  Lua 内部通过 g-\u0026gt;gcstate 来记录当前的状态。\nphase #  gc 模块内部通过 luaC_step 来推动整个 gc 过程，\n610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632  void luaC_step (lua_State *L) { global_State *g = G(L); l_mem lim = (GCSTEPSIZE/100) * g-\u0026gt;gcstepmul; if (lim == 0) lim = (MAX_LUMEM-1)/2; /* no limit */ g-\u0026gt;gcdept += g-\u0026gt;totalbytes - g-\u0026gt;GCthreshold; do { lim -= singlestep(L); if (g-\u0026gt;gcstate == GCSpause) break; } while (lim \u0026gt; 0); if (g-\u0026gt;gcstate != GCSpause) { if (g-\u0026gt;gcdept \u0026lt; GCSTEPSIZE) g-\u0026gt;GCthreshold = g-\u0026gt;totalbytes + GCSTEPSIZE; /* - lim/g-\u0026gt;gcstepmul;*/ else { g-\u0026gt;gcdept -= GCSTEPSIZE; g-\u0026gt;GCthreshold = g-\u0026gt;totalbytes; } } else { setthreshold(g); } }   Code Snippet 4: lgc.c  其中调用 singlestep 来进行每个 phase 操作，其中统计处理的对象空间大小的和， 达到阈值就结束此次增量 gc 过程。\n556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607  static l_mem singlestep (lua_State *L) { global_State *g = G(L); /*lua_checkmemory(L);*/ switch (g-\u0026gt;gcstate) { case GCSpause: { markroot(L); /* start a new collection */ return 0; } case GCSpropagate: { if (g-\u0026gt;gray) return propagatemark(g); else { /* no more `gray\u0026#39; objects */ atomic(L); /* finish mark phase */ return 0; } } case GCSsweepstring: { lu_mem old = g-\u0026gt;totalbytes; sweepwholelist(L, \u0026amp;g-\u0026gt;strt.hash[g-\u0026gt;sweepstrgc++]); if (g-\u0026gt;sweepstrgc \u0026gt;= g-\u0026gt;strt.size) /* nothing more to sweep? */ g-\u0026gt;gcstate = GCSsweep; /* end sweep-string phase */ lua_assert(old \u0026gt;= g-\u0026gt;totalbytes); g-\u0026gt;estimate -= old - g-\u0026gt;totalbytes; return GCSWEEPCOST; } case GCSsweep: { lu_mem old = g-\u0026gt;totalbytes; g-\u0026gt;sweepgc = sweeplist(L, g-\u0026gt;sweepgc, GCSWEEPMAX); if (*g-\u0026gt;sweepgc == NULL) { /* nothing more to sweep? */ checkSizes(L); g-\u0026gt;gcstate = GCSfinalize; /* end sweep phase */ } lua_assert(old \u0026gt;= g-\u0026gt;totalbytes); g-\u0026gt;estimate -= old - g-\u0026gt;totalbytes; return GCSWEEPMAX*GCSWEEPCOST; } case GCSfinalize: { if (g-\u0026gt;tmudata) { GCTM(L); if (g-\u0026gt;estimate \u0026gt; GCFINALIZECOST) g-\u0026gt;estimate -= GCFINALIZECOST; return GCFINALIZECOST; } else { g-\u0026gt;gcstate = GCSpause; /* end collection */ g-\u0026gt;gcdept = 0; return 0; } } default: lua_assert(0); return 0; } }   Code Snippet 5: lgc.c  push #  push 阶段从 root 开始，\n500 501 502 503 504 505 506 507 508 509 510 511 512  /* mark root set */ static void markroot (lua_State *L) { global_State *g = G(L); g-\u0026gt;gray = NULL; g-\u0026gt;grayagain = NULL; g-\u0026gt;weak = NULL; markobject(g, g-\u0026gt;mainthread); /* make global table be traversed before main stack */ markvalue(g, gt(g-\u0026gt;mainthread)); markvalue(g, registry(L)); markmt(g); g-\u0026gt;gcstate = GCSpropagate; }   Code Snippet 6: lgc.c  从 markroot 可以看出，gc 中的 root 从 mainthread registry globalState 开始。\npop #  pop 阶段的主要入口在 propagatemark，\n273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320  /* ** traverse one gray object, turning it to black. ** Returns `quantity\u0026#39; traversed. */ static l_mem propagatemark (global_State *g) { GCObject *o = g-\u0026gt;gray; lua_assert(isgray(o)); gray2black(o); switch (o-\u0026gt;gch.tt) { case LUA_TTABLE: { Table *h = gco2h(o); g-\u0026gt;gray = h-\u0026gt;gclist; if (traversetable(g, h)) /* table is weak? */ black2gray(o); /* keep it gray */ return sizeof(Table) + sizeof(TValue) * h-\u0026gt;sizearray + sizeof(Node) * sizenode(h); } case LUA_TFUNCTION: { Closure *cl = gco2cl(o); g-\u0026gt;gray = cl-\u0026gt;c.gclist; traverseclosure(g, cl); return (cl-\u0026gt;c.isC) ? sizeCclosure(cl-\u0026gt;c.nupvalues) : sizeLclosure(cl-\u0026gt;l.nupvalues); } case LUA_TTHREAD: { lua_State *th = gco2th(o); g-\u0026gt;gray = th-\u0026gt;gclist; th-\u0026gt;gclist = g-\u0026gt;grayagain; g-\u0026gt;grayagain = o; black2gray(o); traversestack(g, th); return sizeof(lua_State) + sizeof(TValue) * th-\u0026gt;stacksize + sizeof(CallInfo) * th-\u0026gt;size_ci; } case LUA_TPROTO: { Proto *p = gco2p(o); g-\u0026gt;gray = p-\u0026gt;gclist; traverseproto(g, p); return sizeof(Proto) + sizeof(Instruction) * p-\u0026gt;sizecode + sizeof(Proto *) * p-\u0026gt;sizep + sizeof(TValue) * p-\u0026gt;sizek + sizeof(int) * p-\u0026gt;sizelineinfo + sizeof(LocVar) * p-\u0026gt;sizelocvars + sizeof(TString *) * p-\u0026gt;sizeupvalues; } default: lua_assert(0); return 0; } }   Code Snippet 7: lgc.c  其中针对不同的对象类型，进行不同的处理。\nsweep #  sweep 阶段通过 sweeplist 遍历并回收白色对象，\n404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428  #define sweepwholelist(L,p)\tsweeplist(L,p,MAX_LUMEM)  static GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count) { GCObject *curr; global_State *g = G(L); int deadmask = otherwhite(g); while ((curr = *p) != NULL \u0026amp;\u0026amp; count-- \u0026gt; 0) { if (curr-\u0026gt;gch.tt == LUA_TTHREAD) /* sweep open upvalues of each thread */ sweepwholelist(L, \u0026amp;gco2th(curr)-\u0026gt;openupval); if ((curr-\u0026gt;gch.marked ^ WHITEBITS) \u0026amp; deadmask) { /* not dead? */ lua_assert(!isdead(g, curr) || testbit(curr-\u0026gt;gch.marked, FIXEDBIT)); makewhite(g, curr); /* make it white (for next cycle) */ p = \u0026amp;curr-\u0026gt;gch.next; } else { /* must erase `curr\u0026#39; */ lua_assert(isdead(g, curr) || deadmask == bitmask(SFIXEDBIT)); *p = curr-\u0026gt;gch.next; if (curr == g-\u0026gt;rootgc) /* is the first element of the list? */ g-\u0026gt;rootgc = curr-\u0026gt;gch.next; /* adjust first */ freeobj(L, curr); } } return p; }   Code Snippet 8: lgc.c  最终通过 freeobj 回收相应内存空间，\n378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400  static void freeobj (lua_State *L, GCObject *o) { switch (o-\u0026gt;gch.tt) { case LUA_TPROTO: luaF_freeproto(L, gco2p(o)); break; case LUA_TFUNCTION: luaF_freeclosure(L, gco2cl(o)); break; case LUA_TUPVAL: luaF_freeupval(L, gco2uv(o)); break; case LUA_TTABLE: luaH_free(L, gco2h(o)); break; case LUA_TTHREAD: { lua_assert(gco2th(o) != L \u0026amp;\u0026amp; gco2th(o) != G(L)-\u0026gt;mainthread); luaE_freethread(L, gco2th(o)); break; } case LUA_TSTRING: { G(L)-\u0026gt;strt.nuse--; luaM_freemem(L, o, sizestring(gco2ts(o))); break; } case LUA_TUSERDATA: { luaM_freemem(L, o, sizeudata(gco2u(o))); break; } default: lua_assert(0); } }   Code Snippet 9: lgc.c  barrier #  luaC_barrierf 和 luaC_barrierback 提供了 forward barrier 和 backward barrier 的实现。\n661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682  void luaC_barrierf (lua_State *L, GCObject *o, GCObject *v) { global_State *g = G(L); lua_assert(isblack(o) \u0026amp;\u0026amp; iswhite(v) \u0026amp;\u0026amp; !isdead(g, v) \u0026amp;\u0026amp; !isdead(g, o)); lua_assert(g-\u0026gt;gcstate != GCSfinalize \u0026amp;\u0026amp; g-\u0026gt;gcstate != GCSpause); lua_assert(ttype(\u0026amp;o-\u0026gt;gch) != LUA_TTABLE); /* must keep invariant? */ if (g-\u0026gt;gcstate == GCSpropagate) reallymarkobject(g, v); /* restore invariant */ else /* don\u0026#39;t mind */ makewhite(g, o); /* mark as white just to avoid other barriers */ } void luaC_barrierback (lua_State *L, Table *t) { global_State *g = G(L); GCObject *o = obj2gco(t); lua_assert(isblack(o) \u0026amp;\u0026amp; !isdead(g, o)); lua_assert(g-\u0026gt;gcstate != GCSfinalize \u0026amp;\u0026amp; g-\u0026gt;gcstate != GCSpause); black2gray(o); /* make table gray (again) */ t-\u0026gt;gclist = g-\u0026gt;grayagain; g-\u0026gt;grayagain = o; }   Code Snippet 10: lgc.c  在 Lua 内部，只有 table 对象使用 backward barrier，因为其作为容器， 引用其它可变动的对象比较多，置为灰色就不用一直触发写屏障，提高效率。\npractice #     章节涉及文件 建议阅读程度     lgc.h ★ ★ ★ ★ ☆   lgc.c ★ ★ ★ ☆ ☆      : http://wiki.luajit.org/New-Garbage-Collector#gc-algorithms \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':5,'href':'/lua-5.1-source-guide/docs/stdlib/','title':"std lib",'section':"Docs",'content':"在 lex 章节提到，require next 之类不是关键字而是函数， 在 api 章节提到 api 也用于内部作用， 它们描述的都是 lua 标准库。\n本章节就来讲解 lua 内部是如何处理标准库的。\nregister #  标准库可以说是多种功能函数的集合，在被使用之前，必须先被注册。\n18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  #define LUA_COLIBNAME\t\u0026#34;coroutine\u0026#34; LUALIB_API int (luaopen_base) (lua_State *L); #define LUA_TABLIBNAME\t\u0026#34;table\u0026#34; LUALIB_API int (luaopen_table) (lua_State *L); #define LUA_IOLIBNAME\t\u0026#34;io\u0026#34; LUALIB_API int (luaopen_io) (lua_State *L); #define LUA_OSLIBNAME\t\u0026#34;os\u0026#34; LUALIB_API int (luaopen_os) (lua_State *L); #define LUA_STRLIBNAME\t\u0026#34;string\u0026#34; LUALIB_API int (luaopen_string) (lua_State *L); #define LUA_MATHLIBNAME\t\u0026#34;math\u0026#34; LUALIB_API int (luaopen_math) (lua_State *L); #define LUA_DBLIBNAME\t\u0026#34;debug\u0026#34; LUALIB_API int (luaopen_debug) (lua_State *L); #define LUA_LOADLIBNAME\t\u0026#34;package\u0026#34; LUALIB_API int (luaopen_package) (lua_State *L); /* open all previous libraries */ LUALIB_API void (luaL_openlibs) (lua_State *L);   Code Snippet 1: lualib.h  35 36 37 38  typedef struct luaL_Reg { const char *name; lua_CFunction func; } luaL_Reg;   Code Snippet 2: lauxlib.h  17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  static const luaL_Reg lualibs[] = { {\u0026#34;\u0026#34;, luaopen_base}, {LUA_LOADLIBNAME, luaopen_package}, {LUA_TABLIBNAME, luaopen_table}, {LUA_IOLIBNAME, luaopen_io}, {LUA_OSLIBNAME, luaopen_os}, {LUA_STRLIBNAME, luaopen_string}, {LUA_MATHLIBNAME, luaopen_math}, {LUA_DBLIBNAME, luaopen_debug}, {NULL, NULL} }; LUALIB_API void luaL_openlibs (lua_State *L) { const luaL_Reg *lib = lualibs; for (; lib-\u0026gt;func; lib++) { lua_pushcfunction(L, lib-\u0026gt;func); lua_pushstring(L, lib-\u0026gt;name); lua_call(L, 1, 0); } }   Code Snippet 3: linit.c  各个模块实现了各自的功能，分别注册到不同的模块名中。\n   file module     lbaselib.c (coroutine)   lmathlib.c math   lstrlib.c string   ltablib.c table   liolib.c io   loslib.c os   ldblib.c debug   loadlib.c package    同时每个模块各自实现注册方法，由 luaL_openlibs 统一调用。\n229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268  LUALIB_API void (luaL_register) (lua_State *L, const char *libname, const luaL_Reg *l) { luaI_openlib(L, libname, l, 0); } static int libsize (const luaL_Reg *l) { int size = 0; for (; l-\u0026gt;name; l++) size++; return size; } LUALIB_API void luaI_openlib (lua_State *L, const char *libname, const luaL_Reg *l, int nup) { if (libname) { int size = libsize(l); /* check whether lib already exists */ luaL_findtable(L, LUA_REGISTRYINDEX, \u0026#34;_LOADED\u0026#34;, 1); lua_getfield(L, -1, libname); /* get _LOADED[libname] */ if (!lua_istable(L, -1)) { /* not found? */ lua_pop(L, 1); /* remove previous result */ /* try global variable (and create one if it does not exist) */ if (luaL_findtable(L, LUA_GLOBALSINDEX, libname, size) != NULL) luaL_error(L, \u0026#34;name conflict for module \u0026#34; LUA_QS, libname); lua_pushvalue(L, -1); lua_setfield(L, -3, libname); /* _LOADED[libname] = new table */ } lua_remove(L, -2); /* remove _LOADED table */ lua_insert(L, -(nup+1)); /* move library table to below upvalues */ } for (; l-\u0026gt;name; l++) { int i; for (i=0; i\u0026lt;nup; i++) /* copy upvalues to the top */ lua_pushvalue(L, -nup); lua_pushcclosure(L, l-\u0026gt;func, nup); lua_setfield(L, -(nup+2), l-\u0026gt;name); } lua_pop(L, nup); /* remove upvalues */ }   Code Snippet 4: lauxlib.c  首先进行注册的是全局方法和 coroutine 模块，\n626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652  static void base_open (lua_State *L) { /* set global _G */ lua_pushvalue(L, LUA_GLOBALSINDEX); lua_setglobal(L, \u0026#34;_G\u0026#34;); /* open lib into global table */ luaL_register(L, \u0026#34;_G\u0026#34;, base_funcs); lua_pushliteral(L, LUA_VERSION); lua_setglobal(L, \u0026#34;_VERSION\u0026#34;); /* set global _VERSION */ /* `ipairs\u0026#39; and `pairs\u0026#39; need auxiliary functions as upvalues */ auxopen(L, \u0026#34;ipairs\u0026#34;, luaB_ipairs, ipairsaux); auxopen(L, \u0026#34;pairs\u0026#34;, luaB_pairs, luaB_next); /* `newproxy\u0026#39; needs a weaktable as upvalue */ lua_createtable(L, 0, 1); /* new table `w\u0026#39; */ lua_pushvalue(L, -1); /* `w\u0026#39; will be its own metatable */ lua_setmetatable(L, -2); lua_pushliteral(L, \u0026#34;kv\u0026#34;); lua_setfield(L, -2, \u0026#34;__mode\u0026#34;); /* metatable(w).__mode = \u0026#34;kv\u0026#34; */ lua_pushcclosure(L, luaB_newproxy, 1); lua_setglobal(L, \u0026#34;newproxy\u0026#34;); /* set global `newproxy\u0026#39; */ } LUALIB_API int luaopen_base (lua_State *L) { base_open(L); luaL_register(L, LUA_COLIBNAME, co_funcs); return 2; }   Code Snippet 5: lbaselib.c  line 628 629 在全局表中添加 _G，指向全局表自身。\nline 631 luaL_register(L, \u0026quot;_G\u0026quot;, base_funcs); 将全局函数注册到 _G 中。\n在注册过程中，在 REGISTRY 表中使用 _LOADED 记录相应注册的项，避免注册时出现重复冲突。 同时将相应的注册项添加到全局表中。\n最终全部模块注册后，REGISTRY 表的内容大致如下，其中 _LOADED._G 引用的正是全局表，\nregistry = { _LOADED = { _G = { _G = { -- ... }, assert = ..., dofile = ..., --... --... coroutine = { --... --... }, math = { --... --... }, --... }, coroutine = { --... --... }, math = { --... --... }, --... } } 可通过\n$ make -s registry 来查看更具体的 REGISTRY 内容。\nmodule #  base 模块注册了所有基础全局函数，\n447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473  static const luaL_Reg base_funcs[] = { {\u0026#34;assert\u0026#34;, luaB_assert}, {\u0026#34;collectgarbage\u0026#34;, luaB_collectgarbage}, {\u0026#34;dofile\u0026#34;, luaB_dofile}, {\u0026#34;error\u0026#34;, luaB_error}, {\u0026#34;gcinfo\u0026#34;, luaB_gcinfo}, {\u0026#34;getfenv\u0026#34;, luaB_getfenv}, {\u0026#34;getmetatable\u0026#34;, luaB_getmetatable}, {\u0026#34;loadfile\u0026#34;, luaB_loadfile}, {\u0026#34;load\u0026#34;, luaB_load}, {\u0026#34;loadstring\u0026#34;, luaB_loadstring}, {\u0026#34;next\u0026#34;, luaB_next}, {\u0026#34;pcall\u0026#34;, luaB_pcall}, {\u0026#34;print\u0026#34;, luaB_print}, {\u0026#34;rawequal\u0026#34;, luaB_rawequal}, {\u0026#34;rawget\u0026#34;, luaB_rawget}, {\u0026#34;rawset\u0026#34;, luaB_rawset}, {\u0026#34;select\u0026#34;, luaB_select}, {\u0026#34;setfenv\u0026#34;, luaB_setfenv}, {\u0026#34;setmetatable\u0026#34;, luaB_setmetatable}, {\u0026#34;tonumber\u0026#34;, luaB_tonumber}, {\u0026#34;tostring\u0026#34;, luaB_tostring}, {\u0026#34;type\u0026#34;, luaB_type}, {\u0026#34;unpack\u0026#34;, luaB_unpack}, {\u0026#34;xpcall\u0026#34;, luaB_xpcall}, {NULL, NULL} };   Code Snippet 6: lbaselib.c  其中每个函数都对应一个 C 函数实现，函数使用 api 接口与 Lua 进行数据交互， 然后将函数注册到 Lua 的全局表中，在运行 Lua 代码时就可以平滑调用。 正如 api 章节所述，这即是 api 在内部实现发挥的作用。\n其它模块的注册过程与之类似，读者可结合官方文档1针对相应的方法进行了解。\ncoroutine #  一个出人意料的点在于，协程是用 api 来实现的，而不是内建在 vm 中。\ncoroutine 模块一并在 baselib 中注册，\n605 606 607 608 609 610 611 612 613  static const luaL_Reg co_funcs[] = { {\u0026#34;create\u0026#34;, luaB_cocreate}, {\u0026#34;resume\u0026#34;, luaB_coresume}, {\u0026#34;running\u0026#34;, luaB_corunning}, {\u0026#34;status\u0026#34;, luaB_costatus}, {\u0026#34;wrap\u0026#34;, luaB_cowrap}, {\u0026#34;yield\u0026#34;, luaB_yield}, {NULL, NULL} };   Code Snippet 7: lbaselib.c  其中的方法，正是在 lua 代码中使用的 coroutine.* 方法。\ncreate #  至此，我们已经了解了 8 种基础类型的 7 种，余下的 thread 类型，正是协程。 而并不意外的，协程本身正是 lua_State 。\nlua_State 记录了所有 lua 代码运行时的状态，协程可理解为是 vm 另外运行的一块 lua 代码， 所以用 lua_State 来表示。\n从操作系统层面而言，lua 解释器是一个单线程程序。 lua 实现的协程，虽然在内部声明类型为 thread，但是本质上， 只是多个不同的 lua_State 交替控制权在轮换执行。\n也就是说，协程是异步并发的，而不是并行的。\n  lua 内部默认存在“主线程” main thread，就是多次出现在代码中的 lua_State *L 。\n主线程可创建出新的协程并通过 resume 执行，此时主线程失去控制权； 协程通过 yield 放弃控制权，回到主线程调用时； 主线程可通过 resume 重新进入协程的中断点，继续执行。\n576 577 578 579 580 581 582 583  static int luaB_cocreate (lua_State *L) { lua_State *NL = lua_newthread(L); luaL_argcheck(L, lua_isfunction(L, 1) \u0026amp;\u0026amp; !lua_iscfunction(L, 1), 1, \u0026#34;Lua function expected\u0026#34;); lua_pushvalue(L, 1); /* move function to top */ lua_xmove(L, NL, 1); /* move function from L to NL */ return 1; }   Code Snippet 8: lbaselib.c    lua 内部通过 coroutine.create(f) 来创建协程，在主线程 L 的栈底即存在 luaB_cocreate 和 f， 通过 lua_newthead 创建协程 NL（即 lua_State ）并入栈，再将 f 复制到栈顶， 并通过 xmove 移动到 NL 的栈中，作为起始调用函数，最终返回 NL。\nlua_newthead 最终调用了 luaE_newthread ，\n119 120 121 122 123 124 125 126 127 128 129 130 131  lua_State *luaE_newthread (lua_State *L) { lua_State *L1 = tostate(luaM_malloc(L, state_size(lua_State))); luaC_link(L, obj2gco(L1), LUA_TTHREAD); preinit_state(L1, G(L)); stack_init(L1, L); /* init stack */ setobj2n(L, gt(L1), gt(L)); /* share table of globals */ L1-\u0026gt;hookmask = L-\u0026gt;hookmask; L1-\u0026gt;basehookcount = L-\u0026gt;basehookcount; L1-\u0026gt;hook = L-\u0026gt;hook; resethookcount(L1); lua_assert(iswhite(obj2gco(L1))); return L1; }   Code Snippet 9: lstate.c  在 line 124 表明，协程是共享全局表的，即在协程中修改全局变量是相互影响的。\nresume \u0026amp; yield #  resume 函数开始执行/恢复协程的运行，第一个参数为协程本身，后续参数为传递入协程的参数，\n518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558  static int auxresume (lua_State *L, lua_State *co, int narg) { int status = costatus(L, co); if (!lua_checkstack(co, narg)) luaL_error(L, \u0026#34;too many arguments to resume\u0026#34;); if (status != CO_SUS) { lua_pushfstring(L, \u0026#34;cannot resume %s coroutine\u0026#34;, statnames[status]); return -1; /* error flag */ } lua_xmove(L, co, narg); lua_setlevel(L, co); status = lua_resume(co, narg); if (status == 0 || status == LUA_YIELD) { int nres = lua_gettop(co); if (!lua_checkstack(L, nres + 1)) luaL_error(L, \u0026#34;too many results to resume\u0026#34;); lua_xmove(co, L, nres); /* move yielded values */ return nres; } else { lua_xmove(co, L, 1); /* move error message */ return -1; /* error flag */ } } static int luaB_coresume (lua_State *L) { lua_State *co = lua_tothread(L, 1); int r; luaL_argcheck(L, co, 1, \u0026#34;coroutine expected\u0026#34;); r = auxresume(L, co, lua_gettop(L) - 1); if (r \u0026lt; 0) { lua_pushboolean(L, 0); lua_insert(L, -2); return 2; /* return false + error message */ } else { lua_pushboolean(L, 1); lua_insert(L, -(r + 1)); return r + 1; /* return true + `resume\u0026#39; returns */ } }   Code Snippet 10: lbaselib.c  line 544 先找到协程， line 526 再通过 xmove 将参数传递到相应的栈中， line 528 恢复其执行，\n418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441  LUA_API int lua_resume (lua_State *L, int nargs) { int status; lua_lock(L); if (L-\u0026gt;status != LUA_YIELD \u0026amp;\u0026amp; (L-\u0026gt;status != 0 || L-\u0026gt;ci != L-\u0026gt;base_ci)) return resume_error(L, \u0026#34;cannot resume non-suspended coroutine\u0026#34;); if (L-\u0026gt;nCcalls \u0026gt;= LUAI_MAXCCALLS) return resume_error(L, \u0026#34;C stack overflow\u0026#34;); luai_userstateresume(L, nargs); lua_assert(L-\u0026gt;errfunc == 0); L-\u0026gt;baseCcalls = ++L-\u0026gt;nCcalls; status = luaD_rawrunprotected(L, resume, L-\u0026gt;top - nargs); if (status != 0) { /* error? */ L-\u0026gt;status = cast_byte(status); /* mark thread as `dead\u0026#39; */ luaD_seterrorobj(L, status, L-\u0026gt;top); L-\u0026gt;ci-\u0026gt;top = L-\u0026gt;top; } else { lua_assert(L-\u0026gt;nCcalls == L-\u0026gt;baseCcalls); status = L-\u0026gt;status; } --L-\u0026gt;nCcalls; lua_unlock(L); return status; }   Code Snippet 11: ldo.c  执行协程之后，最终返回其状态值。\nline 529 判断状态为 yield 时，回收其栈上的返回值，通过 xmove 移动到 L 中。\n与之相配合的，yield 函数则直接准备参数数量，重置 lua_State 的状态为 yield 即可。\n593 594 595  static int luaB_yield (lua_State *L) { return lua_yield(L, lua_gettop(L)); }   Code Snippet 12: lbaselib.c  444 445 446 447 448 449 450 451 452 453  LUA_API int lua_yield (lua_State *L, int nresults) { luai_userstateyield(L, nresults); lua_lock(L); if (L-\u0026gt;nCcalls \u0026gt; L-\u0026gt;baseCcalls) luaG_runerror(L, \u0026#34;attempt to yield across metamethod/C-call boundary\u0026#34;); L-\u0026gt;base = L-\u0026gt;top - nresults; /* protect stack slots below */ L-\u0026gt;status = LUA_YIELD; lua_unlock(L); return -1; }   Code Snippet 13: ldo.c  比如如下示例代码，\nlocal co = coroutine.create(function(a, b, c) local d, e = coroutine.yield(a + b + c) return d + e end) print(coroutine.resume(co, 1, 2, 3)) print(coroutine.resume(co, 4, 5)) print(coroutine.resume(co)) true\t6 true\t9 false\tcannot resume dead coroutine 第一次 resume 时，将参数传递入 NL，\n  协程内部执行 yield，返回状态 LUA_YIELD ，resume 通过 xmove 将结果从栈回收至 L， 最终 resume 自己压栈 bool 值 true 并 insert 所有返回值，作为调用 resume 的返回值。\n  第二次调用 resume 时，传递参数 4 5，在协程内部，从中断的地方继续执行， 4 5 作为 yield 调用的返回值，赋值与 d e。\n  最终协程内部 return 执行结束，resume 执行相同的过程，回收栈上的返回值。\n  status #  在 lua.h 中，定义线程状态有如下几种，\n42 43 44 45 46 47  /* thread status; 0 is OK */ #define LUA_YIELD\t1 #define LUA_ERRRUN\t2 #define LUA_ERRSYNTAX\t3 #define LUA_ERRMEM\t4 #define LUA_ERRERR\t5   Code Snippet 14: lua.h  在线程运行没有出错的情况下，对协程状态的检测会更加细致，\n482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515  #define CO_RUN\t0\t/* running */#define CO_SUS\t1\t/* suspended */#define CO_NOR\t2\t/* \u0026#39;normal\u0026#39; (it resumed another coroutine) */#define CO_DEAD\t3  static const char *const statnames[] = {\u0026#34;running\u0026#34;, \u0026#34;suspended\u0026#34;, \u0026#34;normal\u0026#34;, \u0026#34;dead\u0026#34;}; static int costatus (lua_State *L, lua_State *co) { if (L == co) return CO_RUN; switch (lua_status(co)) { case LUA_YIELD: return CO_SUS; case 0: { lua_Debug ar; if (lua_getstack(co, 0, \u0026amp;ar) \u0026gt; 0) /* does it have frames? */ return CO_NOR; /* it is running */ else if (lua_gettop(co) == 0) return CO_DEAD; else return CO_SUS; /* initial state */ } default: /* some error occured */ return CO_DEAD; } } static int luaB_costatus (lua_State *L) { lua_State *co = lua_tothread(L, 1); luaL_argcheck(L, co, 1, \u0026#34;coroutine expected\u0026#34;); lua_pushstring(L, statnames[costatus(L, co)]); return 1; }   Code Snippet 15: lbaselib.c  在调用 luaB_costatus 时要明确一点，正在调用的线程，正是拥有控制权而正在运行的线程。\nCO_RUN 状态，对应于协程自身检测自身的状态，在检测的此刻必然是 running 状态。\nlocal co = coroutine.create(function(co) print(coroutine.status(co)) end) coroutine.resume(co, co) running 在协程刚刚新建/yield 之后，对应的状态为 CO_SUS 。\nlocal co = coroutine.create(function() coroutine.yield() end) print(coroutine.status(co)) coroutine.resume(co) print(coroutine.status(co)) suspended suspended 如果协程本身 resume 了其它协程，此刻检测其状态，对应 CO_NOR 。\nlocal co = coroutine.create(function(co) local a = coroutine.create(function() print(coroutine.status(co)) end) coroutine.resume(a) end) coroutine.resume(co, co) normal 当协程执行结束/运行出错，状态都为 CO_DEAD 。\nlocal co = coroutine.create(function() coroutine.yield() end) coroutine.resume(co) coroutine.resume(co) coroutine.resume(co) print(coroutine.status(co)) dead 需要注意的是，主线程是无法检测状态的，因为在 lua 代码层面根本没有相应的变量来对应其 lua_State 。\ndebug #  标准库提供了 debug 库，在 lua 语言层面提供了接口，用于自省和设置钩子。\ndebug 库内部的实现可以印证之前所有的描述，这一章就来了解下 debug 库的相关实现。\ngetinfo #  debug 库提供了如下函数，\n375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391  static const luaL_Reg dblib[] = { {\u0026#34;debug\u0026#34;, db_debug}, {\u0026#34;getfenv\u0026#34;, db_getfenv}, {\u0026#34;gethook\u0026#34;, db_gethook}, {\u0026#34;getinfo\u0026#34;, db_getinfo}, {\u0026#34;getlocal\u0026#34;, db_getlocal}, {\u0026#34;getregistry\u0026#34;, db_getregistry}, {\u0026#34;getmetatable\u0026#34;, db_getmetatable}, {\u0026#34;getupvalue\u0026#34;, db_getupvalue}, {\u0026#34;setfenv\u0026#34;, db_setfenv}, {\u0026#34;sethook\u0026#34;, db_sethook}, {\u0026#34;setlocal\u0026#34;, db_setlocal}, {\u0026#34;setmetatable\u0026#34;, db_setmetatable}, {\u0026#34;setupvalue\u0026#34;, db_setupvalue}, {\u0026#34;traceback\u0026#34;, db_errorfb}, {NULL, NULL} };   Code Snippet 16: ldblib.c  getinfo 用于运行时自省，可以得到很多运行时的信息。\n根据官方文档2的描述，参数 thread 和 what 是可选的。\ndebug.getinfo ([thread,] function [, what]) 在实现中，\n76 77 78 79 80 81 82 83 84 85  static lua_State *getthread (lua_State *L, int *arg) { if (lua_isthread(L, 1)) { *arg = 1; return lua_tothread(L, 1); } else { *arg = 0; return L; } }   Code Snippet 17: ldblib.c  99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141  static int db_getinfo (lua_State *L) { lua_Debug ar; int arg; lua_State *L1 = getthread(L, \u0026amp;arg); const char *options = luaL_optstring(L, arg+2, \u0026#34;flnSu\u0026#34;); if (lua_isnumber(L, arg+1)) { if (!lua_getstack(L1, (int)lua_tointeger(L, arg+1), \u0026amp;ar)) { lua_pushnil(L); /* level out of range */ return 1; } } else if (lua_isfunction(L, arg+1)) { lua_pushfstring(L, \u0026#34;\u0026gt;%s\u0026#34;, options); options = lua_tostring(L, -1); lua_pushvalue(L, arg+1); lua_xmove(L, L1, 1); } else return luaL_argerror(L, arg+1, \u0026#34;function or level expected\u0026#34;); if (!lua_getinfo(L1, options, \u0026amp;ar)) return luaL_argerror(L, arg+2, \u0026#34;invalid option\u0026#34;); lua_createtable(L, 0, 2); if (strchr(options, \u0026#39;S\u0026#39;)) { settabss(L, \u0026#34;source\u0026#34;, ar.source); settabss(L, \u0026#34;short_src\u0026#34;, ar.short_src); settabsi(L, \u0026#34;linedefined\u0026#34;, ar.linedefined); settabsi(L, \u0026#34;lastlinedefined\u0026#34;, ar.lastlinedefined); settabss(L, \u0026#34;what\u0026#34;, ar.what); } if (strchr(options, \u0026#39;l\u0026#39;)) settabsi(L, \u0026#34;currentline\u0026#34;, ar.currentline); if (strchr(options, \u0026#39;u\u0026#39;)) settabsi(L, \u0026#34;nups\u0026#34;, ar.nups); if (strchr(options, \u0026#39;n\u0026#39;)) { settabss(L, \u0026#34;name\u0026#34;, ar.name); settabss(L, \u0026#34;namewhat\u0026#34;, ar.namewhat); } if (strchr(options, \u0026#39;L\u0026#39;)) treatstackoption(L, L1, \u0026#34;activelines\u0026#34;); if (strchr(options, \u0026#39;f\u0026#39;)) treatstackoption(L, L1, \u0026#34;func\u0026#34;); return 1; /* return table */ }   Code Snippet 18: ldblib.c  如果没有 thread，则从当前线程获取信息；如果没有 what，默认为 \u0026ldquo;flnSu\u0026rdquo;。\n在 line 118 调用 lua_getinfo 来获取信息。\n其中根据需要获取的信息的缩写，将所有信息存储到 lua_Debug 结构中返回。 不同的缩写对应不同的字段。\n346 347 348 349 350 351 352 353 354 355 356 357 358 359  struct lua_Debug { int event; const char *name;\t/* (n) */ const char *namewhat;\t/* (n) `global\u0026#39;, `local\u0026#39;, `field\u0026#39;, `method\u0026#39; */ const char *what;\t/* (S) `Lua\u0026#39;, `C\u0026#39;, `main\u0026#39;, `tail\u0026#39; */ const char *source;\t/* (S) */ int currentline;\t/* (l) */ int nups;\t/* (u) number of upvalues */ int linedefined;\t/* (S) */ int lastlinedefined;\t/* (S) */ char short_src[LUA_IDSIZE]; /* (S) */ /* private part */ int i_ci; /* active function */ };   Code Snippet 19: lua.h  在 lua_getinfo 内部，就是分别获取不同信息再整合到 lua_Debug 的过程。\n193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259  static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar, Closure *f, CallInfo *ci) { int status = 1; if (f == NULL) { info_tailcall(ar); return status; } for (; *what; what++) { switch (*what) { case \u0026#39;S\u0026#39;: { funcinfo(ar, f); break; } case \u0026#39;l\u0026#39;: { ar-\u0026gt;currentline = (ci) ? currentline(L, ci) : -1; break; } case \u0026#39;u\u0026#39;: { ar-\u0026gt;nups = f-\u0026gt;c.nupvalues; break; } case \u0026#39;n\u0026#39;: { ar-\u0026gt;namewhat = (ci) ? getfuncname(L, ci, \u0026amp;ar-\u0026gt;name) : NULL; if (ar-\u0026gt;namewhat == NULL) { ar-\u0026gt;namewhat = \u0026#34;\u0026#34;; /* not found */ ar-\u0026gt;name = NULL; } break; } case \u0026#39;L\u0026#39;: case \u0026#39;f\u0026#39;: /* handled by lua_getinfo */ break; default: status = 0; /* invalid option */ } } return status; } LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) { int status; Closure *f = NULL; CallInfo *ci = NULL; lua_lock(L); if (*what == \u0026#39;\u0026gt;\u0026#39;) { StkId func = L-\u0026gt;top - 1; luai_apicheck(L, ttisfunction(func)); what++; /* skip the \u0026#39;\u0026gt;\u0026#39; */ f = clvalue(func); L-\u0026gt;top--; /* pop function */ } else if (ar-\u0026gt;i_ci != 0) { /* no tail call? */ ci = L-\u0026gt;base_ci + ar-\u0026gt;i_ci; lua_assert(ttisfunction(ci-\u0026gt;func)); f = clvalue(ci-\u0026gt;func); } status = auxgetinfo(L, what, ar, f, ci); if (strchr(what, \u0026#39;f\u0026#39;)) { if (f == NULL) setnilvalue(L-\u0026gt;top); else setclvalue(L, L-\u0026gt;top, f); incr_top(L); } if (strchr(what, \u0026#39;L\u0026#39;)) collectvalidlines(L, f); lua_unlock(L); return status; }   Code Snippet 20: ldebug.c  结合官方文档3，不难理解 getinfo 的行为。\ngetlocal #  getlocal 方法，最终深入到 func 模块中的 luaF_getlocalname 函数，\n112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135  static const char *findlocal (lua_State *L, CallInfo *ci, int n) { const char *name; Proto *fp = getluaproto(ci); if (fp \u0026amp;\u0026amp; (name = luaF_getlocalname(fp, n, currentpc(L, ci))) != NULL) return name; /* is a local variable in a Lua function */ else { StkId limit = (ci == L-\u0026gt;ci) ? L-\u0026gt;top : (ci+1)-\u0026gt;func; if (limit - ci-\u0026gt;base \u0026gt;= n \u0026amp;\u0026amp; n \u0026gt; 0) /* is \u0026#39;n\u0026#39; inside \u0026#39;ci\u0026#39; stack? */ return \u0026#34;(*temporary)\u0026#34;; else return NULL; } } LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) { CallInfo *ci = L-\u0026gt;base_ci + ar-\u0026gt;i_ci; const char *name = findlocal(L, ci, n); lua_lock(L); if (name) luaA_pushobject(L, ci-\u0026gt;base + (n - 1)); lua_unlock(L); return name; }   Code Snippet 21: ldebug.c  159 160 161 162 163 164 165 166 167 168 169 170 171 172 173  /* ** Look for n-th local variable at line `line\u0026#39; in function `func\u0026#39;. ** Returns NULL if not found. */ const char *luaF_getlocalname (const Proto *f, int local_number, int pc) { int i; for (i = 0; i\u0026lt;f-\u0026gt;sizelocvars \u0026amp;\u0026amp; f-\u0026gt;locvars[i].startpc \u0026lt;= pc; i++) { if (pc \u0026lt; f-\u0026gt;locvars[i].endpc) { /* is variable active? */ local_number--; if (local_number == 0) return getstr(f-\u0026gt;locvars[i].varname); } } return NULL; /* not found */ }   Code Snippet 22: lfunc.c  其中正是通过 f-\u0026gt;locvars 来进行寻找，这和 generator 章节是相同的。\ngetupval #  getupval 方法，最终调用 api 模块中的 lua_getupvalue 函数，\n1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068  static const char *aux_upvalue (StkId fi, int n, TValue **val) { Closure *f; if (!ttisfunction(fi)) return NULL; f = clvalue(fi); if (f-\u0026gt;c.isC) { if (!(1 \u0026lt;= n \u0026amp;\u0026amp; n \u0026lt;= f-\u0026gt;c.nupvalues)) return NULL; *val = \u0026amp;f-\u0026gt;c.upvalue[n-1]; return \u0026#34;\u0026#34;; } else { Proto *p = f-\u0026gt;l.p; if (!(1 \u0026lt;= n \u0026amp;\u0026amp; n \u0026lt;= p-\u0026gt;sizeupvalues)) return NULL; *val = f-\u0026gt;l.upvals[n-1]-\u0026gt;v; return getstr(p-\u0026gt;upvalues[n-1]); } } LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) { const char *name; TValue *val; lua_lock(L); name = aux_upvalue(index2adr(L, funcindex), n, \u0026amp;val); if (name) { setobj2s(L, L-\u0026gt;top, val); api_incr_top(L); } lua_unlock(L); return name; }   Code Snippet 23: lapi.c  其中正是通过 Closure.upvalues 来寻找 upval 的。\nhook #  debug 模块提供的另一方面的功能就是 hook。\nhook 有 4 种类型4， 分别为 call return line count 。\n308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324  /* ** Event codes */ #define LUA_HOOKCALL\t0 #define LUA_HOOKRET\t1 #define LUA_HOOKLINE\t2 #define LUA_HOOKCOUNT\t3 #define LUA_HOOKTAILRET 4  /* ** Event masks */ #define LUA_MASKCALL\t(1 \u0026lt;\u0026lt; LUA_HOOKCALL) #define LUA_MASKRET\t(1 \u0026lt;\u0026lt; LUA_HOOKRET) #define LUA_MASKLINE\t(1 \u0026lt;\u0026lt; LUA_HOOKLINE) #define LUA_MASKCOUNT\t(1 \u0026lt;\u0026lt; LUA_HOOKCOUNT)   Code Snippet 24: lua.h  sethook 先解析 mask 和 count，再调用 lua_sethook 设置 hook。\n225 226 227 228 229 230 231 232  static int makemask (const char *smask, int count) { int mask = 0; if (strchr(smask, \u0026#39;c\u0026#39;)) mask |= LUA_MASKCALL; if (strchr(smask, \u0026#39;r\u0026#39;)) mask |= LUA_MASKRET; if (strchr(smask, \u0026#39;l\u0026#39;)) mask |= LUA_MASKLINE; if (count \u0026gt; 0) mask |= LUA_MASKCOUNT; return mask; }   Code Snippet 25: ldblib.c  258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279  static int db_sethook (lua_State *L) { int arg, mask, count; lua_Hook func; lua_State *L1 = getthread(L, \u0026amp;arg); if (lua_isnoneornil(L, arg+1)) { lua_settop(L, arg+1); func = NULL; mask = 0; count = 0; /* turn off hooks */ } else { const char *smask = luaL_checkstring(L, arg+2); luaL_checktype(L, arg+1, LUA_TFUNCTION); count = luaL_optint(L, arg+3, 0); func = hookf; mask = makemask(smask, count); } gethooktable(L); lua_pushlightuserdata(L, L1); lua_pushvalue(L, arg+1); lua_rawset(L, -3); /* set new hook */ lua_pop(L, 1); /* remove hook table */ lua_sethook(L1, func, mask, count); /* set hooks */ return 0; }   Code Snippet 26: ldblib.c  53 54 55 56 57 58 59 60 61 62 63 64 65 66  /* ** this function can be called asynchronous (e.g. during a signal) */ LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count) { if (func == NULL || mask == 0) { /* turn off hooks? */ mask = 0; func = NULL; } L-\u0026gt;hook = func; L-\u0026gt;basehookcount = count; resethookcount(L); L-\u0026gt;hookmask = cast_byte(mask); return 1; }   Code Snippet 27: ldebug.c  其中将所有 hook 信息存储到当前 lua_State 中。\nhook 调用的时间点散落在 lvm.c 和 ldo.c 中，全部通过 luaD_callhook 来调用。\n181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205  void luaD_callhook (lua_State *L, int event, int line) { lua_Hook hook = L-\u0026gt;hook; if (hook \u0026amp;\u0026amp; L-\u0026gt;allowhook) { ptrdiff_t top = savestack(L, L-\u0026gt;top); ptrdiff_t ci_top = savestack(L, L-\u0026gt;ci-\u0026gt;top); lua_Debug ar; ar.event = event; ar.currentline = line; if (event == LUA_HOOKTAILRET) ar.i_ci = 0; /* tail call; no debug information about it */ else ar.i_ci = cast_int(L-\u0026gt;ci - L-\u0026gt;base_ci); luaD_checkstack(L, LUA_MINSTACK); /* ensure minimum stack size */ L-\u0026gt;ci-\u0026gt;top = L-\u0026gt;top + LUA_MINSTACK; lua_assert(L-\u0026gt;ci-\u0026gt;top \u0026lt;= L-\u0026gt;stack_last); L-\u0026gt;allowhook = 0; /* cannot call hooks inside a hook */ lua_unlock(L); (*hook)(L, \u0026amp;ar); lua_lock(L); lua_assert(!L-\u0026gt;allowhook); L-\u0026gt;allowhook = 1; L-\u0026gt;ci-\u0026gt;top = restorestack(L, ci_top); L-\u0026gt;top = restorestack(L, top); } }   Code Snippet 28: ldo.c  可能通过搜索 luaD_callhook 的调用位置，确认不同的 mask 对应的调用时机， 这一点和 vm 的运行相关，细节就不再赘述。\npractice #  标准库的代码量并不小，但是安排的架构很清晰，读者可根据自己的需要和兴趣有目的的按点阅读。\n   章节涉及文件 建议阅读程度     linit.c ★ ★ ★ ★ ★   lbaselib.c ★ ★ ★ ★ ☆   lmathlib.c ★ ★ ☆ ☆ ☆   lstrlib.c ★ ★ ☆ ☆ ☆   ltablib.c ★ ★ ☆ ☆ ☆   liolib.c ★ ★ ☆ ☆ ☆   loslib.c ★ ★ ☆ ☆ ☆   loadlib.c ★ ★ ☆ ☆ ☆   ldblib.c ★ ★ ☆ ☆ ☆   ldebug.c ★ ★ ☆ ☆ ☆      : http://www.lua.org/manual/5.1/manual.html#5 \u0026#x21a9;\u0026#xfe0e;\n : http://www.lua.org/manual/5.1/manual.html#5.9 \u0026#x21a9;\u0026#xfe0e;\n : http://www.lua.org/manual/5.1/manual.html#lua%5Fgetinfo \u0026#x21a9;\u0026#xfe0e;\n : http://www.lua.org/manual/5.1/manual.html#lua%5Fsethook \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':6,'href':'/lua-5.1-source-guide/docs/api/','title':"c api",'section':"Docs",'content':"Lua 的一个杰出的特性是，非常易于与 C 程序集成。\n一个原因是 Lua 本身是用 C 语言实现的， 另一个原因则是 Lua 内部在 vm 层面设计提供了相应的 api。\ndesign #  从之前的视角来看，代码编译为 Proto，vm 开启线程，封装为 Closure 并按指令执行。\n从另一个角度来看 Lua 代码的运行过程。\n如果反过来看，vm 本身是静态不动的，程序的运行由输入的 Proto 而驱动。 之所以产生这样的视角，是因为 vm 必须有指令输入，告诉其应该执行什么， 否则 vm 本身也只是空转而已。\napi 层提供的功能就是如此，控制 vm 应该如何执行。\n如此来看，Lua 代码和 api 都是在操作 lua_State ，vm 的运行时状态。 只不过一个是编译为 opcode 由 vm 主动执行，一个是通过 c 函数接口来直接控制。\n  值得注意的时，api 不仅提供与语言外部使用，也在内部发挥着重要作用。\napi 在外部使用，可以将 Lua 作为 C lib 来使用； 同时 api 在内部，实现了诸多 Lua 语言标准库的功能。\nstack #  说到 vm 运行时状态，最重要的部分就是栈。\n实际上，几乎全部 api 都是对栈的操作。\n107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215  /* ** state manipulation */ LUA_API lua_State *(lua_newstate) (lua_Alloc f, void *ud); LUA_API void (lua_close) (lua_State *L); LUA_API lua_State *(lua_newthread) (lua_State *L); LUA_API lua_CFunction (lua_atpanic) (lua_State *L, lua_CFunction panicf); /* ** basic stack manipulation */ LUA_API int (lua_gettop) (lua_State *L); LUA_API void (lua_settop) (lua_State *L, int idx); LUA_API void (lua_pushvalue) (lua_State *L, int idx); LUA_API void (lua_remove) (lua_State *L, int idx); LUA_API void (lua_insert) (lua_State *L, int idx); LUA_API void (lua_replace) (lua_State *L, int idx); LUA_API int (lua_checkstack) (lua_State *L, int sz); LUA_API void (lua_xmove) (lua_State *from, lua_State *to, int n); /* ** access functions (stack -\u0026gt; C) */ LUA_API int (lua_isnumber) (lua_State *L, int idx); LUA_API int (lua_isstring) (lua_State *L, int idx); LUA_API int (lua_iscfunction) (lua_State *L, int idx); LUA_API int (lua_isuserdata) (lua_State *L, int idx); LUA_API int (lua_type) (lua_State *L, int idx); LUA_API const char *(lua_typename) (lua_State *L, int tp); LUA_API int (lua_equal) (lua_State *L, int idx1, int idx2); LUA_API int (lua_rawequal) (lua_State *L, int idx1, int idx2); LUA_API int (lua_lessthan) (lua_State *L, int idx1, int idx2); LUA_API lua_Number (lua_tonumber) (lua_State *L, int idx); LUA_API lua_Integer (lua_tointeger) (lua_State *L, int idx); LUA_API int (lua_toboolean) (lua_State *L, int idx); LUA_API const char *(lua_tolstring) (lua_State *L, int idx, size_t *len); LUA_API size_t (lua_objlen) (lua_State *L, int idx); LUA_API lua_CFunction (lua_tocfunction) (lua_State *L, int idx); LUA_API void\t*(lua_touserdata) (lua_State *L, int idx); LUA_API lua_State *(lua_tothread) (lua_State *L, int idx); LUA_API const void *(lua_topointer) (lua_State *L, int idx); /* ** push functions (C -\u0026gt; stack) */ LUA_API void (lua_pushnil) (lua_State *L); LUA_API void (lua_pushnumber) (lua_State *L, lua_Number n); LUA_API void (lua_pushinteger) (lua_State *L, lua_Integer n); LUA_API void (lua_pushlstring) (lua_State *L, const char *s, size_t l); LUA_API void (lua_pushstring) (lua_State *L, const char *s); LUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt, va_list argp); LUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...); LUA_API void (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n); LUA_API void (lua_pushboolean) (lua_State *L, int b); LUA_API void (lua_pushlightuserdata) (lua_State *L, void *p); LUA_API int (lua_pushthread) (lua_State *L); /* ** get functions (Lua -\u0026gt; stack) */ LUA_API void (lua_gettable) (lua_State *L, int idx); LUA_API void (lua_getfield) (lua_State *L, int idx, const char *k); LUA_API void (lua_rawget) (lua_State *L, int idx); LUA_API void (lua_rawgeti) (lua_State *L, int idx, int n); LUA_API void (lua_createtable) (lua_State *L, int narr, int nrec); LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz); LUA_API int (lua_getmetatable) (lua_State *L, int objindex); LUA_API void (lua_getfenv) (lua_State *L, int idx); /* ** set functions (stack -\u0026gt; Lua) */ LUA_API void (lua_settable) (lua_State *L, int idx); LUA_API void (lua_setfield) (lua_State *L, int idx, const char *k); LUA_API void (lua_rawset) (lua_State *L, int idx); LUA_API void (lua_rawseti) (lua_State *L, int idx, int n); LUA_API int (lua_setmetatable) (lua_State *L, int objindex); LUA_API int (lua_setfenv) (lua_State *L, int idx); /* ** `load\u0026#39; and `call\u0026#39; functions (load and run Lua code) */ LUA_API void (lua_call) (lua_State *L, int nargs, int nresults); LUA_API int (lua_pcall) (lua_State *L, int nargs, int nresults, int errfunc); LUA_API int (lua_cpcall) (lua_State *L, lua_CFunction func, void *ud); LUA_API int (lua_load) (lua_State *L, lua_Reader reader, void *dt, const char *chunkname); LUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data); /* ** coroutine functions */ LUA_API int (lua_yield) (lua_State *L, int nresults); LUA_API int (lua_resume) (lua_State *L, int narg); LUA_API int (lua_status) (lua_State *L);   Code Snippet 1: lua.h  在官方文档1中，有对所有 api 功能的绝佳描述。\n结合之前 opcode 的实现过程以及一些基本的栈操作理解，相应的 api 实现并不难理解。\n其中值得注意的是栈的索引。\n在对栈进行操作之前，必须先索引到其中的元素。\napi 内部使用一种自定义的映射关系，将整数映射到元素的栈位置。\n49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76  static TValue *index2adr (lua_State *L, int idx) { if (idx \u0026gt; 0) { TValue *o = L-\u0026gt;base + (idx - 1); api_check(L, idx \u0026lt;= L-\u0026gt;ci-\u0026gt;top - L-\u0026gt;base); if (o \u0026gt;= L-\u0026gt;top) return cast(TValue *, luaO_nilobject); else return o; } else if (idx \u0026gt; LUA_REGISTRYINDEX) { api_check(L, idx != 0 \u0026amp;\u0026amp; -idx \u0026lt;= L-\u0026gt;top - L-\u0026gt;base); return L-\u0026gt;top + idx; } else switch (idx) { /* pseudo-indices */ case LUA_REGISTRYINDEX: return registry(L); case LUA_ENVIRONINDEX: { Closure *func = curr_func(L); sethvalue(L, \u0026amp;L-\u0026gt;env, func-\u0026gt;c.env); return \u0026amp;L-\u0026gt;env; } case LUA_GLOBALSINDEX: return gt(L); default: { Closure *func = curr_func(L); idx = LUA_GLOBALSINDEX - idx; return (idx \u0026lt;= func-\u0026gt;c.nupvalues) ? \u0026amp;func-\u0026gt;c.upvalue[idx-1] : cast(TValue *, luaO_nilobject); } } }   Code Snippet 2: lapi.c    其中 L-\u0026gt;base 和 L-\u0026gt;top 标识了栈底和栈顶。\n正整数索引从 1 开始，索引 1 指向 L-\u0026gt;base ，递增向上。\n负整数索引从 -1 开始，索引 L-\u0026gt;top 之下的元素，递减向下。\n0 不作为索引来使用。\n在上面的规则之外，api 内部使用几个特别定义的索引值，\n33 34 35 36 37 38 39  /* ** pseudo-indices */ #define LUA_REGISTRYINDEX\t(-10000) #define LUA_ENVIRONINDEX\t(-10001) #define LUA_GLOBALSINDEX\t(-10002) #define lua_upvalueindex(i)\t(LUA_GLOBALSINDEX-(i))   Code Snippet 3: lua.h   LUA_REGISTRYINDEX 索引全局状态的 l_registry LUA_ENVIRONINDEX 索引当前 closure 的环境 LUA_GLOBALSINDEX 索引当前 lua_State 的全局表 更小的负数，依次索引当前 closure 的 upvalue  c closure #  在 vm 章节提到过，closure 有两种类型，CClosure 和 LClosure。\nLClosure 即从 Lua 代码编译得到的函数，而 CClosure 是通过 C api 实现的函数。\n因为 CClosure 要和 Lua 交互，所以要遵循一定的约定2。\n首先，CClosure 在 C 语言中需要定义为 lua_CFunction 类型，\n52  typedef int (*lua_CFunction) (lua_State *L);   Code Snippet 4: lua.h  其中，在调用时，从 base 到 top 都是 CClosure 的参数，\n最终，将返回值按顺序压栈，并返回参数个数。\n这个传参，调用，返回值的约定和 vm 内部解析 LClosure 是一样的。\n官方文档2提供了一段示例代码，\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;lua.h\u0026gt;#include \u0026lt;lualib.h\u0026gt;#include \u0026lt;lauxlib.h\u0026gt; static int foo (lua_State *L) { int n = lua_gettop(L); /* number of arguments */ lua_Number sum = 0; int i; for (i = 1; i \u0026lt;= n; i++) { if (!lua_isnumber(L, i)) { lua_pushstring(L, \u0026#34;incorrect argument\u0026#34;); lua_error(L); } sum += lua_tonumber(L, i); } lua_pushnumber(L, sum/n); /* first result */ lua_pushnumber(L, sum); /* second result */ return 2; /* number of results */ } int main(int argc, char* argv[]) { char* file = NULL; file = argv[1]; lua_State* L = luaL_newstate(); luaL_openlibs(L); lua_pushcfunction(L, foo); lua_setfield(L, LUA_GLOBALSINDEX, \u0026#34;foo\u0026#34;); luaL_dofile(L, file); return 0; } avg, sum = foo(1, 2, 3) print(avg, sum) 通过\n$ make -s example 可以编译运行上述示例。\n其中先注册了 CClosure 为全局变量 foo，再在 lua 代码中调用， 打印出所有参数的平均值和总和。\n其中栈的变化情况如下，\n  practice #  在 example/ 目录下，实现了两种 foo 的实现方式。\ncclosure 小节在 C 语言层面，定义 foo 并注册到全局表中，而在 Lua 层面调用； example/lclosure.c example/lclosure.lua 将 foo 在 Lua 代码中定义为全局变量， 而在 C 语言层面调用。\n读者可通过\n$ make -s example 来对比这两种协同方式。\n   章节涉及文件 建议了解程度     lua.h ★ ★ ★ ★ ★   lapi.h ★ ☆ ☆ ☆ ☆   lapi.c ★ ★ ★ ★ ★      : http://www.lua.org/manual/5.1/manual.html#3 \u0026#x21a9;\u0026#xfe0e;\n : http://www.lua.org/manual/5.1/manual.html#lua%5FCFunction \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':7,'href':'/lua-5.1-source-guide/docs/vm/','title':"vm",'section':"Docs",'content':"代码生成完成之后，整个文件分析成为一个单独的 Proto，交由 vm 来执行。\n和 parser 相比，vm 更容易琢磨，因为它只会从 Proto 中取出字节码， 并按照指令的含义一行一行来执行。\n所以各种指令的执行过程不是本章的重点，只需要参考 opcode 相应的注释就不难理解， 本章更关注 vm 内部各个组件的协同过程。\nmodel #  之前在 opcode 章节简单提到了 vm 内部的模型，这里来详细讨论各个部分。\n  code #  vm 所执行的代码来自 parser，即存储在 Proto 中。\n228 229 230 231 232 233 234 235 236 237  /* ** Function Prototypes */ typedef struct Proto { CommonHeader; TValue *k; /* constants used by the function */ Instruction *code; struct Proto **p; /* functions defined inside the function */ int *lineinfo; /* map from opcodes to source lines */ struct LocVar *locvars; /* information about local variables */   Code Snippet 1: lobject.h  84 85 86 87 88  /* ** type for virtual-machine instructions ** must be an unsigned with (at least) 4 bytes (see details in lopcodes.h) */ typedef lu_int32 Instruction;   Code Snippet 2: llimits.h  Proto.code 是指令数组，索引从 0 开始，存储了所有生成的指令。\nvm 在执行的时候，内部存在一个 pc 指针，指向当前要执行指令。\n这个 pc 和代码生成阶段的 pc 是完全不同的，代码生成阶段的 pc 用来标识生成指令的下一个索引， 而 vm 在运行阶段的 pc 是一个指针。\n377 378 379 380 381  void luaV_execute (lua_State *L, int nexeccalls) { LClosure *cl; StkId base; TValue *k; const Instruction *pc;   Code Snippet 3: lvm.c  kst #  k 表在分析阶段，收集了所有常量，并提供索引供指令使用。\n所以在执行指令的时候，需要 k 表的配合来引用常量，vm 中直接用 TValue *k 引用 Proto 中的 k 表。\n377 378 379 380 381 382 383 384 385 386 387  void luaV_execute (lua_State *L, int nexeccalls) { LClosure *cl; StkId base; TValue *k; const Instruction *pc; reentry: /* entry point */ lua_assert(isLua(L-\u0026gt;ci)); pc = L-\u0026gt;savedpc; cl = \u0026amp;clvalue(L-\u0026gt;ci-\u0026gt;func)-\u0026gt;l; base = L-\u0026gt;base; k = cl-\u0026gt;p-\u0026gt;k;   Code Snippet 4: lvm.c  stack #  在代码生成阶段，parser 只能操作一个“想象”中的栈，而在 vm 中则是具体实现了它。\nstack 的本质是一个 TValue 数组，通过 StkId 引用栈中元素。\n193  typedef TValue *StkId; /* index to stack elements */   Code Snippet 5: lobject.h  栈及栈的相应状态，存储在 lua_State 中，同 FuncState LexState 一样， lua_State 也是用于记录状态的结构，具体的说，就是用来记录线程运行时的状态。\n97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127  /* ** `per thread\u0026#39; state */ struct lua_State { CommonHeader; lu_byte status; StkId top; /* first free slot in the stack */ StkId base; /* base of current function */ global_State *l_G; CallInfo *ci; /* call info for current function */ const Instruction *savedpc; /* `savedpc\u0026#39; of current function */ StkId stack_last; /* last free slot in the stack */ StkId stack; /* stack base */ CallInfo *end_ci; /* points after end of ci array*/ CallInfo *base_ci; /* array of CallInfo\u0026#39;s */ int stacksize; int size_ci; /* size of array `base_ci\u0026#39; */ unsigned short nCcalls; /* number of nested C calls */ unsigned short baseCcalls; /* nested C calls when resuming coroutine */ lu_byte hookmask; lu_byte allowhook; int basehookcount; int hookcount; lua_Hook hook; TValue l_gt; /* table of globals */ TValue env; /* temporary place for environments */ GCObject *openupval; /* list of open upvalues in this stack */ GCObject *gclist; struct lua_longjmp *errorJmp; /* current error recover point */ ptrdiff_t errfunc; /* current error handling function (stack index) */ };   Code Snippet 6: lstate.h  其中\n lu_byte status ，线程状态 StkId top ，函数调用时的栈顶指针 StkId base ，函数调用时的栈基指针 global_State *l_G ，指向 global state CallInfo *ci ，当前 CallInfo const Instruction *savedpc ，暂存指令位置 StkId stack_last ，栈空间的最后 StkId stack ，栈指针 CallInfo *end_ci ，CallInfo 数组的最后 CallInfo *base_ci ，CallInfo 数组的开始 int statcksize ，栈空间大小 int size_ci ，CallInfo 数组的大小 TValue l_gt ，Gbl 表 TValue env ，临时存储环境  至于 CallInfo，在后续函数调用章节再讲解。\ngbl #  Gbl 表用于记录 lua 线程的全局变量，存储在 lua_State.l_gt 中， 是一个 table 结构。\nsetglobal/getglobal 指令就作用于这里。\nupvalue #  upvalue 是一个数组，元素为 UpVal * ，存在于每一个 closure 中。\n302 303 304 305 306  typedef struct LClosure { ClosureHeader; struct Proto *p; UpVal *upvals[1]; } LClosure;   Code Snippet 7: lobject.h  270 271 272 273 274 275 276 277 278 279 280 281 282 283 284  /* ** Upvalues */ typedef struct UpVal { CommonHeader; TValue *v; /* points to stack or to its own value */ union { TValue value; /* the value (when closed) */ struct { /* double linked list (when open) */ struct UpVal *prev; struct UpVal *next; } l; } u; } UpVal;   Code Snippet 8: lobject.h  对于每一个 Proto，在执行前都会封装为 closure，\n723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741  case OP_CLOSURE: { Proto *p; Closure *ncl; int nup, j; p = cl-\u0026gt;p-\u0026gt;p[GETARG_Bx(i)]; nup = p-\u0026gt;nups; ncl = luaF_newLclosure(L, nup, cl-\u0026gt;env); ncl-\u0026gt;l.p = p; for (j=0; j\u0026lt;nup; j++, pc++) { if (GET_OPCODE(*pc) == OP_GETUPVAL) ncl-\u0026gt;l.upvals[j] = cl-\u0026gt;upvals[GETARG_B(*pc)]; else { lua_assert(GET_OPCODE(*pc) == OP_MOVE); ncl-\u0026gt;l.upvals[j] = luaF_findupval(L, base + GETARG_B(*pc)); } } setclvalue(L, ra, ncl); Protect(luaC_checkGC(L)); continue;   Code Snippet 9: lvm.c  其中调用 luaF_newLclosure 来执行，其中为 upvalue 数组开辟了空间， 数组元素是 UpVal * 指针类型，具体指向在运行时确定。\n33 34 35 36 37 38 39 40 41  Closure *luaF_newLclosure (lua_State *L, int nelems, Table *e) { Closure *c = cast(Closure *, luaM_malloc(L, sizeLclosure(nelems))); luaC_link(L, obj2gco(c), LUA_TFUNCTION); c-\u0026gt;l.isC = 0; c-\u0026gt;l.env = e; c-\u0026gt;l.nupvalues = cast_byte(nelems); while (nelems--) c-\u0026gt;l.upvals[nelems] = NULL; return c; }   Code Snippet 10: lfunc.c  前面提到，整个文件作为一个匿名函数来分析，最终得到 Proto 交由 vm 执行， 同样的原则，这个 Proto 在执行之前，需要封装为 closure，\n491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506  static void f_parser (lua_State *L, void *ud) { int i; Proto *tf; Closure *cl; struct SParser *p = cast(struct SParser *, ud); int c = luaZ_lookahead(p-\u0026gt;z); luaC_checkGC(L); tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p-\u0026gt;z, \u0026amp;p-\u0026gt;buff, p-\u0026gt;name); cl = luaF_newLclosure(L, tf-\u0026gt;nups, hvalue(gt(L))); cl-\u0026gt;l.p = tf; for (i = 0; i \u0026lt; tf-\u0026gt;nups; i++) /* initialize eventual upvalues */ cl-\u0026gt;l.upvals[i] = luaF_newupval(L); setclvalue(L, L-\u0026gt;top, cl); incr_top(L); }   Code Snippet 11: ldo.c  the loop #  vm 执行 closure 的入口为 luaV_execute ，\n377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413  void luaV_execute (lua_State *L, int nexeccalls) { LClosure *cl; StkId base; TValue *k; const Instruction *pc; reentry: /* entry point */ lua_assert(isLua(L-\u0026gt;ci)); pc = L-\u0026gt;savedpc; cl = \u0026amp;clvalue(L-\u0026gt;ci-\u0026gt;func)-\u0026gt;l; base = L-\u0026gt;base; k = cl-\u0026gt;p-\u0026gt;k; /* main loop of interpreter */ for (;;) { const Instruction i = *pc++; StkId ra; if ((L-\u0026gt;hookmask \u0026amp; (LUA_MASKLINE | LUA_MASKCOUNT)) \u0026amp;\u0026amp; (--L-\u0026gt;hookcount == 0 || L-\u0026gt;hookmask \u0026amp; LUA_MASKLINE)) { traceexec(L, pc); if (L-\u0026gt;status == LUA_YIELD) { /* did hook yield? */ L-\u0026gt;savedpc = pc - 1; return; } base = L-\u0026gt;base; } /* warning!! several calls may realloc the stack and invalidate `ra\u0026#39; */ ra = RA(i); lua_assert(base == L-\u0026gt;base \u0026amp;\u0026amp; L-\u0026gt;base == L-\u0026gt;ci-\u0026gt;base); lua_assert(base \u0026lt;= L-\u0026gt;top \u0026amp;\u0026amp; L-\u0026gt;top \u0026lt;= L-\u0026gt;stack + L-\u0026gt;stacksize); lua_assert(L-\u0026gt;top == L-\u0026gt;ci-\u0026gt;top || luaG_checkopenop(i)); switch (GET_OPCODE(i)) { case OP_MOVE: { setobjs2s(L, ra, RB(i)); continue; } case OP_LOADK: { setobj2s(L, ra, KBx(i)); continue;   Code Snippet 12: lvm.c   line 389，内部是一个死循环 line 390，默认自增 pc，从中取出指令 line 406，根据指令的类型，执行对应的操作  大部分指令的操作都非常简单，对应 opcode 的语义注释就可以理解。\n下面只针对重要的部分，vm 是如何运行 closure 的。\nclosure #  在编译时，并没有涉及到 closure 结构，作为 8 种基础类型之一，closure 结构在运行时发挥作用。\n287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316  /* ** Closures */ #define ClosureHeader \\ CommonHeader; lu_byte isC; lu_byte nupvalues; GCObject *gclist; \\ struct Table *env  typedef struct CClosure { ClosureHeader; lua_CFunction f; TValue upvalue[1]; } CClosure; typedef struct LClosure { ClosureHeader; struct Proto *p; UpVal *upvals[1]; } LClosure; typedef union Closure { CClosure c; LClosure l; } Closure; #define iscfunction(o)\t(ttype(o) == LUA_TFUNCTION \u0026amp;\u0026amp; clvalue(o)-\u0026gt;c.isC) #define isLfunction(o)\t(ttype(o) == LUA_TFUNCTION \u0026amp;\u0026amp; !clvalue(o)-\u0026gt;c.isC)   Code Snippet 13: lobject.h  Closure 是 union 类型，容纳 C Closure 和 Lua Closure 两种类型，C Closure 之后再讲解， 这里只看 Lua Closure。\n lu_byte isC ，标识 Closure 是 C 还是 Lua lu_byte nupvalues ，拥有 upvalue 的数量 struct Table *env ，函数运行环境，等同于 gbl 表 struct Proto *p ，指向 parser 生成的 Proto Upval *upvals[1] ，为 upvalue 分配的空间  def #  回忆 parser 中 function 的定义过程，解析 function 定义的过程是递归， 生成相应的 Proto 并链接到上层 Proto.p 中。\n所以在 vm 中和 function 定义相关的功能，只有使用 closure 指令进行封装这一步。\n723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742  case OP_CLOSURE: { Proto *p; Closure *ncl; int nup, j; p = cl-\u0026gt;p-\u0026gt;p[GETARG_Bx(i)]; nup = p-\u0026gt;nups; ncl = luaF_newLclosure(L, nup, cl-\u0026gt;env); ncl-\u0026gt;l.p = p; for (j=0; j\u0026lt;nup; j++, pc++) { if (GET_OPCODE(*pc) == OP_GETUPVAL) ncl-\u0026gt;l.upvals[j] = cl-\u0026gt;upvals[GETARG_B(*pc)]; else { lua_assert(GET_OPCODE(*pc) == OP_MOVE); ncl-\u0026gt;l.upvals[j] = luaF_findupval(L, base + GETARG_B(*pc)); } } setclvalue(L, ra, ncl); Protect(luaC_checkGC(L)); continue; }   Code Snippet 14: lvm.c  line 729 为 closure 结构分配空间。\nline 731 - 738 是比较有意思的地方，还记得指令生成时，对 upvalue 的约定吗？\nVLOCAL 使用 move 指令，VUPVAL 使用 getupval 指令，这里根据 upvalue 的数量， 向下读取相应数量的指令，初始化 upvalue。\n详细到下面的 upval 小节解析。\nline 739 将封装生成的 closure 赋值给变量。\ncall #  介绍函数调用之前，先来了解一下 CallInfo 结构。\n整个线程的栈记录着计算的状态，函数调用具有天生的栈特性， 调用前入栈，调用后出栈。\nCallInfo 就是用来记录函数调用对应栈的位置的。\n45 46 47 48 49 50 51 52 53 54 55  /* ** informations about a call */ typedef struct CallInfo { StkId base; /* base for this function */ StkId func; /* function index in the stack */ StkId\ttop; /* top for this function */ const Instruction *savedpc; int nresults; /* expected number of results from this function */ int tailcalls; /* number of tail calls lost under this entry */ } CallInfo;   Code Snippet 15: lstate.h   func，指向调用的函数本身 base，指向调用函数对应的栈基地址 top，指向调用函数对应的栈顶地址  lua_State 中，存在着一个 CallInfo 数组，索引从 0 开始，记录着函数调用的层次。\nbase_ci 指向索引 0， end_ci 指向最后， ci 指向当前的函数调用层次。 每当遇到新的函数调用，ci 自增；调用结束，ci 自减。\n具体来看一个示例，\nlocal function f() end f(1, 2, 3) ; function [0] definition (level 1) ; 0 upvalues, 0 params, 2 is_vararg, 5 stacks .function 0 0 2 5 .local \u0026#34;f\u0026#34; ; 0 .const 1 ; 0 .const 2 ; 1 .const 3 ; 2 ; function [0] definition (level 2) ; 0 upvalues, 0 params, 0 is_vararg, 2 stacks .function 0 0 0 2 [1] return 0 1 ; end of function [1] closure 0 0 ; 0 upvalues [2] move 1 0 [3] loadk 2 0 ; 1 [4] loadk 3 1 ; 2 [5] loadk 4 2 ; 3 [6] call 1 4 1 [7] return 0 1 ; end of function 定义一个函数 f，并以参数 1 2 3 来调用它。\n在调用 call 指令之前，整体的栈状态如下，\n  被调用的函数，先入栈，其后再压入传入的参数，在调用时，新增 CallInfo 结构， ci-\u0026gt;func 指向被调用的函数，ci-\u0026gt;base 指向第一个参数，ci-\u0026gt;top 指向取决于被调用的函数分配的空间大小。\n上图指的是 vm 调用函数 chunk 对应的栈状态。\nL-\u0026gt;base L-\u0026gt;top 永远指向当前正在被调用的函数的栈区域，代码生成过程中“想象”中的栈，就是由 L-\u0026gt;base L-\u0026gt;top 指定的区域。\n调用 call 指令之后，栈状态如下，\n  新增 ci，用于管理 chunk 调用函数 f 对应的状态，原则和上面相同。\n相应代码具体描述了对应的过程，\n586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606  case OP_CALL: { int b = GETARG_B(i); int nresults = GETARG_C(i) - 1; if (b != 0) L-\u0026gt;top = ra+b; /* else previous instruction set top */ L-\u0026gt;savedpc = pc; switch (luaD_precall(L, ra, nresults)) { case PCRLUA: { nexeccalls++; goto reentry; /* restart luaV_execute over new Lua function */ } case PCRC: { /* it was a C function (`precall\u0026#39; called it); adjust results */ if (nresults \u0026gt;= 0) L-\u0026gt;top = L-\u0026gt;ci-\u0026gt;top; base = L-\u0026gt;base; continue; } default: { return; /* yield */ } } }   Code Snippet 16: lvm.c  265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306  int luaD_precall (lua_State *L, StkId func, int nresults) { LClosure *cl; ptrdiff_t funcr; if (!ttisfunction(func)) /* `func\u0026#39; is not a function? */ func = tryfuncTM(L, func); /* check the `function\u0026#39; tag method */ funcr = savestack(L, func); cl = \u0026amp;clvalue(func)-\u0026gt;l; L-\u0026gt;ci-\u0026gt;savedpc = L-\u0026gt;savedpc; if (!cl-\u0026gt;isC) { /* Lua function? prepare its call */ CallInfo *ci; StkId st, base; Proto *p = cl-\u0026gt;p; luaD_checkstack(L, p-\u0026gt;maxstacksize); func = restorestack(L, funcr); if (!p-\u0026gt;is_vararg) { /* no varargs? */ base = func + 1; if (L-\u0026gt;top \u0026gt; base + p-\u0026gt;numparams) L-\u0026gt;top = base + p-\u0026gt;numparams; } else { /* vararg function */ int nargs = cast_int(L-\u0026gt;top - func) - 1; base = adjust_varargs(L, p, nargs); func = restorestack(L, funcr); /* previous call may change the stack */ } ci = inc_ci(L); /* now `enter\u0026#39; new function */ ci-\u0026gt;func = func; L-\u0026gt;base = ci-\u0026gt;base = base; ci-\u0026gt;top = L-\u0026gt;base + p-\u0026gt;maxstacksize; lua_assert(ci-\u0026gt;top \u0026lt;= L-\u0026gt;stack_last); L-\u0026gt;savedpc = p-\u0026gt;code; /* starting point */ ci-\u0026gt;tailcalls = 0; ci-\u0026gt;nresults = nresults; for (st = L-\u0026gt;top; st \u0026lt; ci-\u0026gt;top; st++) setnilvalue(st); L-\u0026gt;top = ci-\u0026gt;top; if (L-\u0026gt;hookmask \u0026amp; LUA_MASKCALL) { L-\u0026gt;savedpc++; /* hooks assume \u0026#39;pc\u0026#39; is already incremented */ luaD_callhook(L, LUA_HOOKCALL, -1); L-\u0026gt;savedpc--; /* correct \u0026#39;pc\u0026#39; */ } return PCRLUA; }   Code Snippet 17: ldo.c  return #  return 的过程和 call 相反，收集相应的返回值，并将值从 ci-\u0026gt;func 开始覆盖， 销毁当前 ci，返回到上层 ci。\n上层 ci 从调用函数的位置收集相应的返回值。\n  还是上面的示例，调用 f 返回之后，没有返回值。\nci 回退到上层，不收集返回值。\n相应实现的代码如下，\n639 640 641 642 643 644 645 646 647 648 649 650 651 652 653  case OP_RETURN: { int b = GETARG_B(i); if (b != 0) L-\u0026gt;top = ra+b-1; if (L-\u0026gt;openupval) luaF_close(L, base); L-\u0026gt;savedpc = pc; b = luaD_poscall(L, ra); if (--nexeccalls == 0) /* was previous function running `here\u0026#39;? */ return; /* no: return */ else { /* yes: continue its execution */ if (b) L-\u0026gt;top = L-\u0026gt;ci-\u0026gt;top; lua_assert(isLua(L-\u0026gt;ci)); lua_assert(GET_OPCODE(*((L-\u0026gt;ci)-\u0026gt;savedpc - 1)) == OP_CALL); goto reentry; } }   Code Snippet 18: lvm.c  343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361  int luaD_poscall (lua_State *L, StkId firstResult) { StkId res; int wanted, i; CallInfo *ci; if (L-\u0026gt;hookmask \u0026amp; LUA_MASKRET) firstResult = callrethooks(L, firstResult); ci = L-\u0026gt;ci--; res = ci-\u0026gt;func; /* res == final position of 1st result */ wanted = ci-\u0026gt;nresults; L-\u0026gt;base = (ci - 1)-\u0026gt;base; /* restore base */ L-\u0026gt;savedpc = (ci - 1)-\u0026gt;savedpc; /* restore savedpc */ /* move results to correct place */ for (i = wanted; i != 0 \u0026amp;\u0026amp; firstResult \u0026lt; L-\u0026gt;top; i--) setobjs2s(L, res++, firstResult++); while (i-- \u0026gt; 0) setnilvalue(res++); L-\u0026gt;top = res; return (wanted - LUA_MULTRET); /* 0 iff wanted == LUA_MULTRET */ }   Code Snippet 19: ldo.c  upval #  之前已经零碎的提到 upvalue 的几个方面， 本节来详细讨论 vm 中是如何实现 upvalue 的。\n先来看一段示例，\nlocal a local function f() local b local function g() b = 20 a = 10 end g() return g end local h = f() h() a 和 b 都是函数 g 的 upval。\n当函数 g 在 f 内部第一次调用时，修改了 a 和 b 值，此时 a 和 b 在栈上都是存活的， 因为 a 是 chunk 的局部变量，b 是 f 的局部变量。\n当调用 f，将 g 赋值与 h 时，此时调用 h，a 依然是存活的，但是由于离开了 f，b 在栈上已经被回收。\n此时 g 如何访问到 upvalue b 呢？\nlua 用一种灵巧的方法来解决这个问题。\n270 271 272 273 274 275 276 277 278 279 280 281 282 283 284  /* ** Upvalues */ typedef struct UpVal { CommonHeader; TValue *v; /* points to stack or to its own value */ union { TValue value; /* the value (when closed) */ struct { /* double linked list (when open) */ struct UpVal *prev; struct UpVal *next; } l; } u; } UpVal;   Code Snippet 20: lobject.h  从注释中可以看到，upval 有两种状态，open 和 closed。\n其中 v 指向 upval 所引用的值，当状态为 closed 时，指向自身的 u.value； 当状态为 open 时，指向栈中元素。\n比如上面的示例代码，当在函数 f 中调用 g 时，a 和 b 在栈上都是存活的， 相应的 upval 处于 open 状态，分别指向栈中对应的地址。\n  当离开函数 f 调用 h 时，已经离开了函数 f 的作用域，b 不再于栈上存活， 于是进行 close 操作，将 b 的值拷贝到 u.value，并修改 v 的指向。\n这里的操作对于 l-\u0026gt;upvals 是完全透明的，因为其只通过 v 来访问 upval 的值。\n  723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742  case OP_CLOSURE: { Proto *p; Closure *ncl; int nup, j; p = cl-\u0026gt;p-\u0026gt;p[GETARG_Bx(i)]; nup = p-\u0026gt;nups; ncl = luaF_newLclosure(L, nup, cl-\u0026gt;env); ncl-\u0026gt;l.p = p; for (j=0; j\u0026lt;nup; j++, pc++) { if (GET_OPCODE(*pc) == OP_GETUPVAL) ncl-\u0026gt;l.upvals[j] = cl-\u0026gt;upvals[GETARG_B(*pc)]; else { lua_assert(GET_OPCODE(*pc) == OP_MOVE); ncl-\u0026gt;l.upvals[j] = luaF_findupval(L, base + GETARG_B(*pc)); } } setclvalue(L, ra, ncl); Protect(luaC_checkGC(L)); continue; }   Code Snippet 21: lvm.c  53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  UpVal *luaF_findupval (lua_State *L, StkId level) { global_State *g = G(L); GCObject **pp = \u0026amp;L-\u0026gt;openupval; UpVal *p; UpVal *uv; while (*pp != NULL \u0026amp;\u0026amp; (p = ngcotouv(*pp))-\u0026gt;v \u0026gt;= level) { lua_assert(p-\u0026gt;v != \u0026amp;p-\u0026gt;u.value); if (p-\u0026gt;v == level) { /* found a corresponding upvalue? */ if (isdead(g, obj2gco(p))) /* is it dead? */ changewhite(obj2gco(p)); /* ressurect it */ return p; } pp = \u0026amp;p-\u0026gt;next; } uv = luaM_new(L, UpVal); /* not found: create a new one */ uv-\u0026gt;tt = LUA_TUPVAL; uv-\u0026gt;marked = luaC_white(g); uv-\u0026gt;v = level; /* current value lives in the stack */ uv-\u0026gt;next = *pp; /* chain it in the proper position */ *pp = obj2gco(uv); uv-\u0026gt;u.l.prev = \u0026amp;g-\u0026gt;uvhead; /* double link it in `uvhead\u0026#39; list */ uv-\u0026gt;u.l.next = g-\u0026gt;uvhead.u.l.next; uv-\u0026gt;u.l.next-\u0026gt;u.l.prev = uv; g-\u0026gt;uvhead.u.l.next = uv; lua_assert(uv-\u0026gt;u.l.next-\u0026gt;u.l.prev == uv \u0026amp;\u0026amp; uv-\u0026gt;u.l.prev-\u0026gt;u.l.next == uv); return uv; }   Code Snippet 22: lfunc.c  其中 closure 之后的 move 指令，意味着 upval 处于 open 状态，upvale 需要去链接到栈。 而 getupval 指令，就直接引用上层 closure 相应的 upval 指向的地址就好。\nL-\u0026gt;openupval 是一个单向链表，其中链接着所有 open 状态的 upval，按栈的高地址到低地址的顺序排列。\n注意 line 71 72，pp 是 \u0026amp;p-\u0026gt;next，当 *pp = obj2gco(uv) 的时候，修改了 next 指针的值， 得以将新的 upval 插入到链表中。\n至于 close 操作也不难理解， luaF_close 将所有高于 level 栈地址的 open upval 全部变成 close 状态， 即修改 v 指针指向自身，并从 L-\u0026gt;openupval 中脱离。\n96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112  void luaF_close (lua_State *L, StkId level) { UpVal *uv; global_State *g = G(L); while (L-\u0026gt;openupval != NULL \u0026amp;\u0026amp; (uv = ngcotouv(L-\u0026gt;openupval))-\u0026gt;v \u0026gt;= level) { GCObject *o = obj2gco(uv); lua_assert(!isblack(o) \u0026amp;\u0026amp; uv-\u0026gt;v != \u0026amp;uv-\u0026gt;u.value); L-\u0026gt;openupval = uv-\u0026gt;next; /* remove from `open\u0026#39; list */ if (isdead(g, o)) luaF_freeupval(L, uv); /* free upvalue */ else { unlinkupval(uv); setobj(L, \u0026amp;uv-\u0026gt;u.value, uv-\u0026gt;v); uv-\u0026gt;v = \u0026amp;uv-\u0026gt;u.value; /* now current value lives here */ luaC_linkupval(L, uv); /* link upvalue into `gcroot\u0026#39; list */ } } }   Code Snippet 23: lfunc.c  practice #  上面只提到了和 closure 相关的字节码逻辑，读者可以自行输入其它 lua 代码示例， 探索其它字节码的实现。\n   文件 建议     lvm.h 仔细阅读   lvm.h 仔细阅读   lfunc.h 仔细阅读   lfunc.c 仔细阅读    "});index.add({'id':8,'href':'/lua-5.1-source-guide/docs/generator/','title':"generator",'section':"Docs",'content':"上一章尝试单独解析语法分析过程，本章关注具体的代码生成过程。\n  function vs proto vs closure #  在具体深入代码生成之前，先来区分三个概念，function proto 和 closure。\nfunction，是 lua 语言中定义的概念，是 8 种基础类型之一，表示函数， 具体在 lua 代码中用关键字 function 来定义。\n如同 string 概念在底层由 TString 结构来实现一样， function 在底层用 Proto 结构来实现，是 function 整体编译之后得到的同语义结构。\n编译得到的 Proto 是静态的，在实际运行的时候，需要封装为 Closure 结构，交由 vm 来执行。 Closure 为 upvalue 分配了空间，并统一表示了 c function 和 lua function。\n这也是为什么在 object 章节，提到基础类型对应的实现结构时，用 Closure 而不是用 Proto 来表示 function。\n所以在编译时期，我们关注 Proto，而在运行时期，才关注 Closure。\nchunk #  lua 内部使用了一种巧妙的实现，在编译时，将整个文件当做一个匿名 function 来对待。 相当于文件头加了 function () ，文件尾加了 end 。\n383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398  Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff, const char *name) { struct LexState lexstate; struct FuncState funcstate; lexstate.buff = buff; luaX_setinput(L, \u0026amp;lexstate, z, luaS_new(L, name)); open_func(\u0026amp;lexstate, \u0026amp;funcstate); funcstate.f-\u0026gt;is_vararg = VARARG_ISVARARG; /* main func. is always vararg */ luaX_next(\u0026amp;lexstate); /* read first token */ chunk(\u0026amp;lexstate); check(\u0026amp;lexstate, TK_EOS); close_func(\u0026amp;lexstate); lua_assert(funcstate.prev == NULL); lua_assert(funcstate.f-\u0026gt;nups == 0); lua_assert(lexstate.fs == NULL); return funcstate.f; }   Code Snippet 1: lparser.c  可以看到， luaY_parser 读取文件，最终生成并返回 Proto * 。\n因为整体分析的入口是 chunk，lua 又将文件当做匿名函数来对待， 这也是很多 lua 书籍中提到 chunk 的原因，表示文件编译得到的结果。\nembeded #  如果按照 function 和 Proto 一一对应的关系，会出现函数层级的问题。\n比如下面的示例代码，\nfunction a() function b() end end function c() function d() end function e() end end 如果将 lua 代码文件看作 Proto chunk，代码中定义的 a b c d 同样是 function 且编译为 Proto。 但是 function a b c d e 是 lua 代码的一部分，所以其 Proto 也应该被包含在 Proto chunk 中。\nlua 内部根据 function 定义的位置，来记录这种包含关系。\n  function a c 直接定义在代码文件（顶层匿名函数）中， b d e 则直接定义在 a 和 c 中。\n  Proto 结构中使用 struct Proto * 数组 p（Line 235）来记录其直接包含的 Proto。\n228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253  /* ** Function Prototypes */ typedef struct Proto { CommonHeader; TValue *k; /* constants used by the function */ Instruction *code; struct Proto **p; /* functions defined inside the function */ int *lineinfo; /* map from opcodes to source lines */ struct LocVar *locvars; /* information about local variables */ TString **upvalues; /* upvalue names */ TString *source; int sizeupvalues; int sizek; /* size of `k\u0026#39; */ int sizecode; int sizelineinfo; int sizep; /* size of `p\u0026#39; */ int sizelocvars; int linedefined; int lastlinedefined; GCObject *gclist; lu_byte nups; /* number of upvalues */ lu_byte numparams; lu_byte is_vararg; lu_byte maxstacksize; } Proto;   Code Snippet 2: lobject.h  FuncState #  在 lua 的语法分析中，function 解析是一个重要的部分。\nEBNF 和 regex 的区别在于，EBNF 可以描述一种递归过程，而 regex 则不能。\nchunk 作为解析 function 的入口，得到 Proto，这个过程在遇到 function 定义时，不断的递归调用，生成 Proto， 并按照层级链接起来。\n在了解这个过程之前，要先介绍另一个重要的结构 FuncState 。\n57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  /* state needed to generate code for a given function */ typedef struct FuncState { Proto *f; /* current function header */ Table *h; /* table to find (and reuse) elements in `k\u0026#39; */ struct FuncState *prev; /* enclosing function */ struct LexState *ls; /* lexical state */ struct lua_State *L; /* copy of the Lua state */ struct BlockCnt *bl; /* chain of current blocks */ int pc; /* next position to code (equivalent to `ncode\u0026#39;) */ int lasttarget; /* `pc\u0026#39; of last `jump target\u0026#39; */ int jpc; /* list of pending jumps to `pc\u0026#39; */ int freereg; /* first free register */ int nk; /* number of elements in `k\u0026#39; */ int np; /* number of elements in `p\u0026#39; */ short nlocvars; /* number of elements in `locvars\u0026#39; */ lu_byte nactvar; /* number of active local variables */ upvaldesc upvalues[LUAI_MAXUPVALUES]; /* upvalues */ unsigned short actvar[LUAI_MAXVARS]; /* declared-variable stack */ } FuncState;   Code Snippet 3: lparser.h  从名称可以看出，和 LexState 相似，也用于记录中间状态。 FuncState 用于记录 function 分析过程中的状态，和 function 定义一一对应， 每遇到一个 function 定义时，lua 都会新建一个 FuncState，记录当下解析 function 的中间状态。\nbig picture #  LexState FuncState Proto 这三者在分析过程中协同生成最终的 Proto。\n比如解析如下示例代码，\n1 2 3 4  function a() function b() end end   在整体文件分析开始之前，parser 已经准备好 FuncState，通过 LexState.ls 索引， FuncState.f 指向相应要生成的 Proto。\n  解析第 1 行之后，需要函数定义 a，parser 生成新的 FuncState，并更新 ls.fs 的指向。 同时，fs a 通过 prev 指向 fs chunk，表示层级关系。\n  第 2 行，遇到函数 b 定义，同样的，生成 FuncState 并更新 ls.fs 的指向。\n  第 3 行，函数 b 定义结束，此时 ls.fs 指向 fs b 的 prev，回到上个函数定义层级。 并将函数 b 生成的 Proto 链接到上层函数 a 的 Proto。\n此时，fs b 已经结束其作用。\n    第 4 行，函数 a 定义结束，同上，更新 ls.fs 指向，并链接 Proto a 到 Proto chunk。\n  最终返回 Proto chunk，ls 和 fs 都已经结束其使命，毕竟它们的作用只用于记录中间状态\n在 parser 内部，上面描述的过程发生在 open_func() close_func() 中，读者可仔细体会其细节。\n328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380  static void open_func (LexState *ls, FuncState *fs) { lua_State *L = ls-\u0026gt;L; Proto *f = luaF_newproto(L); fs-\u0026gt;f = f; fs-\u0026gt;prev = ls-\u0026gt;fs; /* linked list of funcstates */ fs-\u0026gt;ls = ls; fs-\u0026gt;L = L; ls-\u0026gt;fs = fs; fs-\u0026gt;pc = 0; fs-\u0026gt;lasttarget = -1; fs-\u0026gt;jpc = NO_JUMP; fs-\u0026gt;freereg = 0; fs-\u0026gt;nk = 0; fs-\u0026gt;np = 0; fs-\u0026gt;nlocvars = 0; fs-\u0026gt;nactvar = 0; fs-\u0026gt;bl = NULL; f-\u0026gt;source = ls-\u0026gt;source; f-\u0026gt;maxstacksize = 2; /* registers 0/1 are always valid */ fs-\u0026gt;h = luaH_new(L, 0, 0); /* anchor table of constants and prototype (to avoid being collected) */ sethvalue2s(L, L-\u0026gt;top, fs-\u0026gt;h); incr_top(L); setptvalue2s(L, L-\u0026gt;top, f); incr_top(L); } static void close_func (LexState *ls) { lua_State *L = ls-\u0026gt;L; FuncState *fs = ls-\u0026gt;fs; Proto *f = fs-\u0026gt;f; removevars(ls, 0); luaK_ret(fs, 0, 0); /* final return */ luaM_reallocvector(L, f-\u0026gt;code, f-\u0026gt;sizecode, fs-\u0026gt;pc, Instruction); f-\u0026gt;sizecode = fs-\u0026gt;pc; luaM_reallocvector(L, f-\u0026gt;lineinfo, f-\u0026gt;sizelineinfo, fs-\u0026gt;pc, int); f-\u0026gt;sizelineinfo = fs-\u0026gt;pc; luaM_reallocvector(L, f-\u0026gt;k, f-\u0026gt;sizek, fs-\u0026gt;nk, TValue); f-\u0026gt;sizek = fs-\u0026gt;nk; luaM_reallocvector(L, f-\u0026gt;p, f-\u0026gt;sizep, fs-\u0026gt;np, Proto *); f-\u0026gt;sizep = fs-\u0026gt;np; luaM_reallocvector(L, f-\u0026gt;locvars, f-\u0026gt;sizelocvars, fs-\u0026gt;nlocvars, LocVar); f-\u0026gt;sizelocvars = fs-\u0026gt;nlocvars; luaM_reallocvector(L, f-\u0026gt;upvalues, f-\u0026gt;sizeupvalues, f-\u0026gt;nups, TString *); f-\u0026gt;sizeupvalues = f-\u0026gt;nups; lua_assert(luaG_checkcode(f)); lua_assert(fs-\u0026gt;bl == NULL); ls-\u0026gt;fs = fs-\u0026gt;prev; /* last token read was anchored in defunct function; must reanchor it */ if (fs) anchor_token(ls); L-\u0026gt;top -= 2; /* remove table and prototype from the stack */ }   Code Snippet 4: lparser.c  FuncState vs Proto #  FuncState 和 Proto 作为分析过程中两个最重要的结构，值得详细做一番了解。\n仔细观察两个结构内部的字段，会发现两者之间有紧密的联系，界限很模糊， 都些许记录了分析过程的结果。 关键的差异在于，Proto 只保留最终结果，而 FuncState 记录中间状态。\n对应这个原则，来详细探究下两个结构的内部。\n先来看 Proto。\n228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253  /* ** Function Prototypes */ typedef struct Proto { CommonHeader; TValue *k; /* constants used by the function */ Instruction *code; struct Proto **p; /* functions defined inside the function */ int *lineinfo; /* map from opcodes to source lines */ struct LocVar *locvars; /* information about local variables */ TString **upvalues; /* upvalue names */ TString *source; int sizeupvalues; int sizek; /* size of `k\u0026#39; */ int sizecode; int sizelineinfo; int sizep; /* size of `p\u0026#39; */ int sizelocvars; int linedefined; int lastlinedefined; GCObject *gclist; lu_byte nups; /* number of upvalues */ lu_byte numparams; lu_byte is_vararg; lu_byte maxstacksize; } Proto;   Code Snippet 5: lobject.h  其中字段分为 3 部分来看\n暂不讨论\n int *lineinfo TString *source int linedefined int lastlinedefined GCObject *gclist  元信息\n lu_byte numparams ，函数的固定参数个数 lu_byte is_vararg ，函数的可变参数 lu_byte maxstacksize ，函数运行时，最大使用的栈空间  数组结果\n TValue *k ，常量表 Instruction *code ，字节码 struct Proto **p ，内部其它函数定义 struct LocVar *locvars ，局部变量信息 TString **upvalues ，upvalue 信息 与 len size 相关的字段  对照之前对 vm 执行模型的讨论，code 和 k 就与之对应。\n这里一个有意思的区别，在于 size 和 n。\n上面提到的 5 个数组，都对应一个 size 字段，用于记录数组的大小。 同时，也对应一个 n 字段，用于记录当前数组已使用的大小（下一个空闲的位置）。\n在分析的过程中，数组 size 值记录空间总长度，当空间不足时，会继续扩大分配。 而数组 n 值用于时刻标识下一个空闲索引，记录分析结果并自增，它的值比 size 小。\n当最终分析结束时，将 n 值赋值给相应的 size 值，省略多余不用的空间，此时两者才会相同。\n如此看来，n 值应该存放在 FuncState 中，但是存在例外的是 lu_byte nups 。\n          相同的视角，来观察 FuncState。\n57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  /* state needed to generate code for a given function */ typedef struct FuncState { Proto *f; /* current function header */ Table *h; /* table to find (and reuse) elements in `k\u0026#39; */ struct FuncState *prev; /* enclosing function */ struct LexState *ls; /* lexical state */ struct lua_State *L; /* copy of the Lua state */ struct BlockCnt *bl; /* chain of current blocks */ int pc; /* next position to code (equivalent to `ncode\u0026#39;) */ int lasttarget; /* `pc\u0026#39; of last `jump target\u0026#39; */ int jpc; /* list of pending jumps to `pc\u0026#39; */ int freereg; /* first free register */ int nk; /* number of elements in `k\u0026#39; */ int np; /* number of elements in `p\u0026#39; */ short nlocvars; /* number of elements in `locvars\u0026#39; */ lu_byte nactvar; /* number of active local variables */ upvaldesc upvalues[LUAI_MAXUPVALUES]; /* upvalues */ unsigned short actvar[LUAI_MAXVARS]; /* declared-variable stack */ } FuncState;   Code Snippet 6: lparser.h  暂不讨论\n Proto *f struct FuncState *prev struct LexState *ls struct lua_State *L  后续讨论\n struct BlockCnt *bl int lasttarget int jpc int freereg  中间结果\n upvaldesc upvalues[LUAI_MAXUPVALUES] unsigned short actvar[LUAI_MAXVARS] 其它 n 字段  两个数组是定长的，即 size 是固定的， f-\u0026gt;nups fs-\u0026gt;nactvar 用于对应其 n 字段。\n    在编译过程中，所得到的结果会不断的存储入上述数组及其它字段中。\ngenerate #  从某种角度看，编译过程就是规则间的同义转换过程。\n代码生成，最终将符合语法规则的 lua 代码，生成为 vm 可执行的同义字节码， 这个过程是隐藏在语法分析下的艺术。\n两个规则间可以进行同义转换的连接点，在于对 vm 的共识， 正因为编译器\u0026quot;懂得\u0026quot; vm，知晓字节码的格式与功能，知晓运行时的栈结构， 知晓 k 表 Gbl 表的读取方式，才能生成 vm 可执行的同义字节码。\n这种共识贯穿在整个代码生成的过程中。\n但是无论编译器如何了解 vm，编译时和运行时还是存在区别的。 代码生成时，只是想象存在一个假想的 vm，它在执行生成的所有结果。\n所以代码生成这个过程是最为繁杂的，到 vm 真正运行时反而轻松了，只需要读指令，执行指令就可以了。\n阅读代码生成相关的代码，笔者还没有精确地把握住其中的原理，只能提供几个原则给读者参考，\n 总体是语法制导翻译的过程 使用后缀方式的生成顺序，比如 a + b 按照 a b + 的顺序来转换生成 精确模拟 vm 的运行方式，包括栈运算，Gbl 表及其它  章节结束之后，读者可以多使用调试器分析示例代码，探索其中的奥妙。\nkey concept #  在仔细探索代码生成之前，先明确几个在生成过程中的重点。\nvariable #  从作用域来看，lua 中的变量有 3 类，分别为 local upvalue global ， 三者在底层的实现方式各不相同。\nlocal #  local 变量的活动范围（active），开始于在作用域中出现的那一刻，一直到作用域结束， 而作用域是有明显的栈特性的，新开辟作用域时入栈，离开作用域时出栈。\n在一个作用域内，local 变量按照声明顺序入栈，离开作用域时全部出栈，变为 inactive 状态。\n利用这个特性，lua 在编译时，在 fs 中用 actvar 和 nactvar 时刻记录着当前 active local 变量的状态。\n比如如下示例代码，\nlocal a do local b do local c end end do local d do local e end end 在代码分析的不同时刻， fs-\u0026gt;actvar 记录的栈状态是这样的，\n  上面只是粗略描述了 active local 变量的栈状态，而实际在 parser 内部，是通过两个数组来存储的。\n  数组 fs-\u0026gt;actvar 的元素是 unsigned short 类型，只用来记录变量的索引。 索引数组 f-\u0026gt;locvars 中的元素，其中元素类型为 struct LocVar * 。\n262 263 264 265 266  typedef struct LocVar { TString *varname; int startpc; /* first point where variable is active */ int endpc; /* first point where variable is dead */ } LocVar;   Code Snippet 7: lobject.h  LocVar 主要记录变量的名字， startpc endpc 在字节码层面记录其活动范围。\n宏 getlocvar 精确描述了图示过程。\n32  #define getlocvar(fs, i)\t((fs)-\u0026gt;f-\u0026gt;locvars[(fs)-\u0026gt;actvar[i]])   Code Snippet 8: lparser.c  upvalue #  upvalue 在本文翻译为上值，它即非 local，又不是 global。 直观从代码上看，即引用作用域之外的变量。\nlua 将 function 作为基础类型之一，可以作为普通变量，参数，返回值，赋值，而四处流转。 又因为 local 变量的作用域限定于词法，这便是 upvalue 机制发挥作用的地方。\n如下示例代码，\nlocal function outer() local a = 0 local function inner() a = a + 1 print(a) end inner() return inner end local f = outer() f() f() 1 2 3 内部第 1 次调用 inner() 时，输出 1 。 当调用 outer()，将 inner 赋值与 f，调用两次 f() 得到 2 3 。\n第 1 次调用 inner() 时，依然在 a 的作用域内，输出 1 是符合直觉的。\n问题在于调用 f() 时，因为 a 只作用在 outer 的作用域，而 f 在 outer 作用域外部， 已经离开了 a 的作用域，这种情况下为何还可以访问 a ？\n这便是闭包机制的由来，a 对于 inner 而言是 upvalue 类型。 这也是 lua 中为何 function 不是 function 而是 closure 的原因，function 及 upvalue 组成了 closure， 所有 func 在运行时都封装为 closure 来运行，其中重要的原因就在于单独分配 upvalue 空间并管理。\n详细的说，第 1 次调用 inner() 时，local a 依然存活，称 upvalue a 为 open 状态。 当离开 outer() 作用域，upvalue a 为 close 状态。\nglobal #  如果依然说，global 变量是除 local 变量和 upvalue 变量的变量，读者肯定不信服。\n之所以存在 upvalue 和 global，隐含的一点是，在 lua 中外层变量对于内层是可见的， 既然是可见的，对于外层变量引用自然有一个查找的过程，变量类型正是在查找的过程中确定的。\n 在当前作用域中可以找到的，为 local 类型 在当前作用域之外的作用域可以找到的，为 upvalue 类型 所有作用域都无法找到的，为 global 类型  按照这个逻辑，顶层的 chunk 是没有 upvalue 的，在当前作用域中查找不到的变量， 只能是 global 类型。\nsetfenv 影响的就是函数的 global 环境， 设定不同的 global 表，可以影响内部对 global 的引用， 实现不同的运行效果，类似于封装成一个小沙盒，\n比如如下代码，变量 a 对 outer inner 都是全局变量，所以全部修改都影响到 global a 的值。\nlocal function outer() a = 10 local function inner() a = a + 1 return a end return inner end local f = outer() print(f(), a) print(f(), a) print(f(), a) 11\t11 12\t12 13\t13 register #  寄存器的主要作用是，存取 local 变量和存取中间结果。\n寄存器在编译时是一个抽象的概念，没有具体的分配空间，编译器只知晓存在这块区域， 并且按照自己的需要来使用和调试。\n而在实际运行时，寄存器存储在 vm 的栈中。\nstatement #  本节开始从实例具体分析代码生成的过程，和实例一起来探求其中的生成模式。\n因为语法元素的递归性，其中的组合是无限的，所以本节只挑选讲解部分重要的“原子性”的部分， 至于各种组合的变数读者可自由探索。\ntool #  在开始以实例为基础的探索之前，先详细介绍相应工具的使用。\n以交互式启动 chunkspy，用于临时检验一些想法。\n$ make spy 分析特定 lua 文件，输出相应的编译结果。\n$ make -s inspect source=lua_file_path 比如分析如下代码，\nlocal a = 1 会输出如下结果，\n1 2 3 4 5 6 7 8  ; function [0] definition (level 1) ; 0 upvalues, 0 params, 2 is_vararg, 2 stacks .function 0 0 2 2 .local \u0026#34;a\u0026#34; ; 0 .const 1 ; 0 [1] loadk 0 0 ; 1 [2] return 0 1 ; end of function   逐行来看，\nline 1\nlevel 1 指的是第一层级，即 chunk； function [0] 表明是当前层级的第 1 个函数（以 0 开始索引）\nline 2\n函数有 0 个 upvalue，0 个参数，按 0b010 模式接收可变参数，需要分配栈容量 2。\nline 3\n意义和 line 2 相同，line 2 是 line 3 的注释\nline 4 5\n.local 列出所有局部变量的名称及索引，即 f-\u0026gt;locvars 的内容 .const 列出 k 表的内容及索引\nline 6 7\n详细打印 f-\u0026gt;code 指令，最终一行总是默认生成一条 return 指令\nline 8\n注释，表明 function 结束\n读者结合 opcode 章节对各个指令功能的理解，不难理解 lua 代码和字节码的同义关系。\nlocal #  先来观察 local 语句。\n语法描述如下，\nstat ::= localstat localstat ::= LOCAL NAME {`,\u0026#39; NAME} [`=\u0026#39; explist] localstat ::= LOCAL FUNCTION NAME body localstat 可用于定义局部变量和局部函数。\n函数部分到后面小节再讨论，对于局部变量，根据是否赋值可分为两种情况。\nno assignment #  如下简单的代码示例，定义局部变量，无赋值，\nlocal a, b, c 分析得到如下结果，\n; function [0] definition (level 1) ; 0 upvalues, 0 params, 2 is_vararg, 3 stacks .function 0 0 2 3 .local \u0026#34;a\u0026#34; ; 0 .local \u0026#34;b\u0026#34; ; 1 .local \u0026#34;c\u0026#34; ; 2 [1] return 0 1 ; end of function 示例代码只是单纯进行了局部变量的声明，最终没有生成任何字节码。\n分析的过程，就是递归向下的函数过程， chunk -\u0026gt; stat -\u0026gt; localstat 。\n1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195  static void localstat (LexState *ls) { /* stat -\u0026gt; LOCAL NAME {`,\u0026#39; NAME} [`=\u0026#39; explist1] */ int nvars = 0; int nexps; expdesc e; do { new_localvar(ls, str_checkname(ls), nvars++); } while (testnext(ls, \u0026#39;,\u0026#39;)); if (testnext(ls, \u0026#39;=\u0026#39;)) nexps = explist1(ls, \u0026amp;e); else { e.k = VVOID; nexps = 0; } adjust_assign(ls, nvars, nexps, \u0026amp;e); adjustlocalvars(ls, nvars); }   Code Snippet 9: lparser.c  关键在于 new_localvar 函数，在循环中读入 a b c，并进行变量分析。\n160 161 162 163 164  static void new_localvar (LexState *ls, TString *name, int n) { FuncState *fs = ls-\u0026gt;fs; luaY_checklimit(fs, fs-\u0026gt;nactvar+n+1, LUAI_MAXVARS, \u0026#34;local variables\u0026#34;); fs-\u0026gt;actvar[fs-\u0026gt;nactvar+n] = cast(unsigned short, registerlocalvar(ls, name)); }   Code Snippet 10: lparser.c  143 144 145 146 147 148 149 150 151 152 153  static int registerlocalvar (LexState *ls, TString *varname) { FuncState *fs = ls-\u0026gt;fs; Proto *f = fs-\u0026gt;f; int oldsize = f-\u0026gt;sizelocvars; luaM_growvector(ls-\u0026gt;L, f-\u0026gt;locvars, fs-\u0026gt;nlocvars, f-\u0026gt;sizelocvars, LocVar, SHRT_MAX, \u0026#34;too many local variables\u0026#34;); while (oldsize \u0026lt; f-\u0026gt;sizelocvars) f-\u0026gt;locvars[oldsize++].varname = NULL; f-\u0026gt;locvars[fs-\u0026gt;nlocvars].varname = varname; luaC_objbarrier(ls-\u0026gt;L, f, varname); return fs-\u0026gt;nlocvars++; }   Code Snippet 11: lparser.c  其中根据变量出现的顺序，依次使用 registerlocalvar 得到变量索引，再记录到 fs-\u0026gt;actvar 中。\n这就是前面讨论过的，局部变量的存储方式，使用 fs-\u0026gt;actvar 记录索引， f-\u0026gt;locvars 记录变量名称。\n  new_locvar 完成的就是这个过程。\n这也对应了 chunkspy 分析结果中的 .local 部分。\nwith assignment #  再来看 local 变量赋值的情况。\n分析示例代码，得到如下结果，\nlocal a, b, c, d, e = 10, \u0026#34;second\u0026#34;, nil, true, false ; function [0] definition (level 1) ; 0 upvalues, 0 params, 2 is_vararg, 5 stacks .function 0 0 2 5 .local \u0026#34;a\u0026#34; ; 0 .local \u0026#34;b\u0026#34; ; 1 .local \u0026#34;c\u0026#34; ; 2 .local \u0026#34;d\u0026#34; ; 3 .local \u0026#34;e\u0026#34; ; 4 .const 10 ; 0 .const \u0026#34;second\u0026#34; ; 1 [1] loadk 0 0 ; 10 [2] loadk 1 1 ; \u0026#34;second\u0026#34; [3] loadnil 2 2 [4] loadbool 3 1 0 ; true [5] loadbool 4 0 0 ; false [6] return 0 1 ; end of function 除了 .local 条目变多了，也增加了 .const 部分，意味着 k 表多出了 2 项记录。\n依旧从 localstat 来分析，\n1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195  static void localstat (LexState *ls) { /* stat -\u0026gt; LOCAL NAME {`,\u0026#39; NAME} [`=\u0026#39; explist1] */ int nvars = 0; int nexps; expdesc e; do { new_localvar(ls, str_checkname(ls), nvars++); } while (testnext(ls, \u0026#39;,\u0026#39;)); if (testnext(ls, \u0026#39;=\u0026#39;)) nexps = explist1(ls, \u0026amp;e); else { e.k = VVOID; nexps = 0; } adjust_assign(ls, nvars, nexps, \u0026amp;e); adjustlocalvars(ls, nvars); }   Code Snippet 12: lparser.c  在记录变量信息之后，遇到 = ，开始分析 = 后的 表达式列表 ，作为变量的赋值内容。\n后面的表达式都是简单表达式，最终会调用 simpleexp 进行解析。\nexplist ::= expr {`,\u0026#39; expr} expr ::= subexpr subexpr ::= (simpleexp | unop subexpr) {binop subexpr} simpleexp ::= NUMBER | STRING | NIL | TRUE | FALSE | DOTS | constructor | FUNCTION body | primaryexp 下面有趣的地方来了，字节码和 k 表中的元素是何时生成的？ 这就和代码生成的方式紧密相关了。\nparser 模块中代码生成的强大在于，它是流式生成的。 意思即一边读入 token，分析状态，就直接生成代码！\n从代码具体来看，\n596 597 598 599 600 601 602 603 604 605 606  static int explist1 (LexState *ls, expdesc *v) { /* explist1 -\u0026gt; expr { `,\u0026#39; expr } */ int n = 1; /* at least one expression */ expr(ls, v); while (testnext(ls, \u0026#39;,\u0026#39;)) { luaK_exp2nextreg(ls-\u0026gt;fs, v); expr(ls, v); n++; } return n; }   在第 1 次分析表达式 时，读入并分析了 10，并在 第 2 次分析表达式 \u0026ldquo;second\u0026rdquo; 之前，已经生成代码并更新了 k 表。\n先来看 expr()，由于分析的是简单表达式，最终会调用 simpleexp 进行分析，\n727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775  static void simpleexp (LexState *ls, expdesc *v) { /* simpleexp -\u0026gt; NUMBER | STRING | NIL | true | false | ... | constructor | FUNCTION body | primaryexp */ switch (ls-\u0026gt;t.token) { case TK_NUMBER: { init_exp(v, VKNUM, 0); v-\u0026gt;u.nval = ls-\u0026gt;t.seminfo.r; break; } case TK_STRING: { codestring(ls, v, ls-\u0026gt;t.seminfo.ts); break; } case TK_NIL: { init_exp(v, VNIL, 0); break; } case TK_TRUE: { init_exp(v, VTRUE, 0); break; } case TK_FALSE: { init_exp(v, VFALSE, 0); break; } case TK_DOTS: { /* vararg */ FuncState *fs = ls-\u0026gt;fs; check_condition(ls, fs-\u0026gt;f-\u0026gt;is_vararg, \u0026#34;cannot use \u0026#34; LUA_QL(\u0026#34;...\u0026#34;) \u0026#34; outside a vararg function\u0026#34;); fs-\u0026gt;f-\u0026gt;is_vararg \u0026amp;= ~VARARG_NEEDSARG; /* don\u0026#39;t need \u0026#39;arg\u0026#39; */ init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 1, 0)); break; } case \u0026#39;{\u0026#39;: { /* constructor */ constructor(ls, v); return; } case TK_FUNCTION: { luaX_next(ls); body(ls, v, 0, ls-\u0026gt;linenumber); return; } default: { primaryexp(ls, v); return; } } luaX_next(ls); }   第 1 次分析 10 时，token 类型是 TK_NUMBER ，直接填充 expdesc 即可， 然后调用 luaK_exp2nextreg 生成代码。\nluaK_exp2nextreg 是一个综合过程，由更基础的几个函数组成。\n深入分析之前，先来补充之前 FuncState 未描述的一个字段，freereg。\n字节码被 vm 运行时，vm 维持一个栈，来存放寄存器和中间结果。 编译器只知晓这个栈的存在，但是在编译时，这个栈并没有真实存在， 只能凭借想象去操作它。\nfreereg 就是用来记录栈顶的变量。\n当存储新的寄存器值时，freereg 就会自增，为寄存器开出空间；\n209 210 211 212  void luaK_reserveregs (FuncState *fs, int n) { luaK_checkstack(fs, n); fs-\u0026gt;freereg += n; }   Code Snippet 13: lcode.c  相应的，如果寄存器不再使用，freereg 会自减，回收相应的空间。\n215 216 217 218 219 220  static void freereg (FuncState *fs, int reg) { if (!ISK(reg) \u0026amp;\u0026amp; reg \u0026gt;= fs-\u0026gt;nactvar) { fs-\u0026gt;freereg--; lua_assert(reg == fs-\u0026gt;freereg); } }   Code Snippet 14: lcode.c  从中可以看出，freereg 将栈分为两部分，在栈底为 local 变量保留空间（reg \u0026gt;= fs-\u0026gt;nactvar）， 上层用于计算中间结果。\n  414 415 416 417 418 419  void luaK_exp2nextreg (FuncState *fs, expdesc *e) { luaK_dischargevars(fs, e); freeexp(fs, e); luaK_reserveregs(fs, 1); exp2reg(fs, e, fs-\u0026gt;freereg - 1); }   Code Snippet 15: lcode.c  在 luaK_exp2nextreg 中，先找出下一个可用的栈/寄存器空间，然后将表达式的值解析到寄存器中， 即生成字节码。\n最终在 discharge2reg 函数生成相应指令 loadk。\n这里出现了第二个重点，对 k 表的操作。\n因为其类型为数字，所以调用的是 luaK_numberK。\n229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277  static int addk (FuncState *fs, TValue *k, TValue *v) { lua_State *L = fs-\u0026gt;L; TValue *idx = luaH_set(L, fs-\u0026gt;h, k); Proto *f = fs-\u0026gt;f; int oldsize = f-\u0026gt;sizek; if (ttisnumber(idx)) { lua_assert(luaO_rawequalObj(\u0026amp;fs-\u0026gt;f-\u0026gt;k[cast_int(nvalue(idx))], v)); return cast_int(nvalue(idx)); } else { /* constant not found; create a new entry */ setnvalue(idx, cast_num(fs-\u0026gt;nk)); luaM_growvector(L, f-\u0026gt;k, fs-\u0026gt;nk, f-\u0026gt;sizek, TValue, MAXARG_Bx, \u0026#34;constant table overflow\u0026#34;); while (oldsize \u0026lt; f-\u0026gt;sizek) setnilvalue(\u0026amp;f-\u0026gt;k[oldsize++]); setobj(L, \u0026amp;f-\u0026gt;k[fs-\u0026gt;nk], v); luaC_barrier(L, f, v); return fs-\u0026gt;nk++; } } int luaK_stringK (FuncState *fs, TString *s) { TValue o; setsvalue(fs-\u0026gt;L, \u0026amp;o, s); return addk(fs, \u0026amp;o, \u0026amp;o); } int luaK_numberK (FuncState *fs, lua_Number r) { TValue o; setnvalue(\u0026amp;o, r); return addk(fs, \u0026amp;o, \u0026amp;o); } static int boolK (FuncState *fs, int b) { TValue o; setbvalue(\u0026amp;o, b); return addk(fs, \u0026amp;o, \u0026amp;o); } static int nilK (FuncState *fs) { TValue k, v; setnilvalue(\u0026amp;v); /* cannot use nil as key; instead use table itself to represent nil */ sethvalue(fs-\u0026gt;L, \u0026amp;k, fs-\u0026gt;h); return addk(fs, \u0026amp;k, \u0026amp;v); }   Code Snippet 16: lcode.c  所有操作 k 表的方法，最终都使用 addk 操作，其作用也很简单， 在 k 表中搜索，如果存在，则直接返回相应索引，其中使用 table fs-\u0026gt;h 做 k 表元素的反向索引，加快搜索过程； 若不存在，则自增，并返回相应的索引。\n  将数字 10 存储入 k 表之后，生成 loadk 指令，将 freereg 和 k 索引作为其操作数。\n至此，parser 只读入了 token 10，便已经完成了操作 k 表，记录常数，并生成对应的指令，令人惊奇。\n对于第 2 个表达式 \u0026ldquo;second\u0026rdquo;，在 simpleexp 时，提前调用 codestring 加入了 k 表， 将其作为 VK 类型来对待。\n133 134 135  static void codestring (LexState *ls, expdesc *e, TString *s) { init_exp(e, VK, luaK_stringK(ls-\u0026gt;fs, s)); }   Code Snippet 17: lparser.c    同样的生成 loadk 指令。\n回到 localstat()，前面对变量和表达式进行解析之后，记录了 = 两边的数量 nvars nexps， adjust_assign() 进行左右数量的调整，多余的 var 空间置为 nil，多余的 exp 则省略。\n最终调用 adjustlocalvars() 调整 fs-\u0026gt;nactvar 的值。\nexpdesc #  从 localstat 的示例中，已经看到代码生成的逻辑是别具一格的。\n结合递归下降，语法制导，后缀顺序，vm opcode 语义，得以以线性顺序生成字节码。\n其中 expdesc 的作用是非常重要的，将一些属性附加到文法符号上，辅助代码生成过程。\n/* ** Expression descriptor */ typedef enum { VVOID,\t/* no value */ VNIL, VTRUE, VFALSE, VK,\t/* info = index of constant in `k\u0026#39; */ VKNUM,\t/* nval = numerical value */ VLOCAL,\t/* info = local register */ VUPVAL, /* info = index of upvalue in `upvalues\u0026#39; */ VGLOBAL,\t/* info = index of table; aux = index of global name in `k\u0026#39; */ VINDEXED,\t/* info = table register; aux = index register (or `k\u0026#39;) */ VJMP,\t/* info = instruction pc */ VRELOCABLE,\t/* info = instruction pc */ VNONRELOC,\t/* info = result register */ VCALL,\t/* info = instruction pc */ VVARARG\t/* info = instruction pc */ } expkind; typedef struct expdesc { expkind k; union { struct { int info, aux; } s; lua_Number nval; } u; int t; /* patch list of `exit when true\u0026#39; */ int f; /* patch list of `exit when false\u0026#39; */ } expdesc; Code Snippet 18: lparser.h  expdesc 用于记录 exp 表达式的相关信息。\n和 token 类型类似，expdesc 内部有字段记录类型，其它字段记录附加信息。\n所有类型用 enum expkind 表示，相应类型后的注释描述了对应其它字段需要记录的信息。\n其中重点的函数是 discharge2reg 和 dischargevars，用于解析相应的 expdesc，生成代码并更新状态。\n   expkind u discharge     VVOID     VNIL  生成指令 loadnil，重置为 VNONRELOC   VTRUE  生成指令 loadbool，重置为 VNONRELOC   VFALSE  生成指令 loadbool，重置为 VNONRELOC   VK info 记录 k 表索引 生成指令 loadk，重置为 VNONRELOC   VKNUM nval 记录数值 生成指令 loadk，重置为 VNONRELOC   VLOCAL info 记录寄存器索引 重置为 VNONRELOC   VUPVAL info 记录 upvalues 数组中的索引 生成指令 GETUPVAL, 重置为 VRELOCABLE，info 记录指令索引   VGLOBAL info 全局表的索引，aux 全局名称的 k 表索引 生成指令 GETGLOBAL, 重置为 VRELOCABLE，info 记录指令索引   VINDEXED info table 所在寄存器的索引，aux 索引值的 RK 值 生成指令 GETTABLE, 重置为 VRELOCABLE，info 记录指令索引   VJMP info 当前指令索引    VRELOCABLE info 当前指令索引 定位到指令位置，修改 A 参数为 reg   VNONRELOC info 最终解析得到的寄存器位置 如果当前寄存器位置与目标位置不同，则生成 move 指令；相同则什么都不做   VCALL info 当前指令索引 重置为 VNONRELOC，info 记录指令的 A 参数   VVARARG info 当前指令索引 重置为 VRELOCABLE    具体如此设计的原因及作用，还需要读者在不同情况下再尝试领会。\nassign #  本节来探讨赋值语句\nstat ::= exprstat exprstat ::= assignstat assignstat ::= (prefixexp | primaryexp (`.\u0026#39; NAME | `[\u0026#39; expr `]\u0026#39;)) assignment assignment ::= `,\u0026#39; assignstat | `=\u0026#39; explist primaryexp ::= prefixexp {`.\u0026#39; NAME | `[\u0026#39; expr `]\u0026#39; | `:\u0026#39; NAME funcargs | funcargs} prefixexp ::= NAME | `(\u0026#39; expr `)\u0026#39; 赋值语句根据变量的类型不同，分为 global upvalue local indexed 几种情况， 对应 expdesc 中的 VGLOBAL VUPVAL VLOCAL VINDEXED。\nglobal #  先来看 global 的赋值情况。\n分析如下代码，\na, b, c = 10, 20, 30 ; function [0] definition (level 1) ; 0 upvalues, 0 params, 2 is_vararg, 3 stacks .function 0 0 2 3 .const \u0026#34;a\u0026#34; ; 0 .const \u0026#34;b\u0026#34; ; 1 .const \u0026#34;c\u0026#34; ; 2 .const 10 ; 3 .const 20 ; 4 .const 30 ; 5 [1] loadk 0 3 ; 10 [2] loadk 1 4 ; 20 [3] loadk 2 5 ; 30 [4] setglobal 2 2 ; c [5] setglobal 1 1 ; b [6] setglobal 0 0 ; a [7] return 0 1 ; end of function 从 chunk 递归向下，最终到达 assignment 函数。\n从 ebnf 描述中可以看出，assignment 是一个递归的过程。\n931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962  static void assignment (LexState *ls, struct LHS_assign *lh, int nvars) { expdesc e; check_condition(ls, VLOCAL \u0026lt;= lh-\u0026gt;v.k \u0026amp;\u0026amp; lh-\u0026gt;v.k \u0026lt;= VINDEXED, \u0026#34;syntax error\u0026#34;); if (testnext(ls, \u0026#39;,\u0026#39;)) { /* assignment -\u0026gt; `,\u0026#39; primaryexp assignment */ struct LHS_assign nv; nv.prev = lh; primaryexp(ls, \u0026amp;nv.v); if (nv.v.k == VLOCAL) check_conflict(ls, lh, \u0026amp;nv.v); luaY_checklimit(ls-\u0026gt;fs, nvars, LUAI_MAXCCALLS - ls-\u0026gt;L-\u0026gt;nCcalls, \u0026#34;variables in assignment\u0026#34;); assignment(ls, \u0026amp;nv, nvars+1); } else { /* assignment -\u0026gt; `=\u0026#39; explist1 */ int nexps; checknext(ls, \u0026#39;=\u0026#39;); nexps = explist1(ls, \u0026amp;e); if (nexps != nvars) { adjust_assign(ls, nvars, nexps, \u0026amp;e); if (nexps \u0026gt; nvars) ls-\u0026gt;fs-\u0026gt;freereg -= nexps - nvars; /* remove extra values */ } else { luaK_setoneret(ls-\u0026gt;fs, \u0026amp;e); /* close last expression */ luaK_storevar(ls-\u0026gt;fs, \u0026amp;lh-\u0026gt;v, \u0026amp;e); return; /* avoid default */ } } init_exp(\u0026amp;e, VNONRELOC, ls-\u0026gt;fs-\u0026gt;freereg-1); /* default assignment */ luaK_storevar(ls-\u0026gt;fs, \u0026amp;lh-\u0026gt;v, \u0026amp;e); }   Code Snippet 19: lparser.c  在遇到 = 之前，执行 if 语句块，递归调用 primaryexp 分析变量； 遇到 = 之后，执行 else 语句块，分析表达式。 在递归的终点，将表达式得到的值赋值给变量。\n因为示例代码中变量都很简单，primaryexp 主要调用 prefixexp 进行分析。\n667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687  static void prefixexp (LexState *ls, expdesc *v) { /* prefixexp -\u0026gt; NAME | \u0026#39;(\u0026#39; expr \u0026#39;)\u0026#39; */ switch (ls-\u0026gt;t.token) { case \u0026#39;(\u0026#39;: { int line = ls-\u0026gt;linenumber; luaX_next(ls); expr(ls, v); check_match(ls, \u0026#39;)\u0026#39;, \u0026#39;(\u0026#39;, line); luaK_dischargevars(ls-\u0026gt;fs, v); return; } case TK_NAME: { singlevar(ls, v); return; } default: { luaX_syntaxerror(ls, \u0026#34;unexpected symbol\u0026#34;); return; } } }   Code Snippet 20: lparser.c  对应其中的 TK_NAME 类型，调用 singlevar 确定变量的类型，内容调用 singlevaraux 来实现。\n224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253  static int singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) { if (fs == NULL) { /* no more levels? */ init_exp(var, VGLOBAL, NO_REG); /* default is global variable */ return VGLOBAL; } else { int v = searchvar(fs, n); /* look up at current level */ if (v \u0026gt;= 0) { init_exp(var, VLOCAL, v); if (!base) markupval(fs, v); /* local will be used as an upval */ return VLOCAL; } else { /* not found at current level; try upper one */ if (singlevaraux(fs-\u0026gt;prev, n, var, 0) == VGLOBAL) return VGLOBAL; var-\u0026gt;u.s.info = indexupvalue(fs, n, var); /* else was LOCAL or UPVAL */ var-\u0026gt;k = VUPVAL; /* upvalue in this level */ return VUPVAL; } } } static void singlevar (LexState *ls, expdesc *var) { TString *varname = str_checkname(ls); FuncState *fs = ls-\u0026gt;fs; if (singlevaraux(fs, varname, var, 1) == VGLOBAL) var-\u0026gt;u.s.info = luaK_stringK(fs, varname); /* info points to global name */ }   Code Snippet 21: lparser.c  singlevaraux 是非常关键的过程，回忆之前在分析过程中，关于嵌套的 function 定义和 fs-\u0026gt;prev 的链条， singlevaraux 就顺着 fs-\u0026gt;prev 不断向上层作用域寻找变量。\n如果 fs == NULL ，说明已经到顶层，变量只能为 global 类型； 如果在当前作用域可找到，说明是 local 变量；其它为 upval 变量。\n示例中 a b c 都为全局变量，所以 singlevaraux 返回 VGLOBAL， 将相应 expdesc 类型赋值为 VGLOBAL，且 info 存储了变量名对应的 k 表索引。\n表达式分析阶段，将 10 20 30 加入 k 表，同时载入寄存器。\n最终赋值阶段，在每个递归层次，用 luaK_storevar 来存储。\n472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500  void luaK_storevar (FuncState *fs, expdesc *var, expdesc *ex) { switch (var-\u0026gt;k) { case VLOCAL: { freeexp(fs, ex); exp2reg(fs, ex, var-\u0026gt;u.s.info); return; } case VUPVAL: { int e = luaK_exp2anyreg(fs, ex); luaK_codeABC(fs, OP_SETUPVAL, e, var-\u0026gt;u.s.info, 0); break; } case VGLOBAL: { int e = luaK_exp2anyreg(fs, ex); luaK_codeABx(fs, OP_SETGLOBAL, e, var-\u0026gt;u.s.info); break; } case VINDEXED: { int e = luaK_exp2RK(fs, ex); luaK_codeABC(fs, OP_SETTABLE, var-\u0026gt;u.s.info, var-\u0026gt;u.s.aux, e); break; } default: { lua_assert(0); /* invalid var kind to store */ break; } } freeexp(fs, ex); }   Code Snippet 22: lcode.c  对应 case VGLOBAL，生成 setglobal 指令。\nupvalue #  分析如下代码，\nlocal a function f() a = 10 end ; function [0] definition (level 1) ; 0 upvalues, 0 params, 2 is_vararg, 2 stacks .function 0 0 2 2 .local \u0026#34;a\u0026#34; ; 0 .const \u0026#34;f\u0026#34; ; 0 ; function [0] definition (level 2) ; 1 upvalues, 0 params, 0 is_vararg, 2 stacks .function 1 0 0 2 .upvalue \u0026#34;a\u0026#34; ; 0 .const 10 ; 0 [1] loadk 0 0 ; 10 [2] setupval 0 0 ; a [3] return 0 1 ; end of function [1] closure 1 0 ; 1 upvalues [2] move 0 0 [3] setglobal 1 0 ; f [4] return 0 1 ; end of function 对于外层函数，a 是 local 变量，而对应内层函数，a 为 upval 变量。\n基本过程同 global，不过 singlevaraux 搜索得到 VUPVAL，生成 setupval 指令。\nlocal #  1 2 3 4  local a = 1 local b b = 1   line 1 为 local 赋值语句，而 line 4 为普通赋值语句，不过恰巧赋值给 local 变量。\n分析如下示例，\nlocal a, b b = 10 ; function [0] definition (level 1) ; 0 upvalues, 0 params, 2 is_vararg, 2 stacks .function 0 0 2 2 .local \u0026#34;a\u0026#34; ; 0 .local \u0026#34;b\u0026#34; ; 1 .const 10 ; 0 [1] loadk 1 0 ; 10 [2] return 0 1 ; end of function 分析过程与上相同，singlevaraux 确定为 VLOCAL，针对寄存器位置，直接生成 loadk。\nindexed #  local t = {} t[\u0026#39;a\u0026#39;] = 10 ; function [0] definition (level 1) ; 0 upvalues, 0 params, 2 is_vararg, 2 stacks .function 0 0 2 2 .local \u0026#34;t\u0026#34; ; 0 .const \u0026#34;a\u0026#34; ; 0 .const 10 ; 1 [1] newtable 0 0 0 ; array=0, hash=0 [2] settable 0 256 257 ; \u0026#34;a\u0026#34; 10 [3] return 0 1 ; end of function VINDEXED 的分析分为两部分，singlevar 分析 t 为 local 变量， 同时在 primaryexp 中继续分析 \u0026lsquo;a\u0026rsquo; 为字符串值，存储在 k 表直接引用。 最终使用 luaK_indexed 确定 expdesc 的类型及相关数据。\n621 622 623 624  void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) { t-\u0026gt;u.s.aux = luaK_exp2RK(fs, k); t-\u0026gt;k = VINDEXED; }   Code Snippet 23: lcode.c  在最终赋值时，生成 gettable 指令。\n之所以使用 RK(C) 作为索引，是因为索引值未必是常数，也可能是一个表，一个函数等其它值， 这里由 table 的特性决定的，这种通用的值只能由寄存器存储。\nfunction #  这个小节关注 function 分析的过程。\n语法描述中，涉及函数定义的地方，主要有 3 处，\nfuncstat ::= FUNCTION funcname body funcname ::= NAME {`.\u0026#39; NAME} [`:\u0026#39; NAME] body ::= `(\u0026#39; parlist `)\u0026#39; chunk END parlist ::= [ DOTS | NAME {`,\u0026#39; NAME} [`,\u0026#39; DOTS] ] localstat ::= LOCAL FUNCTION NAME body simpleexp ::= NUMBER | STRING | NIL | TRUE | FALSE | DOTS | constructor | FUNCTION body | primaryexp 第 1 种对应全局函数定义，第 2 种对应 local 函数定义，第 3 种对应函数函数定义。\nfunction f() end local function f() end local f = function () end 但无论哪一种形式，函数分析的核心函数在于 body，通过 chunk 生成 Proto， 最终赋值予 global/local 变量。\nparam #  先来看参数部分。\nlocal function f(a, b, ...) end ; function [0] definition (level 1) ; 0 upvalues, 0 params, 2 is_vararg, 2 stacks .function 0 0 2 2 .local \u0026#34;f\u0026#34; ; 0 ; function [0] definition (level 2) ; 0 upvalues, 2 params, 7 is_vararg, 3 stacks .function 0 2 7 3 .local \u0026#34;a\u0026#34; ; 0 .local \u0026#34;b\u0026#34; ; 1 .local \u0026#34;arg\u0026#34; ; 2 [1] return 0 1 ; end of function [1] closure 0 0 ; 0 upvalues [2] return 0 1 ; end of function 参数部分由 parlist 处理，分为固定参数和可变参数。\n543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573  static void parlist (LexState *ls) { /* parlist -\u0026gt; [ param { `,\u0026#39; param } ] */ FuncState *fs = ls-\u0026gt;fs; Proto *f = fs-\u0026gt;f; int nparams = 0; f-\u0026gt;is_vararg = 0; if (ls-\u0026gt;t.token != \u0026#39;)\u0026#39;) { /* is `parlist\u0026#39; not empty? */ do { switch (ls-\u0026gt;t.token) { case TK_NAME: { /* param -\u0026gt; NAME */ new_localvar(ls, str_checkname(ls), nparams++); break; } case TK_DOTS: { /* param -\u0026gt; `...\u0026#39; */ luaX_next(ls); #if defined(LUA_COMPAT_VARARG) \t/* use `arg\u0026#39; as default name */ new_localvarliteral(ls, \u0026#34;arg\u0026#34;, nparams++); f-\u0026gt;is_vararg = VARARG_HASARG | VARARG_NEEDSARG; #endif \tf-\u0026gt;is_vararg |= VARARG_ISVARARG; break; } default: luaX_syntaxerror(ls, \u0026#34;\u0026lt;name\u0026gt; or \u0026#34; LUA_QL(\u0026#34;...\u0026#34;) \u0026#34; expected\u0026#34;); } } while (!f-\u0026gt;is_vararg \u0026amp;\u0026amp; testnext(ls, \u0026#39;,\u0026#39;)); } adjustlocalvars(ls, nparams); f-\u0026gt;numparams = cast_byte(fs-\u0026gt;nactvar - (f-\u0026gt;is_vararg \u0026amp; VARARG_HASARG)); luaK_reserveregs(fs, fs-\u0026gt;nactvar); /* reserve register for parameters */ }   Code Snippet 24: lparser.c  固定参数的处理方法，和 local 变量相同，不再赘述。\n对于可变参数，即参数列表的最后定义中出现 ... ，表明函数接收可变数量的参数， 全部收纳入 ... 中。\n在 lua5.0 中，可以在参数定义时使用 ... ， 但是没有 ... 表达式， 意味着在函数体中使用传入的参数时，通过变量 arg 来引用。\narg 是一个 table，以数组形式存储了所有可变参数，同时 arg.n 存储了数组的长度。\n下面是 lua5.1 的同义描述，\nlocal function f(a, b, ...) local arg = {...} arg.n = select(\u0026#34;#\u0026#34;, ...) end lua5.1 默认提供了对变量 arg 的兼容性，所以才会出现注册 arg 变量的情况。\nfs-\u0026gt;is_vararg 是用来记录可变参数状态的变量，含义由 3 个二进制位综合表示。\n256 257 258 259  /* masks for new-style vararg */ #define VARARG_HASARG\t1 #define VARARG_ISVARARG\t2 #define VARARG_NEEDSARG\t4   Code Snippet 25: lobject.h     macro number desc     VARARG_HASARG 0b001 方便计算参数数量，直接使用 \u0026amp; 运算就可以   VARARG_ISVARARG 0b010 是否存在可变参数   VARARG_NEEDSARG 0b100 是否需要 arg，当函数内部出现 ... 表达式时，置为 0    内部有如下几种模式\n   cond is_vararg     无可变参数 0b000   chunk 0b010   不需要 arg 变量 0b011   默认的兼容情况 0b111    upval #  函数体就是 chunk 过程，作为分析的入口，在内部被递归调用，这里不再多做解释。\n这里想重点说明的是，函数对 upvalue 的引用过程。\n1 2 3 4 5 6 7 8 9 10  local a local function f() local b local function g() b = 20 a = 10 end end   示例代码存在 3 层函数嵌套，chunk f g。\ng 中引用的变量 a b 对于 g 而言都是 upvalue 类型。\n当分析到 line 7 时，fs 的链接关系如下，\n  首先分析变量 b，\n183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204  static int singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) { if (fs == NULL) { /* no more levels? */ init_exp(var, VGLOBAL, NO_REG); /* default is global variable */ return VGLOBAL; } else { int v = searchvar(fs, n); /* look up at current level */ if (v \u0026gt;= 0) { init_exp(var, VLOCAL, v); if (!base) markupval(fs, v); /* local will be used as an upval */ return VLOCAL; } else { /* not found at current level; try upper one */ if (singlevaraux(fs-\u0026gt;prev, n, var, 0) == VGLOBAL) return VGLOBAL; var-\u0026gt;u.s.info = indexupvalue(fs, n, var); /* else was LOCAL or UPVAL */ var-\u0026gt;k = VUPVAL; /* upvalue in this level */ return VUPVAL; } } }   Code Snippet 26: lparser.c  在 fs g() 中搜索无果，搜索上层 fs f()，在 fs f() 的 local 变量中找到 b， 调用 indexupvalue，然后标识为 VUPVAL 类型返回。\n183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204  static int indexupvalue (FuncState *fs, TString *name, expdesc *v) { int i; Proto *f = fs-\u0026gt;f; int oldsize = f-\u0026gt;sizeupvalues; for (i=0; i\u0026lt;f-\u0026gt;nups; i++) { if (fs-\u0026gt;upvalues[i].k == v-\u0026gt;k \u0026amp;\u0026amp; fs-\u0026gt;upvalues[i].info == v-\u0026gt;u.s.info) { lua_assert(f-\u0026gt;upvalues[i] == name); return i; } } /* new one */ luaY_checklimit(fs, f-\u0026gt;nups + 1, LUAI_MAXUPVALUES, \u0026#34;upvalues\u0026#34;); luaM_growvector(fs-\u0026gt;L, f-\u0026gt;upvalues, f-\u0026gt;nups, f-\u0026gt;sizeupvalues, TString *, MAX_INT, \u0026#34;\u0026#34;); while (oldsize \u0026lt; f-\u0026gt;sizeupvalues) f-\u0026gt;upvalues[oldsize++] = NULL; f-\u0026gt;upvalues[f-\u0026gt;nups] = name; luaC_objbarrier(fs-\u0026gt;L, f, name); lua_assert(v-\u0026gt;k == VLOCAL || v-\u0026gt;k == VUPVAL); fs-\u0026gt;upvalues[f-\u0026gt;nups].k = cast_byte(v-\u0026gt;k); fs-\u0026gt;upvalues[f-\u0026gt;nups].info = cast_byte(v-\u0026gt;u.s.info); return f-\u0026gt;nups++; }   Code Snippet 27: lparser.c  在 indexupvalue 中，先搜索是否已经存在 upvalue b，若没有则存储到 upvalues 数组中。\nf-\u0026gt;upvalues 记录变量名，fs-\u0026gt;upvalues 记录 upval 信息。\n    upvalue 其实可分为两种情况，一种是 VLOCAL，一种是 VUPVAL。\nb 属于 VLOCAL 的情况，因为 b 和 g() 在一个层级，g() 内部只需要向上查找一个层级便可定位 b。\n48 49 50 51  typedef struct upvaldesc { lu_byte k; lu_byte info; } upvaldesc;   Code Snippet 28: lparser.h  fs-\u0026gt;upvalues 在记录 VLOCAL 的同时，也记录其对应的寄存器位置。\n再来搜索变量 a，不存在于 g()，也不存在于 f() 中，在 chunk() 中找到。\n此时 upvalues 数组的情况如下。\n    a 对于 g() 属于 VUPVAL 的情况，对于 f() 属于 VLOCAL 的情况。\n值得注意，在搜索变量 a 的时候，indexupvalue 调用了两次，一次从 fs g() 出发，一次从 fs f() 出发。 这也解释了，为什么 f() 没有直接使用 a，但是其 upvalues 表中依然记录了 a。\n当函数 g() 解析结束之后，将 Proto 结果链接到上层。\n  得到 Proto 之后，生成 closure 指令将其赋值予变量 g。\n同时在 closure 指令之后，生成了额外的两条指令，按顺序表明当前 closure 的 upvalue 的类型和索引信息。\n[2] move 0 0 [3] getupval 0 0 ; a move 指令此时不表示普通的 move 含义，参数 A 无用，参数 B 指代 VLOCAL 的栈索引。 表示新建的 closure 第 1 个 upvalue 是 VLOCAL 类型， 指向当前作用域索引为 0 的寄存器。\ngetupval 指令同样，参数 A 无用，参数 B 表示上层 closure 中 upvalues 表中的序号。 表示第 2 个 upvalue 是 VUPVAL 类型，指向上个作用域索引为 0 的 upvalue。\n使用这种方式，将 upvalue 的类型和索引存储到 code 中， 所以 f-\u0026gt;upvalues 只需要单纯记录变量名称就足够了。\nvm 在执行的时候，自然会理会其中的含义并做出相应处理。\ndo #  相信很多人都对 ebnf 描述中的 block 和 chunk 有疑问。\nstat ::= dostat dostat ::= DO block END block ::= chunk chunk 已经是分析的入口，为什么 block 又生成 chunk，这样看来 block 不是应该在 chunk 上层吗？\n其实这个问题可以这样看，chunk 可以看作是分析语句列表的方法， block 调用 chunk，是为了分析 block 中的语句列表，并不是要生成新的 FuncState。\n实际上，block 有其自己的一套逻辑。\ndo 语句是最纯粹调用 block 的语句。\nlocal a do local b local c do local d a = 10 end end ; function [0] definition (level 1) ; 0 upvalues, 0 params, 2 is_vararg, 4 stacks .function 0 0 2 4 .local \u0026#34;a\u0026#34; ; 0 .local \u0026#34;b\u0026#34; ; 1 .local \u0026#34;c\u0026#34; ; 2 .local \u0026#34;d\u0026#34; ; 3 .const 10 ; 0 [1] loadk 0 0 ; 10 [2] return 0 1 ; end of function 从结果中，好像什么都看不到，和正常声明变量，进行赋值，是一样的效果。\n实际上，do 语句的作用主要在于描述块作用域。\n在 block() 方法中，\n881 882 883 884 885 886 887 888 889  static void block (LexState *ls) { /* block -\u0026gt; chunk */ FuncState *fs = ls-\u0026gt;fs; BlockCnt bl; enterblock(fs, \u0026amp;bl, 0); chunk(ls); lua_assert(bl.breaklist == NO_JUMP); leaveblock(fs); }   Code Snippet 29: lparser.c  先后调用 enterblock 和 leaveblock 方法，操作 fs-\u0026gt;bl。\n这里也说明了，虽然同样调用 chunk，但是在函数定义时，其使用 open_func close_func 来操作 fs-\u0026gt;prev 形成链状结构，所以 block() 的行为主要是由 enterblock leaveblock 决定的。\n37 38 39 40 41 42 43 44 45 46  /* ** nodes for block list (list of active blocks) */ typedef struct BlockCnt { struct BlockCnt *previous; /* chain */ int breaklist; /* list of jumps out of this loop */ lu_byte nactvar; /* # active locals outside the breakable structure */ lu_byte upval; /* true if some variable in the block is an upvalue */ lu_byte isbreakable; /* true if `block\u0026#39; is a loop */ } BlockCnt;   Code Snippet 30: lparser.c  BlockCnt 的结构并不复杂，\n struct BlockCnt *previous ，指向父 block int breaklist ，在 while 章节讲解 lu_byte nactvar ，进入 block 前保存 nactvar lu_byte upval ，当前块作用域中是否有 local 变量用作 upvalue，在 repeat 章节讲解 lu_byte isbreakable ，是否是一个循环语句块，在 while 章节讲解。   285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307  static void enterblock (FuncState *fs, BlockCnt *bl, lu_byte isbreakable) { bl-\u0026gt;breaklist = NO_JUMP; bl-\u0026gt;isbreakable = isbreakable; bl-\u0026gt;nactvar = fs-\u0026gt;nactvar; bl-\u0026gt;upval = 0; bl-\u0026gt;previous = fs-\u0026gt;bl; fs-\u0026gt;bl = bl; lua_assert(fs-\u0026gt;freereg == fs-\u0026gt;nactvar); } static void leaveblock (FuncState *fs) { BlockCnt *bl = fs-\u0026gt;bl; fs-\u0026gt;bl = bl-\u0026gt;previous; removevars(fs-\u0026gt;ls, bl-\u0026gt;nactvar); if (bl-\u0026gt;upval) luaK_codeABC(fs, OP_CLOSE, bl-\u0026gt;nactvar, 0, 0); /* a block either controls scope or breaks (never both) */ lua_assert(!bl-\u0026gt;isbreakable || !bl-\u0026gt;upval); lua_assert(bl-\u0026gt;nactvar == fs-\u0026gt;nactvar); fs-\u0026gt;freereg = fs-\u0026gt;nactvar; /* free registers */ luaK_patchtohere(fs, bl-\u0026gt;breaklist); }   Code Snippet 31: lparser.c  enterblock 新建 BlockCnt，指向父 block，并记录当前 nactvar。 leaveblock 则相反，删除顶层 block，将 fs-\u0026gt;freereg 重置回原来的 nactvar。\n明显地起到了作用域分隔的作用。\n  在第 1 次进入 do block 时，外部只定义了 local a，只有一个局部变量， 此时保存 nactvar 为 1。\n第 2 次进入 do block 时，增加了定义 local b c，新的 BlockCnt 链接到父 block， 保存 nactvar 为 3。\n在内部，修改 a = 10，这个 a 正是最外层的 local a 而不是 upvalue，因为 upvalue 只作用于不同函数之间，目前 local a b c d 是属于一个函数作用域的。\n离开内层 do block 时，恢复 freereg 到 nactvar=3 且重置了 fs-\u0026gt;nactvar，相当于回收了变量 d。\n至于 block 在循环中的作用，到循环语句章节再讲解。\nif #  本节来分析，在代码生成过程中是如何处理 if 语句的。\nstat ::= ifstat ifstat ::= IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END cond ::= expr block ::= chunk 前面已经提到过，整体的分析过程是从左至右，从前至后的， 而 if 是分支结构，不同于分析过程的线性结构。\nlua 内部使用一种精巧的方式解决这个问题。\nif #  首先来看示例代码，\nlocal a, b if b then a = 1 end ; function [0] definition (level 1) ; 0 upvalues, 0 params, 2 is_vararg, 2 stacks .function 0 0 2 2 .local \u0026#34;a\u0026#34; ; 0 .local \u0026#34;b\u0026#34; ; 1 .const 1 ; 0 [1] test 1 0 ; to [3] if true [2] jmp 1 ; to [4] [3] loadk 0 0 ; 1 [4] return 0 1 ; end of function 整体流程的示意如下，TRUE 表示条件为真所执行的字节码，这里为 loadk。\n  在分支结构中扮演重要角色的是两种指令，test 和 jmp。\n在 vm 的执行过程中，pc 问题默认自增的，即执行完当前指令后，pc++， 对于 test 和 jmp 也不例外。\njmp 指令有一个参数，即跳转的距离，可正可负，意味着可以向前跳转，也可以向后。\n根据 pc++ 的原则，\n 指令 jmp -1 表示循环执行当前的 jmp 指令，因为 jmp 跳转到自身 指令 jmp 0 表示跳转到下一条指令，即正常执行 指令 jmp 1 表示略过下一条指令，跳转到下下一条指令  jmp 是无条件跳转，而 test 指令不同，需要针对 True 和 False 跳转到不同的地方。 lua 使用了一种简洁的模式来安排。\n（假设参数 C = 0 ）test 指令之后固定接着一条 jmp 指令，用于执行 False 跳转。 jmp 指令之后紧接着 True 语句块。\n在这种安排下，\n 如果为 False，正常执行下一条指令，下一条 jmp 跳转到 False 语句块 如果为 True，vm 执行 pc++ ++，跳过 test 后的 jmp 指令，执行 True 语句块  这样就不用使得 test 指令过于复杂。\n对照示例代码，内部使用 ifstat() 来分析 if 语句。\n1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162  static int test_then_block (LexState *ls) { /* test_then_block -\u0026gt; [IF | ELSEIF] cond THEN block */ int condexit; luaX_next(ls); /* skip IF or ELSEIF */ condexit = cond(ls); checknext(ls, TK_THEN); block(ls); /* `then\u0026#39; part */ return condexit; } static void ifstat (LexState *ls, int line) { /* ifstat -\u0026gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */ FuncState *fs = ls-\u0026gt;fs; int flist; int escapelist = NO_JUMP; flist = test_then_block(ls); /* IF cond THEN block */ while (ls-\u0026gt;t.token == TK_ELSEIF) { luaK_concat(fs, \u0026amp;escapelist, luaK_jump(fs)); luaK_patchtohere(fs, flist); flist = test_then_block(ls); /* ELSEIF cond THEN block */ } if (ls-\u0026gt;t.token == TK_ELSE) { luaK_concat(fs, \u0026amp;escapelist, luaK_jump(fs)); luaK_patchtohere(fs, flist); luaX_next(ls); /* skip ELSE (after patch, for correct line info) */ block(ls); /* `else\u0026#39; part */ } else luaK_concat(fs, \u0026amp;escapelist, flist); luaK_patchtohere(fs, escapelist); check_match(ls, TK_END, TK_IF, line); }   Code Snippet 32: lparser.c  使用 test_then_block() 分析 IF cond THEN block 的部分， 使用 cond() 分析条件部分，\n965 966 967 968 969 970 971 972  static int cond (LexState *ls) { /* cond -\u0026gt; exp */ expdesc v; expr(ls, \u0026amp;v); /* read condition */ if (v.k == VNIL) v.k = VFALSE; /* `falses\u0026#39; are all equal here */ luaK_goiftrue(ls-\u0026gt;fs, \u0026amp;v); return v.f; }   Code Snippet 33: lparser.c  进入 luaK_goiftrue() ，调用 jumponcond 和 condjump ，生成了 test 指令和 jmp 指令，\n524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560  static int jumponcond (FuncState *fs, expdesc *e, int cond) { if (e-\u0026gt;k == VRELOCABLE) { Instruction ie = getcode(fs, e); if (GET_OPCODE(ie) == OP_NOT) { fs-\u0026gt;pc--; /* remove previous OP_NOT */ return condjump(fs, OP_TEST, GETARG_B(ie), 0, !cond); } /* else go through */ } discharge2anyreg(fs, e); freeexp(fs, e); return condjump(fs, OP_TESTSET, NO_REG, e-\u0026gt;u.s.info, cond); } void luaK_goiftrue (FuncState *fs, expdesc *e) { int pc; /* pc of last jump */ luaK_dischargevars(fs, e); switch (e-\u0026gt;k) { case VK: case VKNUM: case VTRUE: { pc = NO_JUMP; /* always true; do nothing */ break; } case VJMP: { invertjump(fs, e); pc = e-\u0026gt;u.s.info; break; } default: { pc = jumponcond(fs, e, 0); break; } } luaK_concat(fs, \u0026amp;e-\u0026gt;f, pc); /* insert last jump in `f\u0026#39; list */ luaK_patchtohere(fs, e-\u0026gt;t); e-\u0026gt;t = NO_JUMP; }   Code Snippet 34: lcode.c  74 75 76 77  static int condjump (FuncState *fs, OpCode op, int A, int B, int C) { luaK_codeABC(fs, op, A, B, C); return luaK_jump(fs); }   Code Snippet 35: lcode.c  最终 cond() 返回 jmp 指令的索引，在 ifstat() 中由 flist 保存。\n下面就是关键的地方，lua 如何确定跳转的位置，其中有几个关键的过程，concat，patch 和 dischargejpc。\n在 test_then_block() 之后，解析了 cond 和 true block，并保留了 jmp 指令的索引。\n  因为其后没有 else/elseif 语句，直接执行 line 1159，\n185 186 187 188 189 190 191 192 193 194 195 196  void luaK_concat (FuncState *fs, int *l1, int l2) { if (l2 == NO_JUMP) return; else if (*l1 == NO_JUMP) *l1 = l2; else { int list = *l1; int next; while ((next = getjump(fs, list)) != NO_JUMP) /* find last element */ list = next; fixjump(fs, list, l2); } }   Code Snippet 36: lcode.c  将 flist 链接到 escapelist 上，\n  其后执行 line 1160，执行 patch 过程，\n179 180 181 182  void luaK_patchtohere (FuncState *fs, int list) { luaK_getlabel(fs); luaK_concat(fs, \u0026amp;fs-\u0026gt;jpc, list); }   Code Snippet 37: lcode.c  将 escapelist 链接到 fs-\u0026gt;jpc 上，\n  最终在生成 TRUE 之后的语句时，执行 dischargejpc 过程，\n789 790 791 792 793 794 795 796 797 798 799 800 801  static int luaK_code (FuncState *fs, Instruction i, int line) { Proto *f = fs-\u0026gt;f; dischargejpc(fs); /* `pc\u0026#39; will change */ /* put new instruction in code array */ luaM_growvector(fs-\u0026gt;L, f-\u0026gt;code, fs-\u0026gt;pc, f-\u0026gt;sizecode, Instruction, MAX_INT, \u0026#34;code size overflow\u0026#34;); f-\u0026gt;code[fs-\u0026gt;pc] = i; /* save corresponding line information */ luaM_growvector(fs-\u0026gt;L, f-\u0026gt;lineinfo, fs-\u0026gt;pc, f-\u0026gt;sizelineinfo, int, MAX_INT, \u0026#34;code size overflow\u0026#34;); f-\u0026gt;lineinfo[fs-\u0026gt;pc] = line; return fs-\u0026gt;pc++; }   Code Snippet 38: lcode.c  150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166  static void patchlistaux (FuncState *fs, int list, int vtarget, int reg, int dtarget) { while (list != NO_JUMP) { int next = getjump(fs, list); if (patchtestreg(fs, list, reg)) fixjump(fs, list, vtarget); else fixjump(fs, list, dtarget); /* jump to default target */ list = next; } } static void dischargejpc (FuncState *fs) { patchlistaux(fs, fs-\u0026gt;jpc, fs-\u0026gt;pc, NO_REG, fs-\u0026gt;pc); fs-\u0026gt;jpc = NO_JUMP; }   Code Snippet 39: lcode.c    此时已经在 TRUE 语句块之外，也明确当前的指令索引和 jmp 指令索引， 直接计算距离的差值，修改 jmp 指令的参数，跳转到此位置。\n综合来看，concat 将需要重新定位的 jmp 指令链接起来，最终链接到 jpc 上， 由 dischargejpc 过程，调整所有链接的 jmp 指令，使其跳转到当前位置。\n单纯的 if 语句比较简单，读者或许还体会不到这种方法的作用，下面来看更复杂的语句。\nif else #  local a, b if b then a = 1 else a = 0 end ; function [0] definition (level 1) ; 0 upvalues, 0 params, 2 is_vararg, 2 stacks .function 0 0 2 2 .local \u0026#34;a\u0026#34; ; 0 .local \u0026#34;b\u0026#34; ; 1 .const 1 ; 0 .const 0 ; 1 [1] test 1 0 ; to [3] if true [2] jmp 2 ; to [5] [3] loadk 0 0 ; 1 [4] jmp 1 ; to [6] [5] loadk 0 1 ; 0 [6] return 0 1 ; end of function   1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162  static void ifstat (LexState *ls, int line) { /* ifstat -\u0026gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */ FuncState *fs = ls-\u0026gt;fs; int flist; int escapelist = NO_JUMP; flist = test_then_block(ls); /* IF cond THEN block */ while (ls-\u0026gt;t.token == TK_ELSEIF) { luaK_concat(fs, \u0026amp;escapelist, luaK_jump(fs)); luaK_patchtohere(fs, flist); flist = test_then_block(ls); /* ELSEIF cond THEN block */ } if (ls-\u0026gt;t.token == TK_ELSE) { luaK_concat(fs, \u0026amp;escapelist, luaK_jump(fs)); luaK_patchtohere(fs, flist); luaX_next(ls); /* skip ELSE (after patch, for correct line info) */ block(ls); /* `else\u0026#39; part */ } else luaK_concat(fs, \u0026amp;escapelist, flist); luaK_patchtohere(fs, escapelist); check_match(ls, TK_END, TK_IF, line); }   Code Snippet 40: lparser.c  在 if else 语句中，解析 cond 和 true block 之后，要继续解析 else false block 部分。\nfalse block 生成字节码也遵循一定的模式，先生成 jmp 指令，用于跳出 true block， 其次再生成 false block。\n其中将这个 jmp 链接到 escapelist 上，因为分析到 false block 的起始位置， 所以重定向 test 部分的 jmp 到这个位置。\n  最终将 escapelist 链接到 jpc 上，进行 dischargejpc 操作。\n  由这种模式可以看出，flist 表示 false list，escapelist 表示跳出 true list。\ndischarge 的过程就是先将目标链接到 fs-\u0026gt;jpc 上，然后从 fs-\u0026gt;jpc 开始，重新定位所有 jmp 的目标位置。\nif elseif #  local a, b, c if b then a = 1 elseif c then a = 2 end ; function [0] definition (level 1) ; 0 upvalues, 0 params, 2 is_vararg, 3 stacks .function 0 0 2 3 .local \u0026#34;a\u0026#34; ; 0 .local \u0026#34;b\u0026#34; ; 1 .local \u0026#34;c\u0026#34; ; 2 .const 1 ; 0 .const 2 ; 1 [1] test 1 0 ; to [3] if true [2] jmp 2 ; to [5] [3] loadk 0 0 ; 1 [4] jmp 3 ; to [8] [5] test 2 0 ; to [7] if true [6] jmp 1 ; to [8] [7] loadk 0 1 ; 2 [8] return 0 1 ; end of function   1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162  static void ifstat (LexState *ls, int line) { /* ifstat -\u0026gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */ FuncState *fs = ls-\u0026gt;fs; int flist; int escapelist = NO_JUMP; flist = test_then_block(ls); /* IF cond THEN block */ while (ls-\u0026gt;t.token == TK_ELSEIF) { luaK_concat(fs, \u0026amp;escapelist, luaK_jump(fs)); luaK_patchtohere(fs, flist); flist = test_then_block(ls); /* ELSEIF cond THEN block */ } if (ls-\u0026gt;t.token == TK_ELSE) { luaK_concat(fs, \u0026amp;escapelist, luaK_jump(fs)); luaK_patchtohere(fs, flist); luaX_next(ls); /* skip ELSE (after patch, for correct line info) */ block(ls); /* `else\u0026#39; part */ } else luaK_concat(fs, \u0026amp;escapelist, flist); luaK_patchtohere(fs, escapelist); check_match(ls, TK_END, TK_IF, line); }   Code Snippet 41: lparser.c  elseif 结构是不限数量的，相比之下，if 和 else 只能有一个， 所以这里用 while 循环来重复检测所有 elseif 块。\n对于一个 elseif 块，先生成 jmp 指令，再重新调用 test_then_block ，当做一个 if 块来处理。\n示例代码中只有一个 elseif 块，所以在执行到 line 1151 时，生成字节码如下，\n  在生成最终的 return 之前，在 line 1159 将 flist 链接到 escapelist 上，因为它们有同样的终点。\n185 186 187 188 189 190 191 192 193 194 195 196  void luaK_concat (FuncState *fs, int *l1, int l2) { if (l2 == NO_JUMP) return; else if (*l1 == NO_JUMP) *l1 = l2; else { int list = *l1; int next; while ((next = getjump(fs, list)) != NO_JUMP) /* find last element */ list = next; fixjump(fs, list, l2); } }   Code Snippet 42: lcode.c  其中将 4 jmp 指令，跳转到 6 jmp，相当于将 jmp 链接起来，以 escapelist 为索引链的开始。\n  最终在 discharge 的时候，只需要顺着 escapelist 往下，就可以访问到所有需要重定位的 jmp 指令， 并进行相应参数的修改。\nif elseif else #  嵌套的过程，读者可使用上述方法，自主探索，在此不再赘述。\nwhile #  分支之后，来探索经典的 while 循环结构。\nwhilestat ::= WHILE cond DO block END 分析如下简单的示例，\nlocal a, b while b do a = 1 end ; function [0] definition (level 1) ; 0 upvalues, 0 params, 2 is_vararg, 2 stacks .function 0 0 2 2 .local \u0026#34;a\u0026#34; ; 0 .local \u0026#34;b\u0026#34; ; 1 .const 1 ; 0 [1] test 1 0 ; to [3] if true [2] jmp 2 ; to [5] [3] loadk 0 0 ; 1 [4] jmp -4 ; to [1] [5] return 0 1 ; end of function   可以看出，while 结构生成字节码也是模式化的，cond 生成 test 和 jmp 指令， 其后是循环体，最后的 jmp 指令用于跳转到循环开始，只有 test 为 false 的时候才会跳出循环体。\n991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007  static void whilestat (LexState *ls, int line) { /* whilestat -\u0026gt; WHILE cond DO block END */ FuncState *fs = ls-\u0026gt;fs; int whileinit; int condexit; BlockCnt bl; luaX_next(ls); /* skip WHILE */ whileinit = luaK_getlabel(fs); condexit = cond(ls); enterblock(fs, \u0026amp;bl, 1); checknext(ls, TK_DO); block(ls); luaK_patchlist(fs, luaK_jump(fs), whileinit); check_match(ls, TK_END, TK_WHILE, line); leaveblock(fs); luaK_patchtohere(fs, condexit); /* false conditions finish the loop */ }   Code Snippet 43: lparser.c  生成的过程并不难理解，根据对 concat 和 patch 的理解，\n  break #  因为 break 语句只能用于循环中，所以放在这里和 while 一起讲解。\nbreakstat ::= BREAK 分析如下示例，\nlocal a, b while b do a = 1 break end ; function [0] definition (level 1) ; 0 upvalues, 0 params, 2 is_vararg, 2 stacks .function 0 0 2 2 .local \u0026#34;a\u0026#34; ; 0 .local \u0026#34;b\u0026#34; ; 1 .const 1 ; 0 [1] test 1 0 ; to [3] if true [2] jmp 3 ; to [6] [3] loadk 0 0 ; 1 [4] jmp 1 ; to [6] [5] jmp -5 ; to [1] [6] return 0 1 ; end of function   可以看出，break 在循环体生成了 jmp 指令，跳转到循环外，这个过程由以下几点协同来实现。\n975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007  static void breakstat (LexState *ls) { FuncState *fs = ls-\u0026gt;fs; BlockCnt *bl = fs-\u0026gt;bl; int upval = 0; while (bl \u0026amp;\u0026amp; !bl-\u0026gt;isbreakable) { upval |= bl-\u0026gt;upval; bl = bl-\u0026gt;previous; } if (!bl) luaX_syntaxerror(ls, \u0026#34;no loop to break\u0026#34;); if (upval) luaK_codeABC(fs, OP_CLOSE, bl-\u0026gt;nactvar, 0, 0); luaK_concat(fs, \u0026amp;bl-\u0026gt;breaklist, luaK_jump(fs)); } static void whilestat (LexState *ls, int line) { /* whilestat -\u0026gt; WHILE cond DO block END */ FuncState *fs = ls-\u0026gt;fs; int whileinit; int condexit; BlockCnt bl; luaX_next(ls); /* skip WHILE */ whileinit = luaK_getlabel(fs); condexit = cond(ls); enterblock(fs, \u0026amp;bl, 1); checknext(ls, TK_DO); block(ls); luaK_patchlist(fs, luaK_jump(fs), whileinit); check_match(ls, TK_END, TK_WHILE, line); leaveblock(fs); luaK_patchtohere(fs, condexit); /* false conditions finish the loop */ }   Code Snippet 44: lparser.c  line 1000，调用 enterblock 新建了 breakable = 1 的 BlockCnt，\nline 979，break 语句不断向上层的 BlockCnt 检测是否存在 breakable 的 BlockCnt， 不然就提示语法错误，no loop to break。（直到代码生成时，才检测出这个语法错误）\n找到相应的 BlockCnt 之后，line 987 将 break 生成的 jmp 指令链接到 bl-\u0026gt;breaklist 上，\n296 297 298 299 300 301 302 303 304 305 306 307  static void leaveblock (FuncState *fs) { BlockCnt *bl = fs-\u0026gt;bl; fs-\u0026gt;bl = bl-\u0026gt;previous; removevars(fs-\u0026gt;ls, bl-\u0026gt;nactvar); if (bl-\u0026gt;upval) luaK_codeABC(fs, OP_CLOSE, bl-\u0026gt;nactvar, 0, 0); /* a block either controls scope or breaks (never both) */ lua_assert(!bl-\u0026gt;isbreakable || !bl-\u0026gt;upval); lua_assert(bl-\u0026gt;nactvar == fs-\u0026gt;nactvar); fs-\u0026gt;freereg = fs-\u0026gt;nactvar; /* free registers */ luaK_patchtohere(fs, bl-\u0026gt;breaklist); }   Code Snippet 45: lparser.c  最终在 line 1005 leaveblock 的时候，line 306 将 bl-\u0026gt;breaklist 上的 jmp 重定位。\nfor #  repeat 循环和 while 循环非常相似，主要是通过 jmp 来实现的。 而 for 循环很特殊，用专门的指令来实现。\nforstat ::= FOR (fornum | forlist) END fornum ::= NAME = expr `,\u0026#39; expr [`,\u0026#39; expr] forbody forlist ::= NAME {`,\u0026#39; NAME} IN explist forbody forbody ::= DO block for 语句分为两种，一种只用于数字迭代的 fornum，\nfor i = 1, 10, 2 do end 另一种通用迭代 forlist，\nfor k, v in pairs(t) do end 两种用法在底层使用不同的指令来实现。\nfornum #  fornum ::= NAME = expr `,\u0026#39; expr [`,\u0026#39; expr] forbody forbody ::= DO block = 后的 3 个表达式对应循环变量的初始值，目标值和间隔值，间隔值默认为 1。\n分析如下代码，\nlocal a = 0 for i = 1, 10, 2 do a = a + 1 end ; function [0] definition (level 1) ; 0 upvalues, 0 params, 2 is_vararg, 5 stacks .function 0 0 2 5 .local \u0026#34;a\u0026#34; ; 0 .local \u0026#34;(for index)\u0026#34; ; 1 .local \u0026#34;(for limit)\u0026#34; ; 2 .local \u0026#34;(for step)\u0026#34; ; 3 .local \u0026#34;i\u0026#34; ; 4 .const 0 ; 0 .const 1 ; 1 .const 10 ; 2 .const 2 ; 3 [1] loadk 0 0 ; 0 [2] loadk 1 1 ; 1 [3] loadk 2 2 ; 10 [4] loadk 3 3 ; 2 [5] forprep 1 1 ; to [7] [6] add 0 0 257 ; 1 [7] forloop 1 -2 ; to [6] if loop [8] return 0 1 ; end of function   其中的生成模式也明确，先生成 forprep 做准备工作，跳转到 forloop， 之后分析 forbody，最终生成 fooloop，用于跳转到循环开始/结束循环。\n根据 opcode 描述的语义，\nOP_FORPREP,/*\tA sBx\tR(A)-=R(A+2); pc+=sBx\t*/ OP_FORLOOP,/*\tA sBx\tR(A)+=R(A+2); if R(A) \u0026lt;?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }*/ forprep 先将循环变量减去间隔值，再跳转到 forloop。\n而 forloop 将循环值加上间隔值，再和结束值对比，判断是否要跳出循环， 如果继续循环，则将循环值赋给循环变量；否则跳出循环。\n1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086  static void forbody (LexState *ls, int base, int line, int nvars, int isnum) { /* forbody -\u0026gt; DO block */ BlockCnt bl; FuncState *fs = ls-\u0026gt;fs; int prep, endfor; adjustlocalvars(ls, 3); /* control variables */ checknext(ls, TK_DO); prep = isnum ? luaK_codeAsBx(fs, OP_FORPREP, base, NO_JUMP) : luaK_jump(fs); enterblock(fs, \u0026amp;bl, 0); /* scope for declared variables */ adjustlocalvars(ls, nvars); luaK_reserveregs(fs, nvars); block(ls); leaveblock(fs); /* end of scope for declared variables */ luaK_patchtohere(fs, prep); endfor = (isnum) ? luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP) : luaK_codeABC(fs, OP_TFORLOOP, base, 0, nvars); luaK_fixline(fs, line); /* pretend that `OP_FOR\u0026#39; starts the loop */ luaK_patchlist(fs, (isnum ? endfor : luaK_jump(fs)), prep + 1); } static void fornum (LexState *ls, TString *varname, int line) { /* fornum -\u0026gt; NAME = exp1,exp1[,exp1] forbody */ FuncState *fs = ls-\u0026gt;fs; int base = fs-\u0026gt;freereg; new_localvarliteral(ls, \u0026#34;(for index)\u0026#34;, 0); new_localvarliteral(ls, \u0026#34;(for limit)\u0026#34;, 1); new_localvarliteral(ls, \u0026#34;(for step)\u0026#34;, 2); new_localvar(ls, varname, 3); checknext(ls, \u0026#39;=\u0026#39;); exp1(ls); /* initial value */ checknext(ls, \u0026#39;,\u0026#39;); exp1(ls); /* limit */ if (testnext(ls, \u0026#39;,\u0026#39;)) exp1(ls); /* optional step */ else { /* default step = 1 */ luaK_codeABx(fs, OP_LOADK, fs-\u0026gt;freereg, luaK_numberK(fs, 1)); luaK_reserveregs(fs, 1); } forbody(ls, base, line, 1, 1); }   Code Snippet 46: lparser.c  生成的过程并不难理解，值得关注的是变量部分。\n在 local 表中隐式生成了 3 个变量，\n.local \u0026#34;(for index)\u0026#34; ; 1 .local \u0026#34;(for limit)\u0026#34; ; 2 .local \u0026#34;(for step)\u0026#34; ; 3 分别对应初始值，结束值和间隔值，变量都加了 ()，所以不会和 lua 代码中分析得到的变量名冲突。\n在 fornum 语句整体分析的过程中，生成了 3 层 BlockCnt，\n  最外层 block 是在 forstat 中生成的， breakable = 1 ，用于 break；\n中间层 block 将隐式生成的变量 (for index) 之类和循环变量 i 分开；\n最内层 block 用于 forbody block。\nforlist #  forlist ::= NAME {`,\u0026#39; NAME} IN explist forbody forbody ::= DO block forlist 用于迭代器循环，最常见的就是用 pairs 循环遍历 table。\n分析如下示例，\nlocal a = 0 for k, v in pairs({}) do a = a + 1 end ; function [0] definition (level 1) ; 0 upvalues, 0 params, 2 is_vararg, 7 stacks .function 0 0 2 7 .local \u0026#34;a\u0026#34; ; 0 .local \u0026#34;(for generator)\u0026#34; ; 1 .local \u0026#34;(for state)\u0026#34; ; 2 .local \u0026#34;(for control)\u0026#34; ; 3 .local \u0026#34;k\u0026#34; ; 4 .local \u0026#34;v\u0026#34; ; 5 .const 0 ; 0 .const \u0026#34;pairs\u0026#34; ; 1 .const 1 ; 2 [1] loadk 0 0 ; 0 [2] getglobal 1 1 ; pairs [3] newtable 2 0 0 ; array=0, hash=0 [4] call 1 2 4 [5] jmp 1 ; to [7] [6] add 0 0 258 ; 1 [7] tforloop 1 2 ; to [9] if exit [8] jmp -3 ; to [6] [9] return 0 1 ; end of function   forlist 的生成模式有些不同，先生成 jmp 跳转到 tforloop 指令， 而 tforloop 根据 opcode 的语义，\nOP_TFORLOOP,/*\tA C\tR(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2)); if R(A+3) ~= nil then R(A+2)=R(A+3) else pc++\t*/ 判断为 true 时，正常执行下一条指令；为 false 时，执行 pc++，跳过下一条指令。 而下一条指令固定是 jmp，用于定位到 forbody 的开始。\n1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109  static void forlist (LexState *ls, TString *indexname) { /* forlist -\u0026gt; NAME {,NAME} IN explist1 forbody */ FuncState *fs = ls-\u0026gt;fs; expdesc e; int nvars = 0; int line; int base = fs-\u0026gt;freereg; /* create control variables */ new_localvarliteral(ls, \u0026#34;(for generator)\u0026#34;, nvars++); new_localvarliteral(ls, \u0026#34;(for state)\u0026#34;, nvars++); new_localvarliteral(ls, \u0026#34;(for control)\u0026#34;, nvars++); /* create declared variables */ new_localvar(ls, indexname, nvars++); while (testnext(ls, \u0026#39;,\u0026#39;)) new_localvar(ls, str_checkname(ls), nvars++); checknext(ls, TK_IN); line = ls-\u0026gt;linenumber; adjust_assign(ls, 3, explist1(ls, \u0026amp;e), \u0026amp;e); luaK_checkstack(fs, 3); /* extra space to call generator */ forbody(ls, base, line, nvars - 3, 0); }   Code Snippet 47: lparser.c  1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064  static void forbody (LexState *ls, int base, int line, int nvars, int isnum) { /* forbody -\u0026gt; DO block */ BlockCnt bl; FuncState *fs = ls-\u0026gt;fs; int prep, endfor; adjustlocalvars(ls, 3); /* control variables */ checknext(ls, TK_DO); prep = isnum ? luaK_codeAsBx(fs, OP_FORPREP, base, NO_JUMP) : luaK_jump(fs); enterblock(fs, \u0026amp;bl, 0); /* scope for declared variables */ adjustlocalvars(ls, nvars); luaK_reserveregs(fs, nvars); block(ls); leaveblock(fs); /* end of scope for declared variables */ luaK_patchtohere(fs, prep); endfor = (isnum) ? luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP) : luaK_codeABC(fs, OP_TFORLOOP, base, 0, nvars); luaK_fixline(fs, line); /* pretend that `OP_FOR\u0026#39; starts the loop */ luaK_patchlist(fs, (isnum ? endfor : luaK_jump(fs)), prep + 1); }   Code Snippet 48: lparser.c  其中同样隐式声明了 3 个变量，用于控制循环状态，\n.local \u0026#34;(for generator)\u0026#34; ; 1 .local \u0026#34;(for state)\u0026#34; ; 2 .local \u0026#34;(for control)\u0026#34; ; 3 ret #  return 语句是非常直观的，\nretstat ::= RETURN [explist] 用于从当前 closure 中返回，\nOP_RETURN,/*\tA B\treturn R(A), ... ,R(A+B-2)\t(see note)\t*/ 示例代码，\nlocal a, b return a, b ; function [0] definition (level 1) ; 0 upvalues, 0 params, 2 is_vararg, 4 stacks .function 0 0 2 4 .local \u0026#34;a\u0026#34; ; 0 .local \u0026#34;b\u0026#34; ; 1 [1] move 2 0 [2] move 3 1 [3] return 2 3 [4] return 0 1 ; end of function 对应 retstat 过程，\n1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268  static void retstat (LexState *ls) { /* stat -\u0026gt; RETURN explist */ FuncState *fs = ls-\u0026gt;fs; expdesc e; int first, nret; /* registers with returned values */ luaX_next(ls); /* skip RETURN */ if (block_follow(ls-\u0026gt;t.token) || ls-\u0026gt;t.token == \u0026#39;;\u0026#39;) first = nret = 0; /* return no values */ else { nret = explist1(ls, \u0026amp;e); /* optional return values */ if (hasmultret(e.k)) { luaK_setmultret(fs, \u0026amp;e); if (e.k == VCALL \u0026amp;\u0026amp; nret == 1) { /* tail call? */ SET_OPCODE(getcode(fs,\u0026amp;e), OP_TAILCALL); lua_assert(GETARG_A(getcode(fs,\u0026amp;e)) == fs-\u0026gt;nactvar); } first = fs-\u0026gt;nactvar; nret = LUA_MULTRET; /* return all values */ } else { if (nret == 1) /* only one single value? */ first = luaK_exp2anyreg(fs, \u0026amp;e); else { luaK_exp2nextreg(fs, \u0026amp;e); /* values must go to the `stack\u0026#39; */ first = fs-\u0026gt;nactvar; /* return all `active\u0026#39; values */ lua_assert(nret == fs-\u0026gt;freereg - first); } } } luaK_ret(fs, first, nret); }   Code Snippet 49: lparser.c  在 line 1267 生成 return 指令。\nfunction call #  funccallstat ::= prefixexp primaryexp (`:\u0026#39; NAME funcargs | funcargs) funcargs ::= `(\u0026#39; [ explist ] `)\u0026#39; | constructor | STRING 函数调用和函数定义不同。\n假如函数定义接收 2 个参数，返回 1 个值， 而在函数调用时，可传递 3 个参数，不使用返回值。\n至于多/少的参数/返回值怎么处理，取决于 vm，在 lua 中，如果多了则废弃，少了则补 nil。\n比如如下示例，\nlocal function f() return 1 end f(1, 2, 3) ; function [0] definition (level 1) ; 0 upvalues, 0 params, 2 is_vararg, 5 stacks .function 0 0 2 5 .local \u0026#34;f\u0026#34; ; 0 .const 1 ; 0 .const 2 ; 1 .const 3 ; 2 ; function [0] definition (level 2) ; 0 upvalues, 0 params, 0 is_vararg, 2 stacks .function 0 0 0 2 .const 1 ; 0 [1] loadk 0 0 ; 1 [2] return 0 2 [3] return 0 1 ; end of function [1] closure 0 0 ; 0 upvalues [2] move 1 0 [3] loadk 2 0 ; 1 [4] loadk 3 1 ; 2 [5] loadk 4 2 ; 3 [6] call 1 4 1 [7] return 0 1 ; end of function 哪怕函数定义不接收参数，返回 1 个值，在调用时，只根据调用语句的意愿， 传入 3 个参数，不要返回值。\n  根据 opcode 的语义，\nOP_CALL,/*\tA B C\tR(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */ 在调用前，先将函数压栈，其次紧随着传入的参数值； 调用后，将所有返回值，从调用函数处，向上覆盖。\n示例因为不需要返回值，所以调用后，原来的函数加参数位置置为空。\ncall 指令生成过程参考 funcargs，\n609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655  static void funcargs (LexState *ls, expdesc *f) { FuncState *fs = ls-\u0026gt;fs; expdesc args; int base, nparams; int line = ls-\u0026gt;linenumber; switch (ls-\u0026gt;t.token) { case \u0026#39;(\u0026#39;: { /* funcargs -\u0026gt; `(\u0026#39; [ explist1 ] `)\u0026#39; */ if (line != ls-\u0026gt;lastline) luaX_syntaxerror(ls,\u0026#34;ambiguous syntax (function call x new statement)\u0026#34;); luaX_next(ls); if (ls-\u0026gt;t.token == \u0026#39;)\u0026#39;) /* arg list is empty? */ args.k = VVOID; else { explist1(ls, \u0026amp;args); luaK_setmultret(fs, \u0026amp;args); } check_match(ls, \u0026#39;)\u0026#39;, \u0026#39;(\u0026#39;, line); break; } case \u0026#39;{\u0026#39;: { /* funcargs -\u0026gt; constructor */ constructor(ls, \u0026amp;args); break; } case TK_STRING: { /* funcargs -\u0026gt; STRING */ codestring(ls, \u0026amp;args, ls-\u0026gt;t.seminfo.ts); luaX_next(ls); /* must use `seminfo\u0026#39; before `next\u0026#39; */ break; } default: { luaX_syntaxerror(ls, \u0026#34;function arguments expected\u0026#34;); return; } } lua_assert(f-\u0026gt;k == VNONRELOC); base = f-\u0026gt;u.s.info; /* base register for call */ if (hasmultret(args.k)) nparams = LUA_MULTRET; /* open call */ else { if (args.k != VVOID) luaK_exp2nextreg(fs, \u0026amp;args); /* close last argument */ nparams = fs-\u0026gt;freereg - (base+1); } init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2)); luaK_fixline(fs, line); fs-\u0026gt;freereg = base+1; /* call remove function and arguments and leaves (unless changed) one result */ }   Code Snippet 50: lparser.c  计算参数的个数，line 651 生成 call 指令，返回值暂时用 1，根据上下文再进行后续的修正。\nself #  使用 : 的函数定义和调用方式，更多是出于一种便利， 作用就是将调用对象本身，默认当作第 1 个参数。\n如下两种定义方式就是同义的，\nlocal o = {} function o.f(self) print(self) end function o:g() print(self) end o.f(o) o:g() table: 0x557b5c2091c0 table: 0x557b5c2091c0 分析示例，\nlocal o = {} function o:f() end o:f() ; function [0] definition (level 1) ; 0 upvalues, 0 params, 2 is_vararg, 3 stacks .function 0 0 2 3 .local \u0026#34;o\u0026#34; ; 0 .const \u0026#34;f\u0026#34; ; 0 ; function [0] definition (level 2) ; 0 upvalues, 1 params, 0 is_vararg, 2 stacks .function 0 1 0 2 .local \u0026#34;self\u0026#34; ; 0 [1] return 0 1 ; end of function [1] newtable 0 0 0 ; array=0, hash=0 [2] closure 1 0 ; 0 upvalues [3] settable 0 256 1 ; \u0026#34;f\u0026#34; [4] self 1 0 256 ; \u0026#34;f\u0026#34; [5] call 1 2 1 [6] return 0 1 ; end of function self 指令生成在 call 指令之前，结合 self 指令的语义，\nOP_SELF,/*\tA B C\tR(A+1) := R(B); R(A) := R(B)[RK(C)]\t*/ 结合示例字节码，self 相当于在栈中布置了 o 和 f，方便 call 进行调用，\n  内部在 primaryexp 中调用 luaK_self 生成 self 指令，\n690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724  static void primaryexp (LexState *ls, expdesc *v) { /* primaryexp -\u0026gt; prefixexp { `.\u0026#39; NAME | `[\u0026#39; exp `]\u0026#39; | `:\u0026#39; NAME funcargs | funcargs } */ FuncState *fs = ls-\u0026gt;fs; prefixexp(ls, v); for (;;) { switch (ls-\u0026gt;t.token) { case \u0026#39;.\u0026#39;: { /* field */ field(ls, v); break; } case \u0026#39;[\u0026#39;: { /* `[\u0026#39; exp1 `]\u0026#39; */ expdesc key; luaK_exp2anyreg(fs, v); yindex(ls, \u0026amp;key); luaK_indexed(fs, v, \u0026amp;key); break; } case \u0026#39;:\u0026#39;: { /* `:\u0026#39; NAME funcargs */ expdesc key; luaX_next(ls); checkname(ls, \u0026amp;key); luaK_self(fs, v, \u0026amp;key); funcargs(ls, v); break; } case \u0026#39;(\u0026#39;: case TK_STRING: case \u0026#39;{\u0026#39;: { /* funcargs */ luaK_exp2nextreg(fs, v); funcargs(ls, v); break; } default: return; } } }   Code Snippet 51: lparser.c  503 504 505 506 507 508 509 510 511 512 513  void luaK_self (FuncState *fs, expdesc *e, expdesc *key) { int func; luaK_exp2anyreg(fs, e); freeexp(fs, e); func = fs-\u0026gt;freereg; luaK_reserveregs(fs, 2); luaK_codeABC(fs, OP_SELF, func, e-\u0026gt;u.s.info, luaK_exp2RK(fs, key)); freeexp(fs, key); e-\u0026gt;u.s.info = func; e-\u0026gt;k = VNONRELOC; }   Code Snippet 52: lcode.c  tailcall #  结合 return，存在种特殊形式的函数调用 tailcall。\n-- tail call return f() -- not tail call return a, b, f() 在 return 语句后，仅跟随单独的函数调用，这种形式称为尾调用， 在 vm 中可以进行栈优化，到 vm 章节再详细解释。\npractice #  这个章节的内容虽然很长，但还远远没有将所有功能描述完全。\n其它值得研究的功能包括\n binop，二元运算  arithmetic，算术运算，如何优先级 logic，逻辑运算，and or 短路逻辑   table 字面量 repeat 语句 close，修改 upvalue 状态 etc  希望读者可以自行结合代码示例探索。\n   文件 建议     lparser.h 仔细阅读   lparser.c 仔细阅读   lcode.h 仔细阅读   lcode.c 仔细阅读    "});index.add({'id':9,'href':'/lua-5.1-source-guide/docs/parser/','title':"parser",'section':"Docs",'content':"在 lexer 章节提到，lua 为了效率，将语法分析到代码生成的所有功能封装在 parser 模块中。 在过程中，没有 AST IR 等中间产物，直接从 token 到 opcode，一步到位。 相对的，这部分代码就相对难以理解。\n虽然在代码实现没有明显的步骤划分，但是对于读者， 在理解代码过程中，还是先找出不同步骤的影子，最后再串联在一起。\n这个章节，就是尝试从代码中“分离”出语法分析的部分，先对模块做初步的理解。\n  grammar #  模块以语法分析作为入口，整体是一个语法制导翻译的过程。\n官方文档1使用上下文无关文法来描述 lua 语法，但是省略了一些细节。 笔者结合 parser 代码中的实现过程和相关注释，重新整理语法描述如下，使用 EBNF 描述。\nchunk ::= { stat [ `;\u0026#39; ] } stat ::= ifstat | whilestat | dostat | forstat | repeatstat | funcstat | localstat | retstat | breakstat | exprstat ifstat ::= IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END cond ::= expr block ::= chunk whilestat ::= WHILE cond DO block END dostat ::= DO block END forstat ::= FOR (fornum | forlist) END fornum ::= NAME = expr `,\u0026#39; expr [`,\u0026#39; expr] forbody forlist ::= NAME {`,\u0026#39; NAME} IN explist forbody forbody ::= DO block repeatstat ::= REPEAT block UNTIL cond funcstat ::= FUNCTION funcname body funcname ::= NAME {`.\u0026#39; NAME} [`:\u0026#39; NAME] body ::= `(\u0026#39; parlist `)\u0026#39; chunk END parlist ::= [ DOTS | NAME {`,\u0026#39; NAME} [`,\u0026#39; DOTS] ] localstat ::= LOCAL FUNCTION NAME body | LOCAL NAME {`,\u0026#39; NAME} [`=\u0026#39; explist] retstat ::= RETURN [explist] breakstat ::= BREAK exprstat ::= assignstat | funccallstat assignstat ::= (prefixexp | primaryexp (`.\u0026#39; NAME | `[\u0026#39; expr `]\u0026#39;)) assignment assignment ::= `,\u0026#39; assignstat | `=\u0026#39; explist primaryexp ::= prefixexp {`.\u0026#39; NAME | `[\u0026#39; expr `]\u0026#39; | `:\u0026#39; NAME funcargs | funcargs} prefixexp ::= NAME | `(\u0026#39; expr `)\u0026#39; funccallstat ::= prefixexp primaryexp (`:\u0026#39; NAME funcargs | funcargs) funcargs ::= `(\u0026#39; [ explist ] `)\u0026#39; | constructor | STRING explist ::= expr {`,\u0026#39; expr} expr ::= subexpr subexpr ::= (simpleexp | unop subexpr) {binop subexpr} simpleexp ::= NUMBER | STRING | NIL | TRUE | FALSE | DOTS | constructor | FUNCTION body | primaryexp binop ::= `+´ | `-´ | `*´ | `/´ | `^´ | `%´ | CONCAT | `\u0026lt;´ | LE | `\u0026gt;´ | GE | EQ | NE | AND | OR unop ::= `-´ | NOT | `#´ constructor ::= `{\u0026#39; [fieldlist] `}\u0026#39; fieldlist ::= field {fieldsep field} [fieldsep] field ::= `[\u0026#39; expr `]\u0026#39; `=\u0026#39; expr | NAME `=\u0026#39; expr | expr fieldsep ::= `,\u0026#39; | `;\u0026#39;  { a } 表示 0 个或多个 a [ a ] 表示 0 个或一个 a ( a ) 表示组 | 表示或 大写单词，`单字符' 表示终结符，和 lex 阶段生成的 token 一一对应 小写单词 表示非终结符，整体以 chunk 为入口  之前提到，在 lex 过程，lua 并没有完全使用 regex 对词法做完整的限制，存在些许不完美的实现。 同样的“问题”在语法分析的 EBNF 描述中也存在。\nbinop #  在语法描述上，没有控制二元运算的优先级，而是将优先级在 subexpr 过程中用代码隐式实现。\nbreak #  break 语句位置并不是随意的，只能放置在 loop 块中，而语法描述并没有描述这种限制， 同样的，lua 将此限制实现在代码层面。\nreturn #  return 语句只能放置在块的最后一行，而语法描述没有表示出此种限制。\nrecursive descent #  parser 模块使用 LL(1) 递归下降法进行语法分析。\n递归下降法有一个明显的优点，通常在实现中， 每个非终结符都对应一个同名函数来实现，如 chunk() statement() 等。\n1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337  static int statement (LexState *ls) { int line = ls-\u0026gt;linenumber; /* may be needed for error messages */ switch (ls-\u0026gt;t.token) { case TK_IF: { /* stat -\u0026gt; ifstat */ ifstat(ls, line); return 0; } case TK_WHILE: { /* stat -\u0026gt; whilestat */ whilestat(ls, line); return 0; } case TK_DO: { /* stat -\u0026gt; DO block END */ luaX_next(ls); /* skip DO */ block(ls); check_match(ls, TK_END, TK_DO, line); return 0; } case TK_FOR: { /* stat -\u0026gt; forstat */ forstat(ls, line); return 0; } case TK_REPEAT: { /* stat -\u0026gt; repeatstat */ repeatstat(ls, line); return 0; } case TK_FUNCTION: { funcstat(ls, line); /* stat -\u0026gt; funcstat */ return 0; } case TK_LOCAL: { /* stat -\u0026gt; localstat */ luaX_next(ls); /* skip LOCAL */ if (testnext(ls, TK_FUNCTION)) /* local function? */ localfunc(ls); else localstat(ls); return 0; } case TK_RETURN: { /* stat -\u0026gt; retstat */ retstat(ls); return 1; /* must be last statement */ } case TK_BREAK: { /* stat -\u0026gt; breakstat */ luaX_next(ls); /* skip BREAK */ breakstat(ls); return 1; /* must be last statement */ } default: { exprstat(ls); return 0; /* to avoid warnings */ } } } static void chunk (LexState *ls) { /* chunk -\u0026gt; { stat [`;\u0026#39;] } */ int islast = 0; enterlevel(ls); while (!islast \u0026amp;\u0026amp; !block_follow(ls-\u0026gt;t.token)) { islast = statement(ls); testnext(ls, \u0026#39;;\u0026#39;); lua_assert(ls-\u0026gt;fs-\u0026gt;f-\u0026gt;maxstacksize \u0026gt;= ls-\u0026gt;fs-\u0026gt;freereg \u0026amp;\u0026amp; ls-\u0026gt;fs-\u0026gt;freereg \u0026gt;= ls-\u0026gt;fs-\u0026gt;nactvar); ls-\u0026gt;fs-\u0026gt;freereg = ls-\u0026gt;fs-\u0026gt;nactvar; /* free registers */ } leavelevel(ls); }   Code Snippet 1: lparser.c  这些函数都有一个共性，全部都接收参数 LexState *ls ，从其得到 token。 部分函数接收参数 expdesc* v ，表示当前过程之后，得到的表达式结果。\nexpdesc 结构非常关键，在代码生成章节再详细描述。\n15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  /* ** Expression descriptor */ typedef enum { VVOID,\t/* no value */ VNIL, VTRUE, VFALSE, VK,\t/* info = index of constant in `k\u0026#39; */ VKNUM,\t/* nval = numerical value */ VLOCAL,\t/* info = local register */ VUPVAL, /* info = index of upvalue in `upvalues\u0026#39; */ VGLOBAL,\t/* info = index of table; aux = index of global name in `k\u0026#39; */ VINDEXED,\t/* info = table register; aux = index register (or `k\u0026#39;) */ VJMP,\t/* info = instruction pc */ VRELOCABLE,\t/* info = instruction pc */ VNONRELOC,\t/* info = result register */ VCALL,\t/* info = instruction pc */ VVARARG\t/* info = instruction pc */ } expkind; typedef struct expdesc { expkind k; union { struct { int info, aux; } s; lua_Number nval; } u; int t; /* patch list of `exit when true\u0026#39; */ int f; /* patch list of `exit when false\u0026#39; */ } expdesc;   Code Snippet 2: lparser.h  如此对照 EBNF 的语法描述，就可以方便地对语法分析的过程有大体的了解。\n所有函数之间的调用过程，就像是隐式的 AST 的遍历过程。 代码生成的实现过程就隐藏在这一个个函数中。\n  整体以 chunk 为入口，下分为多个 stat，每个 stat 有独立的结构，最终到基础的 expr 单元， 像一棵树形结构，自顶向下。\npractice #  luaY_parser 是 parser 模块的入口，\n383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398  Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff, const char *name) { struct LexState lexstate; struct FuncState funcstate; lexstate.buff = buff; luaX_setinput(L, \u0026amp;lexstate, z, luaS_new(L, name)); open_func(\u0026amp;lexstate, \u0026amp;funcstate); funcstate.f-\u0026gt;is_vararg = VARARG_ISVARARG; /* main func. is always vararg */ luaX_next(\u0026amp;lexstate); /* read first token */ chunk(\u0026amp;lexstate); check(\u0026amp;lexstate, TK_EOS); close_func(\u0026amp;lexstate); lua_assert(funcstate.prev == NULL); lua_assert(funcstate.f-\u0026gt;nups == 0); lua_assert(lexstate.fs == NULL); return funcstate.f; }   Code Snippet 3: lparser.c  Line 391 调用 chunk，开始递归向下的分析。\n读者可以使用调试器，在 chunk 处加上断点，运行 lua 代码， 使用 next/step 观察内部运行的走向，对照 EBNF 来理解语法分析的整体结构。\n$ make -s debug source=if.lua 建议最开始以 stat 为单位，对每个 stat 进行独立的观察，最终再整合为宏观的理解。\n  : http://www.lua.org/manual/5.1/manual.html#8 \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':10,'href':'/lua-5.1-source-guide/docs/opcode/','title':"opcode",'section':"Docs",'content':"按顺序，本章应该讲解 parser 相关的内容。\n之前提到，parser 模块将语法分析与代码生成揉合在一起，为了更容易理解 parser 的功能， 先对最终生成的代码 opcode 做一些了解，到时就可以带着目的去阅读。\nopcode 字节码，是编译阶段的最终结果。 类比来看，C 编译为机器码，由机器执行；lua 编译为 opcode 由 vm 执行。\n可以说，opcode 是上层 lua 代码与 vm 的中间层，是语义的约定。 本章关注 opcode 的表示方式及含义。\nformat #  所有 opcode 都是定长的，4 bytes 32 bits，单个指令用 unsigned int 表示。\n84 85 86 87 88  /* ** type for virtual-machine instructions ** must be an unsigned with (at least) 4 bytes (see details in lopcodes.h) */ typedef lu_int32 Instruction;   Code Snippet 1: llimits.h  指令内部可分为类型和参数两部分，根据参数的安排方式，所有指令可分为 3 类操作模式。\n31  enum OpMode {iABC, iABx, iAsBx}; /* basic instruction format */   Code Snippet 2: lopcodes.h   iABC，接受 A B C 三个参数 iABx，接受 A Bx 两个参数 iAsBx，接受 A sBx 两个参数  A B C Bx 是无符号数，而 sBx 是有符号数（s 即 signed）。\n  三种类型的指令在 32 bits 的空间中进行如下的划分\n Op 表示指令类型，占据 6 bits，在最低位 A C B 分别占据 8 9 9 bits，从低位到高位排列 Bx 占据 B C 两者的空间 sBx 和 Bx 占据的空间相同，不过解析为有符号数   34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  /* ** size and position of opcode arguments. */ #define SIZE_C\t9 #define SIZE_B\t9 #define SIZE_Bx\t(SIZE_C + SIZE_B) #define SIZE_A\t8  #define SIZE_OP\t6  #define POS_OP\t0 #define POS_A\t(POS_OP + SIZE_OP) #define POS_C\t(POS_A + SIZE_A) #define POS_B\t(POS_C + SIZE_C) #define POS_Bx\tPOS_C   Code Snippet 3: lopcodes.h  param #  A C B 的长度分别是 8 9 9 bits，都解析为无符号数。 Bx 占据 18 位，解析为无符号数。 sBx 和 Bx 占据同一空间，但是解析为有符号数。\n不同参数表示不同的范围。\n   param len(bits) range     A 8 0 -\u0026gt; 2^8 - 1   C 9 0 -\u0026gt; 2^9 - 1   B 9 0 -\u0026gt; 2^9 - 1   Bx 18 0 -\u0026gt; 2^18 - 1   sBx 18 -(2^17 - 1) -\u0026gt; 2^17 - 1    65 66 67  #define MAXARG_A ((1\u0026lt;\u0026lt;SIZE_A)-1) #define MAXARG_B ((1\u0026lt;\u0026lt;SIZE_B)-1) #define MAXARG_C ((1\u0026lt;\u0026lt;SIZE_C)-1)   Code Snippet 4: lopcodes.h  57 58  #define MAXARG_Bx ((1\u0026lt;\u0026lt;SIZE_Bx)-1) #define MAXARG_sBx (MAXARG_Bx\u0026gt;\u0026gt;1) /* `sBx\u0026#39; is signed */   lua 并不用反码补码的逻辑来理解 sBx，而只是将同样字节表示的 Bx 减去 offset 得到 sBx。\n  offset 就是 sBx 的最大值，所以 1111 1..1 1111 对于 sBx 是没有意义的。\nkind #  指令类型共有 38 种，用 enum OpCode 标识，\n146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211  /* ** grep \u0026#34;ORDER OP\u0026#34; if you change these enums */ typedef enum { /*---------------------------------------------------------------------- name\targs\tdescription ------------------------------------------------------------------------*/ OP_MOVE,/*\tA B\tR(A) := R(B)\t*/ OP_LOADK,/*\tA Bx\tR(A) := Kst(Bx)\t*/ OP_LOADBOOL,/*\tA B C\tR(A) := (Bool)B; if (C) pc++\t*/ OP_LOADNIL,/*\tA B\tR(A) := ... := R(B) := nil\t*/ OP_GETUPVAL,/*\tA B\tR(A) := UpValue[B]\t*/ OP_GETGLOBAL,/*\tA Bx\tR(A) := Gbl[Kst(Bx)]\t*/ OP_GETTABLE,/*\tA B C\tR(A) := R(B)[RK(C)]\t*/ OP_SETGLOBAL,/*\tA Bx\tGbl[Kst(Bx)] := R(A)\t*/ OP_SETUPVAL,/*\tA B\tUpValue[B] := R(A)\t*/ OP_SETTABLE,/*\tA B C\tR(A)[RK(B)] := RK(C)\t*/ OP_NEWTABLE,/*\tA B C\tR(A) := {} (size = B,C)\t*/ OP_SELF,/*\tA B C\tR(A+1) := R(B); R(A) := R(B)[RK(C)]\t*/ OP_ADD,/*\tA B C\tR(A) := RK(B) + RK(C)\t*/ OP_SUB,/*\tA B C\tR(A) := RK(B) - RK(C)\t*/ OP_MUL,/*\tA B C\tR(A) := RK(B) * RK(C)\t*/ OP_DIV,/*\tA B C\tR(A) := RK(B) / RK(C)\t*/ OP_MOD,/*\tA B C\tR(A) := RK(B) % RK(C)\t*/ OP_POW,/*\tA B C\tR(A) := RK(B) ^ RK(C)\t*/ OP_UNM,/*\tA B\tR(A) := -R(B)\t*/ OP_NOT,/*\tA B\tR(A) := not R(B)\t*/ OP_LEN,/*\tA B\tR(A) := length of R(B)\t*/ OP_CONCAT,/*\tA B C\tR(A) := R(B).. ... ..R(C)\t*/ OP_JMP,/*\tsBx\tpc+=sBx\t*/ OP_EQ,/*\tA B C\tif ((RK(B) == RK(C)) ~= A) then pc++\t*/ OP_LT,/*\tA B C\tif ((RK(B) \u0026lt; RK(C)) ~= A) then pc++ */ OP_LE,/*\tA B C\tif ((RK(B) \u0026lt;= RK(C)) ~= A) then pc++ */ OP_TEST,/*\tA C\tif not (R(A) \u0026lt;=\u0026gt; C) then pc++\t*/ OP_TESTSET,/*\tA B C\tif (R(B) \u0026lt;=\u0026gt; C) then R(A) := R(B) else pc++\t*/ OP_CALL,/*\tA B C\tR(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */ OP_TAILCALL,/*\tA B C\treturn R(A)(R(A+1), ... ,R(A+B-1))\t*/ OP_RETURN,/*\tA B\treturn R(A), ... ,R(A+B-2)\t(see note)\t*/ OP_FORLOOP,/*\tA sBx\tR(A)+=R(A+2); if R(A) \u0026lt;?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }*/ OP_FORPREP,/*\tA sBx\tR(A)-=R(A+2); pc+=sBx\t*/ OP_TFORLOOP,/*\tA C\tR(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2)); if R(A+3) ~= nil then R(A+2)=R(A+3) else pc++\t*/ OP_SETLIST,/*\tA B C\tR(A)[(C-1)*FPF+i] := R(A+i), 1 \u0026lt;= i \u0026lt;= B\t*/ OP_CLOSE,/*\tA close all variables in the stack up to (\u0026gt;=) R(A)*/ OP_CLOSURE,/*\tA Bx\tR(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))\t*/ OP_VARARG/*\tA B\tR(A), R(A+1), ..., R(A+B-1) = vararg\t*/ } OpCode; #define NUM_OPCODES\t(cast(int, OP_VARARG) + 1)   Code Snippet 5: lopcodes.h  注释描述了相应类型的指令所接受的参数和功能。\nmodel #  想要了解指令具体的功能，就需要提前对 vm 的执行模型有一些了解。\n  vm 为编程语言提供了更大的灵活性，原因就在于这个虚拟的机器内部可以自由构造，而不用面对一成不变的 x86 架构。\n不管 vm 如何设计，目的都是执行 opcode，实现其描述的语义。 lua 实现的 vm 主要由图中的几个部分构成。\nCode \u0026amp; pc #  vm 在执行时，必须要有执行的蓝图，即输入的字节码。\nCode 就表示 vm 要执行的字节码，在内部以指令数组的形式来存储。\npc 的概念都不陌生，用于索引当前正在执行的指令。\nStack #  Stack 时刻记录着 vm 执行指令时的状态。\nlua 中的 vm 比较特殊，存在寄存器的概念，但是将寄存器的存储区域放在栈中（准确地说是栈底）。\nKst #  这是一个辅助结构，用于记录 lua 代码中出现的常量，在指令中通过 kst 中的索引来使用这些常量。\nGbl #  Gbl 是全局表，以 table 结构来实现，对应 lua 语言中“全局”的概念，比如全局变量，就存储在这里。\nUpValue #  记录闭包引用的上值，之后再详细解释。\nmeaning #  对应 vm 模型的粗略了解，下面来看指令后的功能描述表达了什么含义。\nR(A) 表示索引为 A 的寄存器，因为寄存器存储在栈中，所以 R(A) 直接索引栈中的空间。\n寄存器是可读写的，如果出现在赋值左边，表示寄存器的位置；出现在赋值右边，表示使用相应位置的值。\n  Kst(Bx) 表示索引为 Bx 的常量，从 kst 表中取值。\n常量表在执行时是只读的。\n  RK(B) 根据 B 的大小，用于索引寄存器/常量，只用于只读。\n  这里和之前参数空间的长度安排巧妙地联系在一起。\nA B C 三个参数，长度分别为 8 9 9 bits。 在 opcode 的整体设计中，没有 RK(A)，只有 RK(B) RK(C)。\n所以使用 B C 中比 A 多出的 1 个高位 bit，用于辨别 RK 表示的是 R 还是 K。\n   R/K bits range     R 0\u0026hellip;\u0026hellip;.. 0 -\u0026gt; 255   K 1\u0026hellip;\u0026hellip;.. 256 -\u0026gt; 511    这样，相应的宏也就不难理解。\n114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130  /* ** Macros to operate RK indices */ /* this bit 1 means constant (0 means register) */ #define BITRK\t(1 \u0026lt;\u0026lt; (SIZE_B - 1))  /* test whether value is a constant */ #define ISK(x)\t((x) \u0026amp; BITRK)  /* gets the index of the constant */ #define INDEXK(r)\t((int)(r) \u0026amp; ~BITRK)  #define MAXINDEXRK\t(BITRK - 1)  /* code a constant index as a RK value */ #define RKASK(x)\t((x) | BITRK)   Code Snippet 6: lopcodes.h  Gbl 是全局表，Stack 和 Kst 都以数组来实现，所以只需要整数索引，而 Gbl 是真正的表， 用 table 来实现，这意味着索引可以是除 nil 外的任意值。 所以在索引使用 Gbl 时，通常使用间接的方式。\n  UpValue 表和 Kst 类似，以数组表示，用整数索引，但是可读写。\n  有了上面符号的理解，读者应该能读懂大部分指令所表达的功能。\n本质上，vm 的运行过程就是不断的执行指令，操作不同区域的数据的过程。\n下面列几个简单示例。\nmove #  154  OP_MOVE,/*\tA B\tR(A) := R(B)\t*/   Code Snippet 7: lopcodes.h  move 很容易理解，直接进行寄存器间的赋值。\n  getglobal #  160  OP_GETGLOBAL,/*\tA Bx\tR(A) := Gbl[Kst(Bx)]\t*/   Code Snippet 8: lopcodes.h  Gbl 因为不使用整数索引，所以在引用其中元素时，需要 Kst 作间接的引用。\n  add #  171  OP_ADD,/*\tA B C\tR(A) := RK(B) + RK(C)\t*/   Code Snippet 9: lopcodes.h  add 是二元运算，其中使用 RK 来引用。\n  more #  ChunkSpy 的作者对于 opcode 有更深刻的理解，在其发布 ChunkSpy 程序的时候，也附带了描述 opcode 的文档1， 推荐读者详细阅读。\nmeta #  opcode 模块除了定义指令的类型和格式，同时也记录了指令的其它信息，用于辅助代码生成。\n59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101  #define opmode(t,a,b,c,m) (((t)\u0026lt;\u0026lt;7) | ((a)\u0026lt;\u0026lt;6) | ((b)\u0026lt;\u0026lt;4) | ((c)\u0026lt;\u0026lt;2) | (m))  const lu_byte luaP_opmodes[NUM_OPCODES] = { /* T A B C mode\topcode\t*/ opmode(0, 1, OpArgR, OpArgN, iABC) /* OP_MOVE */ ,opmode(0, 1, OpArgK, OpArgN, iABx)\t/* OP_LOADK */ ,opmode(0, 1, OpArgU, OpArgU, iABC)\t/* OP_LOADBOOL */ ,opmode(0, 1, OpArgR, OpArgN, iABC)\t/* OP_LOADNIL */ ,opmode(0, 1, OpArgU, OpArgN, iABC)\t/* OP_GETUPVAL */ ,opmode(0, 1, OpArgK, OpArgN, iABx)\t/* OP_GETGLOBAL */ ,opmode(0, 1, OpArgR, OpArgK, iABC)\t/* OP_GETTABLE */ ,opmode(0, 0, OpArgK, OpArgN, iABx)\t/* OP_SETGLOBAL */ ,opmode(0, 0, OpArgU, OpArgN, iABC)\t/* OP_SETUPVAL */ ,opmode(0, 0, OpArgK, OpArgK, iABC)\t/* OP_SETTABLE */ ,opmode(0, 1, OpArgU, OpArgU, iABC)\t/* OP_NEWTABLE */ ,opmode(0, 1, OpArgR, OpArgK, iABC)\t/* OP_SELF */ ,opmode(0, 1, OpArgK, OpArgK, iABC)\t/* OP_ADD */ ,opmode(0, 1, OpArgK, OpArgK, iABC)\t/* OP_SUB */ ,opmode(0, 1, OpArgK, OpArgK, iABC)\t/* OP_MUL */ ,opmode(0, 1, OpArgK, OpArgK, iABC)\t/* OP_DIV */ ,opmode(0, 1, OpArgK, OpArgK, iABC)\t/* OP_MOD */ ,opmode(0, 1, OpArgK, OpArgK, iABC)\t/* OP_POW */ ,opmode(0, 1, OpArgR, OpArgN, iABC)\t/* OP_UNM */ ,opmode(0, 1, OpArgR, OpArgN, iABC)\t/* OP_NOT */ ,opmode(0, 1, OpArgR, OpArgN, iABC)\t/* OP_LEN */ ,opmode(0, 1, OpArgR, OpArgR, iABC)\t/* OP_CONCAT */ ,opmode(0, 0, OpArgR, OpArgN, iAsBx)\t/* OP_JMP */ ,opmode(1, 0, OpArgK, OpArgK, iABC)\t/* OP_EQ */ ,opmode(1, 0, OpArgK, OpArgK, iABC)\t/* OP_LT */ ,opmode(1, 0, OpArgK, OpArgK, iABC)\t/* OP_LE */ ,opmode(1, 1, OpArgR, OpArgU, iABC)\t/* OP_TEST */ ,opmode(1, 1, OpArgR, OpArgU, iABC)\t/* OP_TESTSET */ ,opmode(0, 1, OpArgU, OpArgU, iABC)\t/* OP_CALL */ ,opmode(0, 1, OpArgU, OpArgU, iABC)\t/* OP_TAILCALL */ ,opmode(0, 0, OpArgU, OpArgN, iABC)\t/* OP_RETURN */ ,opmode(0, 1, OpArgR, OpArgN, iAsBx)\t/* OP_FORLOOP */ ,opmode(0, 1, OpArgR, OpArgN, iAsBx)\t/* OP_FORPREP */ ,opmode(1, 0, OpArgN, OpArgU, iABC)\t/* OP_TFORLOOP */ ,opmode(0, 0, OpArgU, OpArgU, iABC)\t/* OP_SETLIST */ ,opmode(0, 0, OpArgN, OpArgN, iABC)\t/* OP_CLOSE */ ,opmode(0, 1, OpArgU, OpArgN, iABx)\t/* OP_CLOSURE */ ,opmode(0, 1, OpArgU, OpArgN, iABC)\t/* OP_VARARG */ };   Code Snippet 10: lopcodes.c  这些信息用 1 byte 8 bits 来记录，其中\n T，表示指令是否有 test 操作 A，表示是否修改了 R(A) mode，表示指令属于 iABC/iABx/iAsBx 的哪一种 B C，表示 B C 参数的使用方式  OpArgN，未使用 OpArgU，使用 OpArgR，作为寄存器索引/跳转偏移量 OpArgK，作为常量索引/RK索引     /* ** masks for instruction properties. The format is: ** bits 0-1: op mode ** bits 2-3: C arg mode ** bits 4-5: B arg mode ** bit 6: instruction set register A ** bit 7: operator is a test */ enum OpArgMask { OpArgN, /* argument is not used */ OpArgU, /* argument is used */ OpArgR, /* argument is a register or a jump offset */ OpArgK /* argument is a constant or register/constant */ }; Code Snippet 11: lopcodes.h  相应地，相关的宏就不难理解。\n#define getOpMode(m)\t(cast(enum OpMode, luaP_opmodes[m] \u0026amp; 3)) #define getBMode(m)\t(cast(enum OpArgMask, (luaP_opmodes[m] \u0026gt;\u0026gt; 4) \u0026amp; 3)) #define getCMode(m)\t(cast(enum OpArgMask, (luaP_opmodes[m] \u0026gt;\u0026gt; 2) \u0026amp; 3)) #define testAMode(m)\t(luaP_opmodes[m] \u0026amp; (1 \u0026lt;\u0026lt; 6)) #define testTMode(m)\t(luaP_opmodes[m] \u0026amp; (1 \u0026lt;\u0026lt; 7)) Code Snippet 12: lopcodes.h  practice #     文件 建议     lopcodes.h 仔细阅读   lopcodes.c 仔细阅读      : \u0026lt;a no frills introduction to lua 5.1 vm instructions.pdf\u0026gt; \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':11,'href':'/lua-5.1-source-guide/docs/lexer/','title':"lexer",'section':"Docs",'content':"之前的章节，关注的是内部的一些实现，为后续打基础。\n后续的章节关注 lua 是如何从文本代码到最终实际运行起来的。\n本章关注 lua 中的词法分析部分，即 lexer，这通常是编译过程的第一步。\nlexer #  传统的编译过程大家都不陌生。\n  lua 是解释型语言，但同样存在从源码到字节码的编译过程，区别在于其运行在 VM 上。\n经过历史的演变，lua 的内部实现为了效率，遵从如下的过程。\n  AST 使用虚线表示，是因为内部没有显式的 AST 结构。\n综合来看，lexer 完成了从 code 到 token 的过程， parser 孤身一人完成了从 token 到 opcode 的过程。\n  单纯从从文件角度看，lua 代码只是文本文件，由字符组成。 文本形式的编程语言由机器理解并执行，需要经过一系列组件的处理过程。 不同组件有明确的分工，不同的组件有不同的输入和输出，组成上下游关系。\nlexer 通常是第一个组件，将源代码转换为 token，将字符流转化为 token 流，作为后续 parser 的输入。\n  Token #  简单的说，token 就是多个字符组成的有序序列。\nlua 内部用 struct 表示 token，\n43 44 45 46 47 48 49 50 51 52  typedef union { lua_Number r; TString *ts; } SemInfo; /* semantics information */ typedef struct Token { int token; SemInfo seminfo; } Token;   Code Snippet 1: llex.h  int token #  token 定义为 int，表示 Token 的类型，所有类型定义在 enum 结构中。\n14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #define FIRST_RESERVED\t257  /* maximum length of a reserved word */ #define TOKEN_LEN\t(sizeof(\u0026#34;function\u0026#34;)/sizeof(char))  /* * WARNING: if you change the order of this enumeration, * grep \u0026#34;ORDER RESERVED\u0026#34; */ enum RESERVED { /* terminal symbols denoted by reserved words */ TK_AND = FIRST_RESERVED, TK_BREAK, TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION, TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT, TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE, /* other terminal symbols */ TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER, TK_NAME, TK_STRING, TK_EOS };   Code Snippet 2: llex.h  每个 token 类型都有对应的文本表示，\n36 37 38 39 40 41 42 43 44 45  /* ORDER RESERVED */ const char *const luaX_tokens [] = { \u0026#34;and\u0026#34;, \u0026#34;break\u0026#34;, \u0026#34;do\u0026#34;, \u0026#34;else\u0026#34;, \u0026#34;elseif\u0026#34;, \u0026#34;end\u0026#34;, \u0026#34;false\u0026#34;, \u0026#34;for\u0026#34;, \u0026#34;function\u0026#34;, \u0026#34;if\u0026#34;, \u0026#34;in\u0026#34;, \u0026#34;local\u0026#34;, \u0026#34;nil\u0026#34;, \u0026#34;not\u0026#34;, \u0026#34;or\u0026#34;, \u0026#34;repeat\u0026#34;, \u0026#34;return\u0026#34;, \u0026#34;then\u0026#34;, \u0026#34;true\u0026#34;, \u0026#34;until\u0026#34;, \u0026#34;while\u0026#34;, \u0026#34;..\u0026#34;, \u0026#34;...\u0026#34;, \u0026#34;==\u0026#34;, \u0026#34;\u0026gt;=\u0026#34;, \u0026#34;\u0026lt;=\u0026#34;, \u0026#34;~=\u0026#34;, \u0026#34;\u0026lt;number\u0026gt;\u0026#34;, \u0026#34;\u0026lt;name\u0026gt;\u0026#34;, \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, \u0026#34;\u0026lt;eof\u0026gt;\u0026#34;, NULL };   Code Snippet 3: llex.c   and 到 while 之间是所有关键字 .. 到 ~= 之间是二元运算符 \u0026lt;number\u0026gt; 表示数字字面量 \u0026lt;name\u0026gt; 表示变量名称 \u0026lt;string\u0026gt; 表示字符串字面量 \u0026lt;eof\u0026gt; 表示文件结束符  在上面所有类型中，看不到单字符 token 的影子，如 ( , . ; [ 。 这是因为单字符用单字节 ascii 码表示（0 - 255），可以直接用自身来表示，记录在 int token 中。 这也是多字符 token 从 FIRST_RESERVED 257 开始的原因，巧妙的将两者分开。\nSeminfo #  Seminfo 用于存储 token 类型对应的内容。\n对于单字符，关键字和二元运算符，不需要记录额外内容，因为类型的文本表示是唯一的。 \u0026lt;number\u0026gt; \u0026lt;name\u0026gt; \u0026lt;string\u0026gt; 则不同，相应类型下存在无数可能的内容，这就是 seminfo 的作用。\n lua_Number r 用来记录 \u0026lt;number\u0026gt; 相应的内容 TString *ts 用来记录 \u0026lt;name\u0026gt; 变量的名称， \u0026lt;string\u0026gt; 字符串内容  LexState #  lex 是一个过程，过程中需要记录当下所处的状态，比如文件读取的位置，匹配的结果等， 这个关键的数据结构就是 LexState。\n整个 lex 过程围绕 LexState 展开，这样说毫不为过，清楚其有非常大的助益。\n55 56 57 58 59 60 61 62 63 64 65 66 67  typedef struct LexState { int current; /* current character (charint) */ int linenumber; /* input line counter */ int lastline; /* line of last token `consumed\u0026#39; */ Token t; /* current token */ Token lookahead; /* look ahead token */ struct FuncState *fs; /* `FuncState\u0026#39; is private to the parser */ struct lua_State *L; ZIO *z; /* input stream */ Mbuffer *buff; /* buffer for tokens */ TString *source; /* current source name */ char decpoint; /* locale decimal point */ } LexState;   Code Snippet 4: llex.h  将其中所有字段分为 3 部分\nlex 过程的重要部分\n ZIO *z ，源代码文件流 Mbuffer *buff ，lex 匹配过程中的 buffer int current ，当前 token 之后紧跟的字符 Token t ，当前 token Token lookahead ，前瞻的下一个 token  在 parser 章节再讨论\n struct FuncState *fs struct lua_State *L  非重点，暂不讨论\n int linenumber ，当前 current 所处行号 int lastline ，上一个 token 所处行号 TString *source ，源代码的名称 char decpoint ，和数字的 l10n 相关    内部数据间的协同，在 method 小节继续讲述。\nmethod #  luaX_init #  前面在 string 章节，关于其中 reserved 字段的作用没有讲述，刚好在 lexer 章节补上。\n35 36  /* number of reserved words */ #define NUM_RESERVED\t(cast(int, TK_WHILE-FIRST_RESERVED+1))   Code Snippet 5: llex.h  64 65 66 67 68 69 70 71 72  void luaX_init (lua_State *L) { int i; for (i=0; i\u0026lt;NUM_RESERVED; i++) { TString *ts = luaS_new(L, luaX_tokens[i]); luaS_fix(ts); /* reserved words are never collected */ lua_assert(strlen(luaX_tokens[i])+1 \u0026lt;= TOKEN_LEN); ts-\u0026gt;tsv.reserved = cast_byte(i+1); /* reserved word */ } }   Code Snippet 6: llex.c  之前提到，string 在 lua 内部只保存一份，是不可修改的。\nluaX_init 将所有关键字（如 local function end 等）预先分配，存储入全局表。 特别的，在其 reserved 字段上记录其在 enum RESERVED 中的序号，从 1 开始。\n这样带来的效果是，所有 reserved != 0 的 string 都是关键字，且可以由 reserved 来判断出关键字的 token 类型。\n这一点间接方便了 luaX_next 中，关键字类型 token 的判断过程。\nllex #  本质上来看，lexer 就是遵循些许模式，从字符流的头部开始匹配，找到并返回相匹配的 token。\n不同 token 的模式通常用 regex 来描述，将所有的模式转化为代码的形式，就是 lex 过程。\n一般而言，这是一个相对枯燥又考验耐心的工作，好在有 lexer generator 这样的工具，如 flex， 它可以直接将 regex 规则转化为 lex 代码。\n一般而言，一个语言的诞生初期，都会使用 lexer generator，方便快速迭代， 到了后期语言本身相对稳定的时候，为了提升效率，都会将 lex 过程重写，python ruby lua 都是如此。\n这也意味着，阅读 lua 中 lex 过程的代码不如同义的 flex 代码1轻松。\nlex 过程看似随意，底层其实有充足的数学理论支撑， regex NFA DFA 的同义转化，最终用代码方式呈现。 这一点远有更专业的书来讲解，具体细节就不再赘述。\nlexer 内部的核心方法就是 llex。\n334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445  static int llex (LexState *ls, SemInfo *seminfo) { luaZ_resetbuffer(ls-\u0026gt;buff); for (;;) { switch (ls-\u0026gt;current) { case \u0026#39;\\n\u0026#39;: case \u0026#39;\\r\u0026#39;: { inclinenumber(ls); continue; } case \u0026#39;-\u0026#39;: { next(ls); if (ls-\u0026gt;current != \u0026#39;-\u0026#39;) return \u0026#39;-\u0026#39;; /* else is a comment */ next(ls); if (ls-\u0026gt;current == \u0026#39;[\u0026#39;) { int sep = skip_sep(ls); luaZ_resetbuffer(ls-\u0026gt;buff); /* `skip_sep\u0026#39; may dirty the buffer */ if (sep \u0026gt;= 0) { read_long_string(ls, NULL, sep); /* long comment */ luaZ_resetbuffer(ls-\u0026gt;buff); continue; } } /* else short comment */ while (!currIsNewline(ls) \u0026amp;\u0026amp; ls-\u0026gt;current != EOZ) next(ls); continue; } case \u0026#39;[\u0026#39;: { int sep = skip_sep(ls); if (sep \u0026gt;= 0) { read_long_string(ls, seminfo, sep); return TK_STRING; } else if (sep == -1) return \u0026#39;[\u0026#39;; else luaX_lexerror(ls, \u0026#34;invalid long string delimiter\u0026#34;, TK_STRING); } case \u0026#39;=\u0026#39;: { next(ls); if (ls-\u0026gt;current != \u0026#39;=\u0026#39;) return \u0026#39;=\u0026#39;; else { next(ls); return TK_EQ; } } case \u0026#39;\u0026lt;\u0026#39;: { next(ls); if (ls-\u0026gt;current != \u0026#39;=\u0026#39;) return \u0026#39;\u0026lt;\u0026#39;; else { next(ls); return TK_LE; } } case \u0026#39;\u0026gt;\u0026#39;: { next(ls); if (ls-\u0026gt;current != \u0026#39;=\u0026#39;) return \u0026#39;\u0026gt;\u0026#39;; else { next(ls); return TK_GE; } } case \u0026#39;~\u0026#39;: { next(ls); if (ls-\u0026gt;current != \u0026#39;=\u0026#39;) return \u0026#39;~\u0026#39;; else { next(ls); return TK_NE; } } case \u0026#39;\u0026#34;\u0026#39;: case \u0026#39;\\\u0026#39;\u0026#39;: { read_string(ls, ls-\u0026gt;current, seminfo); return TK_STRING; } case \u0026#39;.\u0026#39;: { save_and_next(ls); if (check_next(ls, \u0026#34;.\u0026#34;)) { if (check_next(ls, \u0026#34;.\u0026#34;)) return TK_DOTS; /* ... */ else return TK_CONCAT; /* .. */ } else if (!isdigit(ls-\u0026gt;current)) return \u0026#39;.\u0026#39;; else { read_numeral(ls, seminfo); return TK_NUMBER; } } case EOZ: { return TK_EOS; } default: { if (isspace(ls-\u0026gt;current)) { lua_assert(!currIsNewline(ls)); next(ls); continue; } else if (isdigit(ls-\u0026gt;current)) { read_numeral(ls, seminfo); return TK_NUMBER; } else if (isalpha(ls-\u0026gt;current) || ls-\u0026gt;current == \u0026#39;_\u0026#39;) { /* identifier or reserved word */ TString *ts; do { save_and_next(ls); } while (isalnum(ls-\u0026gt;current) || ls-\u0026gt;current == \u0026#39;_\u0026#39;); ts = luaX_newstring(ls, luaZ_buffer(ls-\u0026gt;buff), luaZ_bufflen(ls-\u0026gt;buff)); if (ts-\u0026gt;tsv.reserved \u0026gt; 0) /* reserved word? */ return ts-\u0026gt;tsv.reserved - 1 + FIRST_RESERVED; else { seminfo-\u0026gt;ts = ts; return TK_NAME; } } else { int c = ls-\u0026gt;current; next(ls); return c; /* single-char tokens (+ - / ...) */ } } } } }   Code Snippet 7: llex.c  它的功能非常纯粹，从字符流的开始，进行模式匹配，找到相应的 token，并返回相应的类型和内容。\n      llex 的具体过程不再赘述，读者可以打开调试器，用一些代码示例来针对性的阅读。\n这里只略微提几个值得关注的点。\nkeyword #  关键字的匹配过程，和 \u0026lt;name\u0026gt; 的匹配过程统一在一起。\n不过是在最终得到匹配结果时，通过 reserved 字段来判断，是否是关键字。 之所以可以做到这一点是因为，所有 string 在全局表中都是唯一的， 而且 luaX_init 已经提前设置了所有的关键字。\n422 423 424 425 426 427 428 429 430 431 432 433 434 435 436  else if (isalpha(ls-\u0026gt;current) || ls-\u0026gt;current == \u0026#39;_\u0026#39;) { /* identifier or reserved word */ TString *ts; do { save_and_next(ls); } while (isalnum(ls-\u0026gt;current) || ls-\u0026gt;current == \u0026#39;_\u0026#39;); ts = luaX_newstring(ls, luaZ_buffer(ls-\u0026gt;buff), luaZ_bufflen(ls-\u0026gt;buff)); if (ts-\u0026gt;tsv.reserved \u0026gt; 0) /* reserved word? */ return ts-\u0026gt;tsv.reserved - 1 + FIRST_RESERVED; else { seminfo-\u0026gt;ts = ts; return TK_NAME; } }   Code Snippet 8: llex.c  这个巧妙的过程，意味着关键字的优先级高于标识符。\n定义与关键字同名的变量是不可能的，因为它会被辨别为是关键字，引发语法错误。\nlocal end = 1 number #  理想情况下，token 类型的识别在前，类型确定后，再来提取相应的内容。\n但是对于 \u0026lt;number\u0026gt; 并不是这样来处理的。\n193 194 195 196 197 198 199 200 201 202 203 204 205 206 207  /* LUA_NUMBER */ static void read_numeral (LexState *ls, SemInfo *seminfo) { lua_assert(isdigit(ls-\u0026gt;current)); do { save_and_next(ls); } while (isdigit(ls-\u0026gt;current) || ls-\u0026gt;current == \u0026#39;.\u0026#39;); if (check_next(ls, \u0026#34;Ee\u0026#34;)) /* `E\u0026#39;? */ check_next(ls, \u0026#34;+-\u0026#34;); /* optional exponent sign */ while (isalnum(ls-\u0026gt;current) || ls-\u0026gt;current == \u0026#39;_\u0026#39;) save_and_next(ls); save(ls, \u0026#39;\\0\u0026#39;); buffreplace(ls, \u0026#39;.\u0026#39;, ls-\u0026gt;decpoint); /* follow locale for decimal point */ if (!luaO_str2d(luaZ_buffer(ls-\u0026gt;buff), \u0026amp;seminfo-\u0026gt;r)) /* format error? */ trydecpoint(ls, seminfo); /* try to update decimal point separator */ }   Code Snippet 9: llex.c  如果用 regex 来表示这个过程，则是 [\\.[:digit:]]+[Ee[+-]?]?[[:alnum:]_]* ， 这个模式并不能完全匹配数字。\nlocal i = .3.3.3 .3.3.3 可以匹配相应模式，但是并不是数字。\n庆幸的是 lua 依旧发现这个错误，\nmalformed number near \u0026#39;.3.3.3\u0026#39; lua 内部使用 \u0026lt;stdlib.h\u0026gt; 中的 strtod 来尝试进行 string 到 number 的转换。 如果发生错误，则说明不是数字。\n525  #define lua_str2number(s,p)\tstrtod((s), (p))   Code Snippet 10: luaconf.h  看起来这并不合常规，因为 lua 只是粗略匹配了一段“像是 number”的内容，通过 strtod 来做最终判断， 感觉有些取巧。\nlong string #  lua 中可以用 [[]] 来表示长字符串，但是存在一种变体，比较少见， 形式如 [===[ ]===] 也是长字符串， = 的数量要完全相同。\n长字符串的规则，加上 -- 就可以扩充到长注释。\nlocal long_str = [[ this is a long string. ]] local another_str = [===[ another long string. ]===] --[[ comment this line ]] --[====[ comment this line ]====] 这一点在阅读代码时要注意。\nbuiltin #  next, require 等不是关键字，而是运行环境中提供的函数，它们的功能是在 VM 中实现的。\n这一点在后续 api 章节会讲到。\nluaX_lookahead #  在语法分析的过程中，存在少数情况，需要下一个 token 来去除多个模式间的歧义。\nluaX_lookahead 就是在这个时候使用，\n459 460 461 462  void luaX_lookahead (LexState *ls) { lua_assert(ls-\u0026gt;lookahead.token == TK_EOS); ls-\u0026gt;lookahead.token = llex(ls, \u0026amp;ls-\u0026gt;lookahead.seminfo); }   Code Snippet 11: llex.c  过程很简单，使用 llex 方法，将 token 存储在 LexState.lookahead 中。\n  luaX_next #  luaX_next 和 luaX_lookahead 相同，不过是将 token 存储在 LexState.t 中。\n如果 lookahead 中存在 token，则直接拿过来使用，并重置 lookahead。\n448 449 450 451 452 453 454 455 456  void luaX_next (LexState *ls) { ls-\u0026gt;lastline = ls-\u0026gt;linenumber; if (ls-\u0026gt;lookahead.token != TK_EOS) { /* is there a look-ahead token? */ ls-\u0026gt;t = ls-\u0026gt;lookahead; /* use this one */ ls-\u0026gt;lookahead.token = TK_EOS; /* and discharge it */ } else ls-\u0026gt;t.token = llex(ls, \u0026amp;ls-\u0026gt;t.seminfo); /* read next token */ }   Code Snippet 12: llex.c      a little lexer #  根据对 lex 模块的理解，可以做一个简单的 lexer 分析器。\n它不是一个独立的程序，而是一段 gdb 脚本，gdb 可以在 lua 在运行时进行 inspect。\n在 luaX_next 方法加上断点，每次触发的时候，就输出相应的 token，就可以实现一个简单的 lexer 工具。\n$ make -s lex source=./test/co.lua 这种做法有些许弱点，如果中途出现语法错误，过程就会中断，所以它只能分析语法分析正确的代码。\npractice #     文件 建议     lzio.h zio 模块中实现了 zio 和 mbuffer 结构，对字符流和 buffer 进行了封装，感兴趣的读者可仔细阅读   lzio.c 同上   llex.h 仔细阅读   llex.c 浏览阅读，配合调试器会更轻松      : http://lua-users.org/lists/lua-l/2005-12/msg00091.html \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':12,'href':'/lua-5.1-source-guide/docs/table/','title':"table",'section':"Docs",'content':"初次接触 lua 的人都有困惑， 多数动态语言都会内建 dict 和 array 的概念，而 lua 用 table 同时表示这两个概念。\n所谓 dict 不过是 kv 存储，从某种角度来看，可以将 array 看作 k 是整数的一种特殊情况。\n本章就来从源码角度认识 lua 中的 table。\nstructure #  338 339 340 341 342 343 344 345 346 347 348  typedef struct Table { CommonHeader; lu_byte flags; /* 1\u0026lt;\u0026lt;p means tagmethod(p) is not present */ lu_byte lsizenode; /* log2 of size of `node\u0026#39; array */ struct Table *metatable; TValue *array; /* array part */ Node *node; Node *lastfree; /* any free position is before this position */ GCObject *gclist; int sizearray; /* size of `array\u0026#39; array */ } Table;   table 的结构并不复杂，除去 CommonHeader 和 gclist，剩余的字段可分为 3 部分。\ndict 相关\n Node * node ，kv 存储的数组 lu_byte lsizenode ，数组的大小，用 log2 表示 Node * lastfree ，在数组中从尾向前，第一个空闲位置的指针  array 相关\n TValue * array ，array 存储的数组 int sizearray ，array 的大小  metatable 相关\n struct Table * metatable ，metatable 的指针 lu_byte flags ，一个字节，用于缓存加速 meta method 的搜索  从结构中可以发现，table 并不只是单纯的 dict 结构，为了效率，在内部也用 array 的方式进行辅助存储。\n下面就 3 个部分，分别讨论\ndict #  在 lua 中，用 table 表示 dict 概念，有非常大的自由度。\n使用 k v 存储时\n k 不能是 nil 若 v 是 nil，表示从 dict 中删除 k v 除此之外，k v 可以是任意值，无论是 function 还是 string  本质上来看，这就是用 TValue 统一表示所有“值”所带来的好处。 这一点从 Node 结构中可以清楚的看出来。\n323 324 325 326 327 328 329 330 331 332 333 334 335  typedef union TKey { struct { TValuefields; struct Node *next; /* for chaining */ } nk; TValue tvk; } TKey; typedef struct Node { TValue i_val; TKey i_key; } Node;     Figure 1: Node \u0026amp; TKey\n  Node 代表一个 k v 存储，k v 分别用 i_key 和 i_val 来表示。 i_val 本身是 TValue， i_key 是 TKey。\nTKey 本身是一个 union，其中用 tvk 来索引本身的值，即 TValue。 另一项 nk 则添加了 next 指针，辅助在 Node 数组中做链接。 所以本质上， i_key 也是 TValue。\ndict 表示的是多个 kv 的集合，在 table 内部，所有 kv 经过相应的安排，存储在 Node 数组中。\n比如下面的代码，在 table 内部将可能会如此表示。\nlocal t = {} t[print] = true t[true] = false t[\u0026#34;return\u0026#34;] = 0 t[\u0026#34;name\u0026#34;] = \u0026#34;print\u0026#34; t[\u0026#34;tool\u0026#34;] = \u0026#34;dot\u0026#34;   Figure 2: kv stored in Node array\n  至于 kv 存取的方式，在 get set 小节详细讨论。\n有了上面的理解，相关的宏也就容易理解了。\n13 14 15 16 17 18  #define gnode(t,i)\t(\u0026amp;(t)-\u0026gt;node[i]) #define gkey(n)\t(\u0026amp;(n)-\u0026gt;i_key.nk) #define gval(n)\t(\u0026amp;(n)-\u0026gt;i_val) #define gnext(n)\t((n)-\u0026gt;i_key.nk.next)  #define key2tval(n)\t(\u0026amp;(n)-\u0026gt;i_key.tvk)   Code Snippet 1: ltable.h  352 353 354 355 356 357 358 359 360  /* ** `module\u0026#39; operation for hashing (size is always a power of 2) */ #define lmod(s,size) \\ (check_exp((size\u0026amp;(size-1))==0, (cast(int, (s) \u0026amp; ((size)-1)))))  #define twoto(x)\t(1\u0026lt;\u0026lt;(x)) #define sizenode(t)\t(twoto((t)-\u0026gt;lsizenode))   Code Snippet 2: lobject.h  main position #  table 内部使用巧妙的方式来存储 kv，其中关键的概念是 main position。\n因为 k 可以是任意类型的值，在存储 kv 之前，必须先确定将其安排在什么位置， 这个位置就是 kv 的 main position。\n计算的方式并不陌生，先计算 k 的 hash 值，再模除 node 数组长度，得到 main position。\n前面提到，k 可以是 nil 之外任意类型的值，所以在计算 main position 的时候， 针对不同的类型有不同的计算方式。\n96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113  /* ** returns the `main\u0026#39; position of an element in a table (that is, the index ** of its hash value) */ static Node *mainposition (const Table *t, const TValue *key) { switch (ttype(key)) { case LUA_TNUMBER: return hashnum(t, nvalue(key)); case LUA_TSTRING: return hashstr(t, rawtsvalue(key)); case LUA_TBOOLEAN: return hashboolean(t, bvalue(key)); case LUA_TLIGHTUSERDATA: return hashpointer(t, pvalue(key)); default: return hashpointer(t, gcvalue(key)); } }   Code Snippet 3: ltable.c  针对不同类型详细来看，\n50 51 52 53 54 55 56 57 58 59 60 61 62 63  #define hashpow2(t,n) (gnode(t, lmod((n), sizenode(t))))  #define hashstr(t,str) hashpow2(t, (str)-\u0026gt;tsv.hash) #define hashboolean(t,p) hashpow2(t, p)  /* ** for some types, it is better to avoid modulus by power of 2, as ** they tend to have many 2 factors. */ #define hashmod(t,n)\t(gnode(t, ((n) % ((sizenode(t)-1)|1))))  #define hashpointer(t,p)\thashmod(t, IntPoint(p))   Code Snippet 4: ltable.c  string #  string 比较简单，依旧使用自身的 hash，再模除 node size 得到 main position。\nbool #  bool 类型更简单，直接锁定了 main position 的 0 1 位置。\nlight userdata #  对于 light userdata，强制将 pointer 地址解析为 unsigned int 作为 hash 值， 模除 node size - 1 得到 main position。\n因为地址一般按照 2 的幂对齐，而且 node size 也是 2 的幂，直接模除不容易将值分散开来， 所以就使用 node size - 1。\nhashmod 末尾的 | 1 是避免出现 mod 0 的情况。\nGCObject #  同 light userdata，进行指针运算。\nnumber #  66 67 68 69  /* ** number of ints inside a lua_Number */ #define numints\tcast_int(sizeof(lua_Number)/sizeof(int))   Code Snippet 5: ltable.c  81 82 83 84 85 86 87 88 89 90 91 92  /* ** hash for lua_Numbers */ static Node *hashnum (const Table *t, lua_Number n) { unsigned int a[numints]; int i; if (luai_numeq(n, 0)) /* avoid problems with -0 */ return gnode(t, 0); memcpy(a, \u0026amp;n, sizeof(a)); for (i = 1; i \u0026lt; numints; i++) a[0] += a[i]; return hashmod(t, a[0]); }     lua_Number 默认用 double 来表示，在 32 位系统中，double 通常占用 64 位。 从二进制表示层面，将 double 分拆为 2 个 unsigned int，求和后再模除 node size - 1 得到 main position。\n这里要注意两个细节，\n一是对 +0 -0 做了统一处理。 +0 -0 在数值角度上是相等的，但是在二进制浮点表示1上， 存在标志位的不同，如果依旧使用分拆 unsigned int 的方式， +0 -0 将计算得到不同的 main position， 这显然不是我们想要的，所以这里统一用 main position 0 来处理。\n二是在模除的过程中， hashmod 并非使用 node size 进行模除，而是 node size - 1，原因同上。\nset #  明确 main position 之后，下一步来了解如何存储 kv。\n根据代码中的注释，dict 部分的实现 use a mix of chained scatter table with brent\u0026rsquo;s variation。\n8 9 10 11 12 13 14 15 16 17 18 19  /* ** Implementation of tables (aka arrays, objects, or hash tables). ** Tables keep its elements in two parts: an array part and a hash part. ** Non-negative integer keys are all candidates to be kept in the array ** part. The actual size of the array is the largest `n\u0026#39; such that at ** least half the slots between 0 and n are in use. ** Hash uses a mix of chained scatter table with Brent\u0026#39;s variation. ** A main invariant of these tables is that, if an element is not ** in its main position (i.e. the `original\u0026#39; position that its hash gives ** to it), then the colliding element is in its own main position. ** Hence even when the load factor reaches 100%, performance remains good. */   有兴趣的可以研究论文2，这里仅从代码方面解析其实现。\ntable 模块中提供了 luaH_set 实现 kv 存储。\n494 495 496 497 498 499 500 501 502 503 504 505  TValue *luaH_set (lua_State *L, Table *t, const TValue *key) { const TValue *p = luaH_get(t, key); t-\u0026gt;flags = 0; if (p != luaO_nilobject) return cast(TValue *, p); else { if (ttisnil(key)) luaG_runerror(L, \u0026#34;table index is nil\u0026#34;); else if (ttisnumber(key) \u0026amp;\u0026amp; luai_numisnan(nvalue(key))) luaG_runerror(L, \u0026#34;table index is NaN\u0026#34;); return newkey(L, t, key); } }   Code Snippet 6: ltable.c  可以观察到，其中只有 k 参数，而没有 v 参数。 这是因为这个方法只返回参数 k 在 table 中对应 node.i_val 的指针，由外部调用者自行进行 v 的赋值。\nluaH_set 很简单，如果已经存在相应的 k，则直接返回； 通过一系列错误检测之后，调用 newkey 方法，添加 k。\n392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429  /* ** inserts a new key into a hash table; first, check whether key\u0026#39;s main ** position is free. If not, check whether colliding node is in its main ** position or not: if it is not, move colliding node to an empty place and ** put new key in its main position; otherwise (colliding node is in its main ** position), new key goes to an empty position. */ static TValue *newkey (lua_State *L, Table *t, const TValue *key) { Node *mp = mainposition(t, key); if (!ttisnil(gval(mp)) || mp == dummynode) { Node *othern; Node *n = getfreepos(t); /* get a free place */ if (n == NULL) { /* cannot find a free place? */ rehash(L, t, key); /* grow table */ return luaH_set(L, t, key); /* re-insert key into grown table */ } lua_assert(n != dummynode); othern = mainposition(t, key2tval(mp)); if (othern != mp) { /* is colliding node out of its main position? */ /* yes; move colliding node into free position */ while (gnext(othern) != mp) othern = gnext(othern); /* find previous */ gnext(othern) = n; /* redo the chain with `n\u0026#39; in place of `mp\u0026#39; */ *n = *mp; /* copy colliding node into free pos. (mp-\u0026gt;next also goes) */ gnext(mp) = NULL; /* now `mp\u0026#39; is free */ setnilvalue(gval(mp)); } else { /* colliding node is in its own main position */ /* new node will go into free position */ gnext(n) = gnext(mp); /* chain new position */ gnext(mp) = n; mp = n; } } gkey(mp)-\u0026gt;value = key-\u0026gt;value; gkey(mp)-\u0026gt;tt = key-\u0026gt;tt; luaC_barriert(L, t, key); lua_assert(ttisnil(gval(mp))); return gval(mp); }   Code Snippet 7: ltable.c  newkey 是理解内部结构的关键。 调用时可能遇到 3 种情况，下面一一讨论。\nmp free #  k 的 main position 是空闲的，即相应的 node.i_val 是 nil 值。\n  这种情况下，mp 的位置就是要插入的位置，说明 line 401 为 false，直接执行 line 425 。\n  colliding node in own mp #  如果 k 的 main position（mp）已经被占用，说明出现了冲突， 占用 mp 的结点称为 colliding node。\ncolliding node 根据 i_key 也可以计算出自身的 main position（othern）。\n如果 othern 和 mp 是相同的，说明两者确实发生了 hash 冲突，都应该使用这个位置。\n  但是位置只有一个，只能从当前空闲的结点借用一个位置（n）， 然后使用头插法，用 i_key.next 将其链接起来。\n可以发现，这个链条的起点从 main position 开始，链接的全部是 main position 相同（即 hash 冲突）的结点。\n  colliding node not in own mp #  如果 othern 和 mp 不相同，说明 colliding node 是在之前冲突时，借用了此结点的位置。\n之前是空闲的，可以借用，但是现在，明确拥有 mp 的 k 要来拿回属于自己的位置，colliding node 只能让出来。\n  让出的方法很简单，再另外找到一个空闲位置，放置 colliding node，原来的位置就还回去。\n为了将新位置链接回去，同时从 othern 一路向下，查找到 colliding node 的上一个结点，并链接新的结点。\n  get #  在 set 小节明确了 node 内部组织的方法之后，get 方法就很容易理解了。\n466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491  /* ** main search function */ const TValue *luaH_get (Table *t, const TValue *key) { switch (ttype(key)) { case LUA_TNIL: return luaO_nilobject; case LUA_TSTRING: return luaH_getstr(t, rawtsvalue(key)); case LUA_TNUMBER: { int k; lua_Number n = nvalue(key); lua_number2int(k, n); if (luai_numeq(cast_num(k), nvalue(key))) /* index is int? */ return luaH_getnum(t, k); /* use specialized version */ /* else go through */ } default: { Node *n = mainposition(t, key); do { /* check whether `key\u0026#39; is somewhere in the chain */ if (luaO_rawequalObj(key2tval(n), key)) return gval(n); /* that\u0026#39;s it */ else n = gnext(n); } while (n); return luaO_nilobject; } } }   Code Snippet 8: ltable.c  核心就是先计算得到 main position，再一路通过 next 向下查找， 如果 k 匹配，就返回相应的 v；否则返回 nil。\narray #  前面提到，为了效率，table 内部有特定的区域用于存储 array 相关的数据（k 为正整数）。\n考虑如下代码，\nlocal t = {1, 2, 3, 4} 如果内部使用 TValue[] 来存储，效率自然是最高的。\n 空间上，Node 结构大小至少为 2 * TValue，若直接用数组表示，只需要 1 * TValue 的空间； 时间上，若直接使用数组，可以直接索引元素，速度非常快，而 Node 需要在整个链条中使用 next 遍历。  但是，假如出现这种情况，\nlocal t = {1, 2, 3, 4, [1000] = 1000} 索引都为正整数，但是中间并不连续，从 4 到 1000 出现了巨大的空隙。\n假如依旧使用 TValue[] 来存储就不划算了，大小必须为 1000，中间浪费的空间太多。\n综合考虑，lua 使用一种权衡的方式来安排正整数索引的数据。\n具体而言，就是找到一个最大的整数 n，其中 0 到 n 之间至少有 n/2 个整数索引， 这样可以保持至少 50% 的利用率。\n剩余在 n 范围之外的索引，依旧使用 kv 方式来存储。\n  需要注意的细节是，table 表示 array 的时候，默认索引从 1 开始。\n相应的，table 中的 TValue *array 只存储正整数索引（\u0026gt;= 1）对应的值。 由于 C 语言数组的索引从 0 开始，所以存储时，有 1 个位置偏移。\nget #  在讲解 get 之前，需要明确一点，并且所有数字索引的 kv 都会存储在内部的 array 中。\n对于类型是 number 的 k，需要其\n 不是浮点值，是整数值 是 \u0026gt;= 1 的正整数 范围在 1 - sizearray 之间  不在这个范围内的 kv，依旧按照 dict 来处理，从代码中可以明确看到这一点。\n466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491  /* ** main search function */ const TValue *luaH_get (Table *t, const TValue *key) { switch (ttype(key)) { case LUA_TNIL: return luaO_nilobject; case LUA_TSTRING: return luaH_getstr(t, rawtsvalue(key)); case LUA_TNUMBER: { int k; lua_Number n = nvalue(key); lua_number2int(k, n); if (luai_numeq(cast_num(k), nvalue(key))) /* index is int? */ return luaH_getnum(t, k); /* use specialized version */ /* else go through */ } default: { Node *n = mainposition(t, key); do { /* check whether `key\u0026#39; is somewhere in the chain */ if (luaO_rawequalObj(key2tval(n), key)) return gval(n); /* that\u0026#39;s it */ else n = gnext(n); } while (n); return luaO_nilobject; } } }   Code Snippet 9: ltable.c  432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449  /* ** search function for integers */ const TValue *luaH_getnum (Table *t, int key) { /* (1 \u0026lt;= key \u0026amp;\u0026amp; key \u0026lt;= t-\u0026gt;sizearray) */ if (cast(unsigned int, key-1) \u0026lt; cast(unsigned int, t-\u0026gt;sizearray)) return \u0026amp;t-\u0026gt;array[key-1]; else { lua_Number nk = cast_num(key); Node *n = hashnum(t, nk); do { /* check whether `key\u0026#39; is somewhere in the chain */ if (ttisnumber(gkey(n)) \u0026amp;\u0026amp; luai_numeq(nvalue(gkey(n)), nk)) return gval(n); /* that\u0026#39;s it */ else n = gnext(n); } while (n); return luaO_nilobject; } }   set #  set 的逻辑也很简单，不过其中有一点需要注意。\n回忆之前 dict 部分的 set 方法，返回的是存储 v 的指针，而如果 kv 安排在 array 部分， 则不需要 newkey 过程，直接返回相应的 array 位置即可。\n494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517  TValue *luaH_set (lua_State *L, Table *t, const TValue *key) { const TValue *p = luaH_get(t, key); t-\u0026gt;flags = 0; if (p != luaO_nilobject) return cast(TValue *, p); else { if (ttisnil(key)) luaG_runerror(L, \u0026#34;table index is nil\u0026#34;); else if (ttisnumber(key) \u0026amp;\u0026amp; luai_numisnan(nvalue(key))) luaG_runerror(L, \u0026#34;table index is NaN\u0026#34;); return newkey(L, t, key); } } TValue *luaH_setnum (lua_State *L, Table *t, int key) { const TValue *p = luaH_getnum(t, key); if (p != luaO_nilobject) return cast(TValue *, p); else { TValue k; setnvalue(\u0026amp;k, cast_num(key)); return newkey(L, t, \u0026amp;k); } }   Code Snippet 10: ltable.c  先调用 get 方法，得到结果 p， if (p != luaO_nilobject) 非常关键。\n回忆 get 方法， 如果相应 kv 存储在 array 中，直接返回 array 中相应的地址，地址必定不是 luaO_nilobject ； 而如果存储在 Node 中，如果找不到相应的 k，才会返回 luaO_nilobject 。\n这一点细节，和之前的逻辑完美统一起来。\nmethod #  除了 table 内部组织数据的方式，部分方法也值得关注。\nnext #  在 lua 语言中，我们可以使用 next 方法来遍历 table。 next 接收两个参考，一个是 table，一个是 k。\nnext 的行为也很容易理解，\n 如果 k 是 nil，则返回 table 的第一项； 如果 table 中没有相应的 k，则出错； 如果存在相应的 k，则返回存储在 k 之后的 k 和 v； 如果 k 是最后一项，则返回 nil nil   local t = { 1, 2, 3, 4, [\u0026#34;name\u0026#34;] = \u0026#34;t\u0026#34;, [\u0026#34;section\u0026#34;] = \u0026#34;table\u0026#34; } t[3] = nil local k = nil local v repeat k, v = next(t, k) print(k, v) until k == nil 1\t1 2\t2 4\t4 name\tt section\ttable nil\tnil 上面的示例代码，k 以 nil 为开始，不断输入 next，最终遍历整个 table。\n  这里要思考的问题是，next 的顺序是如何决定的。 上面的示例代码，无论运行多少次，输出结果都是一样的。说明内部有明显的顺序安排，而不是随机的。\n观察代码不难发现，顺序正是依次遍历 array 数组和 node 数组来决定的。\n  语言中使用的 next 是在 api 层面定义的，而底层使用的方法正是 luaH_next 。\n132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179  /* ** returns the index of a `key\u0026#39; for table traversals. First goes all ** elements in the array part, then elements in the hash part. The ** beginning of a traversal is signalled by -1. */ static int findindex (lua_State *L, Table *t, StkId key) { int i; if (ttisnil(key)) return -1; /* first iteration */ i = arrayindex(key); if (0 \u0026lt; i \u0026amp;\u0026amp; i \u0026lt;= t-\u0026gt;sizearray) /* is `key\u0026#39; inside array part? */ return i-1; /* yes; that\u0026#39;s the index (corrected to C) */ else { Node *n = mainposition(t, key); do { /* check whether `key\u0026#39; is somewhere in the chain */ /* key may be dead already, but it is ok to use it in `next\u0026#39; */ if (luaO_rawequalObj(key2tval(n), key) || (ttype(gkey(n)) == LUA_TDEADKEY \u0026amp;\u0026amp; iscollectable(key) \u0026amp;\u0026amp; gcvalue(gkey(n)) == gcvalue(key))) { i = cast_int(n - gnode(t, 0)); /* key index in hash table */ /* hash elements are numbered after array ones */ return i + t-\u0026gt;sizearray; } else n = gnext(n); } while (n); luaG_runerror(L, \u0026#34;invalid key to \u0026#34; LUA_QL(\u0026#34;next\u0026#34;)); /* key not found */ return 0; /* to avoid warnings */ } } int luaH_next (lua_State *L, Table *t, StkId key) { int i = findindex(L, t, key); /* find original element */ for (i++; i \u0026lt; t-\u0026gt;sizearray; i++) { /* try first array part */ if (!ttisnil(\u0026amp;t-\u0026gt;array[i])) { /* a non-nil value? */ setnvalue(key, cast_num(i+1)); setobj2s(L, key+1, \u0026amp;t-\u0026gt;array[i]); return 1; } } for (i -= t-\u0026gt;sizearray; i \u0026lt; sizenode(t); i++) { /* then hash part */ if (!ttisnil(gval(gnode(t, i)))) { /* a non-nil value? */ setobj2s(L, key, key2tval(gnode(t, i))); setobj2s(L, key+1, gval(gnode(t, i))); return 1; } } return 0; /* no more elements */ }   Code Snippet 11: ltable.c  luaH_next 输入的是 k，\n 首先，通过 findindex 找到 k 在 array/node 数组中的索引， 然后，将索引 i 自增， Line 164 for (i++, ...) 先遍历 array 部分，再遍历 node 部分，跳过所有 v 为 nil 的项 直到 array 和 node 遍历结束  值得注意的是， luaH_next 返回 0/1 说明是否已经遍历结束，方法内部将 k v 存储在栈上。\n关于栈和 api 的具体分析，见之后的章节。\npractice #  table 模块中还有部分方法没有涉及到，如 rehash, getn 等，但并非重点内容， 感兴趣的读者可自行阅读。\n在明确内部存储结构的基础上，其它方法并不难理解。\n   文件 建议     ltable.h 仔细阅读   ltable.c 浏览阅读，关注核心方法      : https://en.wikipedia.org/wiki/Double-precision%5Ffloating-point%5Fformat \u0026#x21a9;\u0026#xfe0e;\n : https://maths-people.anu.edu.au/~brent/pub/pub013.html \u0026#x21a9;\u0026#xfe0e;\n   "});index.add({'id':13,'href':'/lua-5.1-source-guide/docs/string/','title':"string",'section':"Docs",'content':"string 是多数编程语言内建的类型，lua 也不例外。\nlua 代码中使用字符串是非常方便的，呼之即来，使用后也可以不闻不问。 因为 string 在底层自动新建，并由 gc 自动回收，极大方便了上层使用者。\n更重要的是，string 同时也在 lua 的底层实现发挥着重要的作用。\n本章就来讲解 lua 中的 string。\nstructure #  在 object 章节中已经提到，string 类型在 GCObject 中用 TString ts 表示。\n196 197 198 199 200 201 202 203 204 205 206 207  /* ** String headers for string table */ typedef union TString { L_Umaxalign dummy; /* ensures maximum alignment for strings */ struct { CommonHeader; lu_byte reserved; unsigned int hash; size_t len; } tsv; } TString;   Code Snippet 1: lobject.h  TString 看上去是 union 结构，但是 dummy 只用来做对齐，并不用作实际用途， 所以考虑这一点，TString 本质还是一个 struct 结构。\n除去 CommonHeader 部分，新增了 3 个字段，存储 string 的元数据， 而实际的数据部分，紧紧跟在 TString 的后面，而没有使用如 next 之类的指针来引用，是一种巧妙的方法。\n  data 部分是通用的 char[]。\nmeta 部分，用新增的 3 个字段来记录，\n reserved，用于关键字（如 if，end 等），到 lex 章节再详细解释 hash，由 data 计算得到的 hash 值，在 new 小节详细解释 len，data 长度，不包含最后的 \u0026lsquo;\\0\u0026rsquo;  明确了这种结构之后，相关的宏就很容易理解。\n210  #define getstr(ts)\tcast(const char *, (ts) + 1)   Code Snippet 2: lobject.h  使用 ts + 1 来索引到 data 的位置，并取到 data 数据。\n16  #define sizestring(s)\t(sizeof(union TString)+((s)-\u0026gt;len+1)*sizeof(char))   Code Snippet 3: lstring.h  TString 的空间大小就是 meta + data 的大小，+1 是因为要计入末尾的 \u0026lsquo;\\0\u0026rsquo;。\nnew #  immutable #  多数 lua 用户不知道的是，lua 中所有的 string 都是不可变的，且只有一份留存在内存中。\n比如如下示例代码，\nlocal a = \u0026#34;pre\u0026#34; local b = \u0026#34;post\u0026#34; local c = a .. b local d = \u0026#34;pre\u0026#34; 变量 a d 指向同一个 string 类型的 TValue（还记得吗？）\na .. b 连接的过程没有修改 \u0026quot;pre\u0026quot; 或者 \u0026quot;post\u0026quot; ，而是新建了 \u0026quot;prepost\u0026quot; ，新变量 c 指向它。\n  string table #  前面提到的 immutable 的特性，正是对底层实现的一种表面呈现。\n实际上，所有新建的 TString 都集合存储在 global_State 中的 stringtable。\n65 66 67 68 69  /* ** `global state\u0026#39;, shared by all threads of this state */ typedef struct global_State { stringtable strt; /* hash table for strings */   Code Snippet 4: lstate.h  38 39 40 41 42  typedef struct stringtable { GCObject **hash; lu_int32 nuse; /* number of elements */ int size; } stringtable;   stringtable 就是教科书式的 hash table 实现。\n hash，元素为 GCObject * 的桶数组 nuse，已存储 TString 的数量 size，桶数组的长度    method #    string 模块中提供的方法非常少，新建 TString 的核心过程实现在 luaS_newlstr 和 newlstr 中。\n75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93  TString *luaS_newlstr (lua_State *L, const char *str, size_t l) { GCObject *o; unsigned int h = cast(unsigned int, l); /* seed */ size_t step = (l\u0026gt;\u0026gt;5)+1; /* if string is too long, don\u0026#39;t hash all its chars */ size_t l1; for (l1=l; l1\u0026gt;=step; l1-=step) /* compute hash */ h = h ^ ((h\u0026lt;\u0026lt;5)+(h\u0026gt;\u0026gt;2)+cast(unsigned char, str[l1-1])); for (o = G(L)-\u0026gt;strt.hash[lmod(h, G(L)-\u0026gt;strt.size)]; o != NULL; o = o-\u0026gt;gch.next) { TString *ts = rawgco2ts(o); if (ts-\u0026gt;tsv.len == l \u0026amp;\u0026amp; (memcmp(str, getstr(ts), l) == 0)) { /* string may be dead */ if (isdead(G(L), o)) changewhite(o); return ts; } } return newlstr(L, str, l, h); /* not found */ }   Code Snippet 5: lstring.c  从公有方法 luaS_newlstr 开始\n 先计算 字符串 hash 用 模除 方式找到相应的 bucket 如果桶中有元素，一路向下查找 如果有相同 char * 内容的元素存在，返回相应元素 直到这时，才新建 TString   50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  static TString *newlstr (lua_State *L, const char *str, size_t l, unsigned int h) { TString *ts; stringtable *tb; if (l+1 \u0026gt; (MAX_SIZET - sizeof(TString))/sizeof(char)) luaM_toobig(L); ts = cast(TString *, luaM_malloc(L, (l+1)*sizeof(char)+sizeof(TString))); ts-\u0026gt;tsv.len = l; ts-\u0026gt;tsv.hash = h; ts-\u0026gt;tsv.marked = luaC_white(G(L)); ts-\u0026gt;tsv.tt = LUA_TSTRING; ts-\u0026gt;tsv.reserved = 0; memcpy(ts+1, str, l*sizeof(char)); ((char *)(ts+1))[l] = \u0026#39;\\0\u0026#39;; /* ending 0 */ tb = \u0026amp;G(L)-\u0026gt;strt; h = lmod(h, tb-\u0026gt;size); ts-\u0026gt;tsv.next = tb-\u0026gt;hash[h]; /* chain new entry */ tb-\u0026gt;hash[h] = obj2gco(ts); tb-\u0026gt;nuse++; if (tb-\u0026gt;nuse \u0026gt; cast(lu_int32, tb-\u0026gt;size) \u0026amp;\u0026amp; tb-\u0026gt;size \u0026lt;= MAX_INT/2) luaS_resize(L, tb-\u0026gt;size*2); /* too crowded */ return ts; }   Code Snippet 6: lstring.c  私有方法 newlstr 调用的前提是，桶数组中没有相同 char * 内容的 TString 存在\n 检测是否超出长度限制，在右侧减运算防止溢出 分配内存，l+1 是为了补足最后的 \u0026lsquo;\\0\u0026rsquo; 添加后置 \u0026lsquo;\\0\u0026rsquo; 头插法，插入到 string table 中，这样就不用判断桶中是否有元素， 使用隐藏在 CommonHeader 中的 next 将元素链接起来。 按需进行 resize  理解了上述方法，余下的两个宏自然也容易理解\n20 21 22  #define luaS_new(L, s)\t(luaS_newlstr(L, s, strlen(s))) #define luaS_newliteral(L, s)\t(luaS_newlstr(L, \u0026#34;\u0026#34; s, \\ (sizeof(s)/sizeof(char))-1))   Code Snippet 7: lstring.h  两者的区别在于 luaS_literal 只能接受字面量参数。 因为如果 sizeof(s) 中的 s 是 char * ，得到的是指针类型的长度，而不是字符串的长度。\nresize #  resize 方法的作用是用于动态调整 hash table 中桶的数量，\n 如果桶个数过少，容易出现冲突 如果桶个数过多，空间利用率不高  在不考虑极值的情况下\n 当元素数量超过桶的个数，则 2 倍拓展 当元素数量小于 1/4 桶的个数，则 2 倍收缩   69 70  if (tb-\u0026gt;nuse \u0026gt; cast(lu_int32, tb-\u0026gt;size) \u0026amp;\u0026amp; tb-\u0026gt;size \u0026lt;= MAX_INT/2) luaS_resize(L, tb-\u0026gt;size*2); /* too crowded */   Code Snippet 8: lstring.c  433 434 435 436  /* check size of string hash */ if (g-\u0026gt;strt.nuse \u0026lt; cast(lu_int32, g-\u0026gt;strt.size/4) \u0026amp;\u0026amp; g-\u0026gt;strt.size \u0026gt; MINSTRTABSIZE*2) luaS_resize(L, g-\u0026gt;strt.size/2); /* table is too big */   Code Snippet 9: lgc.c  practice #   luaS_resize 留待读者自行阅读，教科书式的实现 因为 userdata 的新建方法和 string 非常相似，在源码中也就一并放在一起，关注  sizeudata luaS_newudata       文件 建议     lstring.h 仔细阅读   lstring.c 仔细阅读    "});index.add({'id':14,'href':'/lua-5.1-source-guide/docs/memory/','title':"memory",'section':"Docs",'content':"内存管理对所有程序都很关键，对于动态语言更是如此。\nlua 是单线程程序，即使在内部实现了协程，但内存还是统一管理的。\n内存回收使用 gc 算法，是非常重要的模块，而相对地，内存分配就显得非常简单。\n本章就讲解 lua 源码中关于内存分配的内容。\ncore api #  内存分配，无外乎涉及 3 个基础 api\n malloc realloc free  对于了解操作系统和 C 语言的大家都不陌生。\nlua 内部将其简化为 1 个 api，定义原型为 lua_Alloc\n63 64 65 66  /* ** prototype for memory-allocation functions */ typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);   Code Snippet 1: lua.h  这是一个函数指针，规定其行为需遵从如下约定\n23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  /* ** About the realloc function: ** void * frealloc (void *ud, void *ptr, size_t osize, size_t nsize); ** (`osize\u0026#39; is the old size, `nsize\u0026#39; is the new size) ** ** Lua ensures that (ptr == NULL) iff (osize == 0). ** ** * frealloc(ud, NULL, 0, x) creates a new block of size `x\u0026#39; ** ** * frealloc(ud, p, x, 0) frees the block `p\u0026#39; ** (in this specific case, frealloc must return NULL). ** particularly, frealloc(ud, NULL, 0, 0) does nothing ** (which is equivalent to free(NULL) in ANSI C) ** ** frealloc returns NULL if it cannot create or reallocate the area ** (any reallocation to an equal or smaller size cannot fail!) */   Code Snippet 2: lmem.c  简单的说，就是根据参数的不同，将 3 个基础 api 的功能用 1 个 api 来表示\n malloc， frealloc(ud, NULL, 0, ns) ，分配大小为 ns 的内存，返回头地址 realloc， frealloc(ud, p, os, ns) ，变更 p 开始的内存块大小从 os 到 ns，失败返回 NULL free， frealloc(ud, p, os, 0) ，回收以 p 开始的 os 大小的内存块，返回 NULL  lua 默认提供一个符合约定的 frealloc 函数供内部使用，可以看到它是非常纯粹的\n627 628 629 630 631 632 633 634 635 636  static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) { (void)ud; (void)osize; if (nsize == 0) { free(ptr); return NULL; } else return realloc(ptr, nsize); }   Code Snippet 3: lauxlib.c  about global state #  在 overview 章节，简单提到了 global_State ，字面意义上理解，它和全局的状态相关。\n这里就是它的一个应用方面，记录内存分配相关的状态。\n65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94  /* ** `global state\u0026#39;, shared by all threads of this state */ typedef struct global_State { stringtable strt; /* hash table for strings */ lua_Alloc frealloc; /* function to reallocate memory */ void *ud; /* auxiliary data to `frealloc\u0026#39; */ lu_byte currentwhite; lu_byte gcstate; /* state of garbage collector */ int sweepstrgc; /* position of sweep in `strt\u0026#39; */ GCObject *rootgc; /* list of all collectable objects */ GCObject **sweepgc; /* position of sweep in `rootgc\u0026#39; */ GCObject *gray; /* list of gray objects */ GCObject *grayagain; /* list of objects to be traversed atomically */ GCObject *weak; /* list of weak tables (to be cleared) */ GCObject *tmudata; /* last element of list of userdata to be GC */ Mbuffer buff; /* temporary buffer for string concatentation */ lu_mem GCthreshold; lu_mem totalbytes; /* number of bytes currently allocated */ lu_mem estimate; /* an estimate of number of bytes actually in use */ lu_mem gcdept; /* how much GC is `behind schedule\u0026#39; */ int gcpause; /* size of pause between successive GCs */ int gcstepmul; /* GC `granularity\u0026#39; */ lua_CFunction panic; /* to be called in unprotected errors */ TValue l_registry; struct lua_State *mainthread; UpVal uvhead; /* head of double-linked list of all open upvalues */ struct Table *mt[NUM_TAGS]; /* metatables for basic types */ TString *tmname[TM_N]; /* array with tag-method names */ } global_State;   Code Snippet 4: lstate.h   frealloc 引用内部的内存分配函数，即上面提到的 l_alloc ud 引用 frealloc 函数的第一个参数，提供辅助数据，用于用户自定义 totalbytes 记录已分配的总内存大小  在了解 global_State 相关字段后，就不难理解 lua 在 c api 层面提供的相关接口， 使用户自定义内存管理函数。\n1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022  LUA_API lua_Alloc lua_getallocf (lua_State *L, void **ud) { lua_Alloc f; lua_lock(L); if (ud) *ud = G(L)-\u0026gt;ud; f = G(L)-\u0026gt;frealloc; lua_unlock(L); return f; } LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud) { lua_lock(L); G(L)-\u0026gt;ud = ud; G(L)-\u0026gt;frealloc = f; lua_unlock(L); }   Code Snippet 5: lapi.c  generic api #  核心 api 定义之后，其它上层方法不过是对它的封装。\n  lmem.h 对外提供了诸多函数和宏，依赖关系如图示，这里简要介绍图中标识的 3 个方法，其余留给读者自行阅读。\nluaM_realloc_ #  对核心 api 进行了封装，检测函数错误，以及计算 totalbytes，为其它方法提供了基础。\n73 74 75 76 77 78 79 80 81 82 83 84 85  /* ** generic allocation routine. */ void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) { global_State *g = G(L); lua_assert((osize == 0) == (block == NULL)); block = (*g-\u0026gt;frealloc)(g-\u0026gt;ud, block, osize, nsize); if (block == NULL \u0026amp;\u0026amp; nsize \u0026gt; 0) luaD_throw(L, LUA_ERRMEM); lua_assert((nsize == 0) == (block == NULL)); g-\u0026gt;totalbytes = (g-\u0026gt;totalbytes - osize) + nsize; return block; }   Code Snippet 6: lmem.c  luaM_rellocv #  这个方法是一个宏，其中参数含义为\n L -\u0026gt; lua_State b -\u0026gt; block pointer on -\u0026gt; old number n n -\u0026gt; new number n e -\u0026gt; elem size   19 20 21 22  #define luaM_reallocv(L,b,on,n,e) \\ ((cast(size_t, (n)+1) \u0026lt;= MAX_SIZET/(e)) ? /* +1 to avoid warnings */\\ luaM_realloc_(L, (b), (on)*(e), (n)*(e)) : \\ luaM_toobig(L))   Code Snippet 7: lmem.h  可以看出，这个宏在 luaM_realloc_ 的基础上，方便对多元素数组进行内存分配，省去重复手动计算内存大小的困扰。\n其中有一个细节，使用 n+1 和 MAX_SIZET/e 进行比较，而非使用 (n+1) * e 和 MAX_SIZET 进行比较， 因为 size_t 是无符号类型，先进行除法来避免比较时溢出。\nluaM_growaux_ #  这个方法在 luaM_rellocv 的基础上，添加了 limit 的限制。\n最小不能小于 4， 最大不能超过 limit，按 2 倍速度进行内存 grow，适用于管理 类 vector 结构 。\n46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  void *luaM_growaux_ (lua_State *L, void *block, int *size, size_t size_elems, int limit, const char *errormsg) { void *newblock; int newsize; if (*size \u0026gt;= limit/2) { /* cannot double it? */ if (*size \u0026gt;= limit) /* cannot grow even a little? */ luaG_runerror(L, errormsg); newsize = limit; /* still have at least one free place */ } else { newsize = (*size)*2; if (newsize \u0026lt; MINSIZEARRAY) newsize = MINSIZEARRAY; /* minimum size */ } newblock = luaM_reallocv(L, block, *size, newsize, size_elems); *size = newsize; /* update only when everything else is OK */ return newblock; }   Code Snippet 8: lmem.c  practice #  本章并不复杂，明确了上面的基础，剩下的方法并不难理解。\n   文件 建议     lmem.h 仔细阅读   lmem.c 仔细阅读    "});index.add({'id':15,'href':'/lua-5.1-source-guide/docs/object/','title':"object",'section':"Docs",'content':"lua 是一种动态类型语言，类型不存在于变量中，而存在于值本身。\n语言中定义了 8 种类型的值\n nil bool number string table function userdata thread  虽然章节名称为 object，和源代码的名称相同。 但是通常都翻译为“对象”，容易与 OOP 中的对象概念混杂在一起。 在本章，更乐意将其译为“值”。\n从某种角度而言，程序就是“数据”与“操作数据的方法”。 所以第一步，先来了解 lua 中的值。\ntagged value #  章节开始就提到，类型存在于值本身。 在 lua 内部，用 TValue（tagged value）结构表示值的概念。\n67 68 69 70 71 72 73 74 75  /* ** Tagged Values */ #define TValuefields\tValue value; int tt  typedef struct lua_TValue { TValuefields; } TValue;   Code Snippet 1: lobject.h  tt 表示值的类型，value 表示值的数据。 明显地，类型是值的一部分。\n  type #  在 TValue 中，类型 tt 用 int 来标识，可以在代码中看到所有基础类型的宏定义\n69 70 71 72 73 74 75 76 77 78 79 80 81 82  /* ** basic types */ #define LUA_TNONE\t(-1)  #define LUA_TNIL\t0 #define LUA_TBOOLEAN\t1 #define LUA_TLIGHTUSERDATA\t2 #define LUA_TNUMBER\t3 #define LUA_TSTRING\t4 #define LUA_TTABLE\t5 #define LUA_TFUNCTION\t6 #define LUA_TUSERDATA\t7 #define LUA_TTHREAD\t8   Code Snippet 2: lua.h  完全对应 lua 中的 8 种类型。\n同时定义了相应的宏，方便检测值的类型。\n78 79 80 81 82 83 84 85 86 87 88 89 90  /* Macros to test type */ #define ttisnil(o)\t(ttype(o) == LUA_TNIL) #define ttisnumber(o)\t(ttype(o) == LUA_TNUMBER) #define ttisstring(o)\t(ttype(o) == LUA_TSTRING) #define ttistable(o)\t(ttype(o) == LUA_TTABLE) #define ttisfunction(o)\t(ttype(o) == LUA_TFUNCTION) #define ttisboolean(o)\t(ttype(o) == LUA_TBOOLEAN) #define ttisuserdata(o)\t(ttype(o) == LUA_TUSERDATA) #define ttisthread(o)\t(ttype(o) == LUA_TTHREAD) #define ttislightuserdata(o)\t(ttype(o) == LUA_TLIGHTUSERDATA)  /* Macros to access values */ #define ttype(o)\t((o)-\u0026gt;tt)   Code Snippet 3: lobject.h  细心如你，一定发现多出了一种 lightuserdata 类型。 这是由 userdata 细分出来的一种类型，目前先不做细致的解释， 之后到相应章节再具体分析。\nvalue #  TValue 中，数据 value 用 union Value 结构来表示，有效利用内存空间。\n56 57 58 59 60 61 62 63 64  /* ** Union of all Lua values */ typedef union { GCObject *gc; void *p; lua_Number n; int b; } Value;   Code Snippet 4: lobject.h  不同类型的数据使用不同的键值来存取。\n  detail #  下面针对不同类型的值，详细分析。\nnil #  nil 是最简单的值，表示没有值。 由于只表示一个含义，故不需要 value，只用 tt 记录类型即可。\n27  const TValue luaO_nilobject_ = {{NULL}, LUA_TNIL};   Code Snippet 5: lobject.c  363 364 365  #define luaO_nilobject\t(\u0026amp;luaO_nilobject_)  LUAI_DATA const TValue luaO_nilobject_;   Code Snippet 6: lobject.h  可以看出，nil 值在内部是一个单例，所有使用 nil 的地方，都通过 luaO_nilobject 来引用。\n  bool #  和其它语言一样，bool 值记录 true 和 false。\n在存储的安排上，使用 tt 记录类型，用 value 中的 int b = 1/0 表示 true/false。\n  light userdata #  light userdata 表示 c 和 lua 协同时，由 c 一方传入的数据。 lua 内部只负责引用，而不负责其生命周期管理，什么时候应该释放，lua 不清楚也不过问。\n所以内部在用 tt 记录类型之后，只用 value 中 void * p 引用即可。\n  number #  在默认设置下，lua 语言中所有数字都用 double 来表示。\n495 496 497 498 499 500 501 502 503 504 505  /* ** {================================================================== @@ LUA_NUMBER is the type of numbers in Lua. ** CHANGE the following definitions only if you want to build Lua ** with a number type different from double. You may also need to ** change lua_number2int \u0026amp; lua_number2integer. ** =================================================================== */ #define LUA_NUMBER_DOUBLE #define LUA_NUMBER\tdouble   Code Snippet 7: luaconf.h  98 99  /* type of numbers in Lua */ typedef LUA_NUMBER lua_Number;   Code Snippet 8: lua.h  类似的，用 tt 记录类型，用 value 中 lua_Number n 来记录 number 数值。\n  collectable #  上面几种类型的值，内部表示都相对简单，剩余几种类型的数据就相对复杂一些。\n string table function userdata thread  有一点是共通的，它们同属于可 gc 的值（iscollectable）。\n189  #define iscollectable(o)\t(ttype(o) \u0026gt;= LUA_TSTRING)   Code Snippet 9: lobject.h    lua 内建了 gc 机制，其中关键的结构是 GCObject ， 用于表示所有 iscollectable 的值。\nGCObject 是 union 结构，和 Value 结构类似，内部键值用于存取不同类型的数据。\n133 134 135 136 137 138 139 140 141 142 143 144 145  /* ** Union of all collectable objects */ union GCObject { GCheader gch; union TString ts; union Udata u; union Closure cl; struct Table h; struct Proto p; struct UpVal uv; struct lua_State th; /* thread */ };   Code Snippet 10: lstate.h  如果仔细观察内部内存的安排，会发现这种方式是非常巧妙的。\n  gch h p uv th 都是 struct，头部的字段都是 CommonHeader。\n39 40 41 42 43 44 45 46 47 48 49 50 51  /* ** Common Header for all collectable objects (in macro form, to be ** included in other objects) */ #define CommonHeader\tGCObject *next; lu_byte tt; lu_byte marked  /* ** Common header in struct form */ typedef struct GCheader { CommonHeader; } GCheader;   Code Snippet 11: lobject.h  338 339 340 341 342 343 344 345 346 347 348  typedef struct Table { CommonHeader; lu_byte flags; /* 1\u0026lt;\u0026lt;p means tagmethod(p) is not present */ lu_byte lsizenode; /* log2 of size of `node\u0026#39; array */ struct Table *metatable; TValue *array; /* array part */ Node *node; Node *lastfree; /* any free position is before this position */ GCObject *gclist; int sizearray; /* size of `array\u0026#39; array */ } Table;   228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253  /* ** Function Prototypes */ typedef struct Proto { CommonHeader; TValue *k; /* constants used by the function */ Instruction *code; struct Proto **p; /* functions defined inside the function */ int *lineinfo; /* map from opcodes to source lines */ struct LocVar *locvars; /* information about local variables */ TString **upvalues; /* upvalue names */ TString *source; int sizeupvalues; int sizek; /* size of `k\u0026#39; */ int sizecode; int sizelineinfo; int sizep; /* size of `p\u0026#39; */ int sizelocvars; int linedefined; int lastlinedefined; GCObject *gclist; lu_byte nups; /* number of upvalues */ lu_byte numparams; lu_byte is_vararg; lu_byte maxstacksize; } Proto;   270 271 272 273 274 275 276 277 278 279 280 281 282 283 284  /* ** Upvalues */ typedef struct UpVal { CommonHeader; TValue *v; /* points to stack or to its own value */ union { TValue value; /* the value (when closed) */ struct { /* double linked list (when open) */ struct UpVal *prev; struct UpVal *next; } l; } u; } UpVal;   97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127  /* ** `per thread\u0026#39; state */ struct lua_State { CommonHeader; lu_byte status; StkId top; /* first free slot in the stack */ StkId base; /* base of current function */ global_State *l_G; CallInfo *ci; /* call info for current function */ const Instruction *savedpc; /* `savedpc\u0026#39; of current function */ StkId stack_last; /* last free slot in the stack */ StkId stack; /* stack base */ CallInfo *end_ci; /* points after end of ci array*/ CallInfo *base_ci; /* array of CallInfo\u0026#39;s */ int stacksize; int size_ci; /* size of array `base_ci\u0026#39; */ unsigned short nCcalls; /* number of nested C calls */ unsigned short baseCcalls; /* nested C calls when resuming coroutine */ lu_byte hookmask; lu_byte allowhook; int basehookcount; int hookcount; lua_Hook hook; TValue l_gt; /* table of globals */ TValue env; /* temporary place for environments */ GCObject *openupval; /* list of open upvalues in this stack */ GCObject *gclist; struct lua_longjmp *errorJmp; /* current error recover point */ ptrdiff_t errfunc; /* current error handling function (stack index) */ };   Code Snippet 12: lstate.h  ts u cl 虽然是 union，但是其中多余的字段是用于对齐的，实质还是 struct。\n196 197 198 199 200 201 202 203 204 205 206 207  /* ** String headers for string table */ typedef union TString { L_Umaxalign dummy; /* ensures maximum alignment for strings */ struct { CommonHeader; lu_byte reserved; unsigned int hash; size_t len; } tsv; } TString;   Code Snippet 13: lobject.h  215 216 217 218 219 220 221 222 223  typedef union Udata { L_Umaxalign dummy; /* ensures maximum alignment for `local\u0026#39; udata */ struct { CommonHeader; struct Table *metatable; struct Table *env; size_t len; } uv; } Udata;   287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312  /* ** Closures */ #define ClosureHeader \\ CommonHeader; lu_byte isC; lu_byte nupvalues; GCObject *gclist; \\ struct Table *env  typedef struct CClosure { ClosureHeader; lua_CFunction f; TValue upvalue[1]; } CClosure; typedef struct LClosure { ClosureHeader; struct Proto *p; UpVal *upvals[1]; } LClosure; typedef union Closure { CClosure c; LClosure l; } Closure;   GCObject 将类型重新备份了一份，GCHeader 中的 tt 和 TValue 中的 tt 是相同的。\n105 106 107 108 109  /* ** for internal debug only */ #define checkconsistency(obj) \\ lua_assert(!iscollectable(obj) || (ttype(obj) == (obj)-\u0026gt;value.gc-\u0026gt;gch.tt))   Code Snippet 14: lobject.h  这样的话，GCObject 可以脱离 TValue，使用 GCHeader gch 先来读取 tt，再根据 tt 来使用不同的键值来引用数据。\n148 149 150 151 152 153 154 155 156 157 158 159  /* macros to convert a GCObject into a specific value */ #define rawgco2ts(o)\tcheck_exp((o)-\u0026gt;gch.tt == LUA_TSTRING, \u0026amp;((o)-\u0026gt;ts)) #define gco2ts(o)\t(\u0026amp;rawgco2ts(o)-\u0026gt;tsv) #define rawgco2u(o)\tcheck_exp((o)-\u0026gt;gch.tt == LUA_TUSERDATA, \u0026amp;((o)-\u0026gt;u)) #define gco2u(o)\t(\u0026amp;rawgco2u(o)-\u0026gt;uv) #define gco2cl(o)\tcheck_exp((o)-\u0026gt;gch.tt == LUA_TFUNCTION, \u0026amp;((o)-\u0026gt;cl)) #define gco2h(o)\tcheck_exp((o)-\u0026gt;gch.tt == LUA_TTABLE, \u0026amp;((o)-\u0026gt;h)) #define gco2p(o)\tcheck_exp((o)-\u0026gt;gch.tt == LUA_TPROTO, \u0026amp;((o)-\u0026gt;p)) #define gco2uv(o)\tcheck_exp((o)-\u0026gt;gch.tt == LUA_TUPVAL, \u0026amp;((o)-\u0026gt;uv)) #define ngcotouv(o) \\ check_exp((o) == NULL || (o)-\u0026gt;gch.tt == LUA_TUPVAL, \u0026amp;((o)-\u0026gt;uv)) #define gco2th(o)\tcheck_exp((o)-\u0026gt;gch.tt == LUA_TTHREAD, \u0026amp;((o)-\u0026gt;th))   Code Snippet 15: lstate.h  至于不同类型的数据如何记录，在后面会分章节讨论。\ninternal #  细心如你，一定又发现了，GCObject 中除了 gch，多出了 p uv，是 8 种类型之外的。\n事实上，在 thread 之后，新定义了 3 个类型，同属于 iscollectable，只用于内部使用\n proto upval deadkey   19 20 21 22 23 24 25 26 27 28 29 30  /* tags for values visible from Lua */ #define LAST_TAG\tLUA_TTHREAD  #define NUM_TAGS\t(LAST_TAG+1)  /* ** Extra tags for non-values */ #define LUA_TPROTO\t(LAST_TAG+1) #define LUA_TUPVAL\t(LAST_TAG+2) #define LUA_TDEADKEY\t(LAST_TAG+3)   Code Snippet 16: lobject.h  proto 和 upval 就对应 GCObject 中多出的 2 个键值 p uv， 至于 deadkey，到特定章节再讨论。\npractice #     文件 建议 描述     lobject.h 仔细阅读 这个文件非常关键，除了定义了关键的数据结构之外，还定义了大量的宏辅助数据操作   lstate.h 浏览阅读 其中定义了和运行时状态相关的数据结构，尽量理解，加深印象   lobject.c 可以阅读 实现了 lobject.h 中声明的方法，并非核心内容    "});index.add({'id':16,'href':'/lua-5.1-source-guide/docs/overview/','title':"overview",'section':"Docs",'content':"goal #  这是一本关于 lua 5.1 源代码的小书。 主要探索 lua 源代码，从中研究 lua 语言的内部实现。\n起因是出于好奇和乐趣，同时希望对其它 source reader 有所启发。\nlua 本身虽然只有几万行代码，但是将其所有细节都描述清楚还是要花费不少篇幅。 而且我也不自信自己的文字能力能将其含义描述清楚。\n所以在本书中，\n 根据 2/8 原则，关注重点部分 一图胜千言，尽量使用图解 其余相关源代码，作为读者的练习  每一本书都有适合的读者，本书也是如此。\n希望读者你\n 使用过 lua 语言，了解 lua 了解 Linux 基础使用 熟悉 C 语言  因为本书就是建立在相应的前提下书写的。\nproject #  file structure #     file/dir desc     lua-5.1.5/ lua 源代码   install/ 编译 lua 源代码的结果，安装当前目录   tool/ 一些第三方辅助工具   draft/ 本书草稿   book/ 本书发布内容，org 格式   docs/ 本书发布内容，html 格式   opcode/ 关于 opcode 的测试代码   statement/ 关于 statement 的测试代码   test/ 关于其它功能的测试代码   helper.py gdb 脚本，辅助打印数据结构   init.gdb gdb 脚本，用作调试入口   lex.gdb gdb 脚本，实现粗糙的词法分析器   publish.el org 生成 html 的配置文件   Makefile makefile，简化一些命令调用   readme.org readme    source code #  出于方便修改源代码进行调试的原因，将 lua 5.1 source code 下载并保存在项目的 lua-5.1.5/ 目录中， 统一管理。\ndiff -ur /home/manjaro/temp/lua-5.1.5/Makefile ../lua-5.1.5/Makefile --- /home/manjaro/temp/lua-5.1.5/Makefile\t2012-02-10 17:50:23.000000000 +0800 +++ ../lua-5.1.5/Makefile\t2020-09-16 16:59:20.010277348 +0800 @@ -9,7 +9,7 @@  # Where to install. The installation starts in the src and doc directories, # so take care if INSTALL_TOP is not an absolute path. -INSTALL_TOP= /usr/local +INSTALL_TOP= $(CURDIR)/../install  INSTALL_BIN= $(INSTALL_TOP)/bin INSTALL_INC= $(INSTALL_TOP)/include INSTALL_LIB= $(INSTALL_TOP)/lib diff -ur /home/manjaro/temp/lua-5.1.5/src/Makefile ../lua-5.1.5/src/Makefile --- /home/manjaro/temp/lua-5.1.5/src/Makefile\t2012-02-14 04:41:22.000000000 +0800 +++ ../lua-5.1.5/src/Makefile\t2020-11-18 14:45:06.879322946 +0800 @@ -8,7 +8,7 @@  PLAT= none CC= gcc -CFLAGS= -O2 -Wall $(MYCFLAGS) +CFLAGS= -m32 -ggdb3 -O0 -Wall $(MYCFLAGS)  AR= ar rcu RANLIB= ranlib RM= rm -f @@ -30,7 +30,7 @@ \tlstrlib.o loadlib.o linit.o LUA_T=\tlua -LUA_O=\tlua.o +LUA_O=\tlua.o print.o  LUAC_T=\tluac LUAC_O=\tluac.o print.o @@ -52,10 +52,10 @@ \t$(RANLIB) $@ $(LUA_T): $(LUA_O) $(LUA_A) -\t$(CC) -o $@ $(MYLDFLAGS) $(LUA_O) $(LUA_A) $(LIBS) +\t$(CC) $(CFLAGS) -o $@ $(MYLDFLAGS) $(LUA_O) $(LUA_A) $(LIBS)  $(LUAC_T): $(LUAC_O) $(LUA_A) -\t$(CC) -o $@ $(MYLDFLAGS) $(LUAC_O) $(LUA_A) $(LIBS) +\t$(CC) $(CFLAGS) -o $@ $(MYLDFLAGS) $(LUAC_O) $(LUA_A) $(LIBS)  clean: $(RM) $(ALL_T) $(ALL_O) 其中对 ./lua-5.1.5/Makefile 做了 1 处修改，\n 将 lua 安装目录修改到本地 ./install/  其中对 ./lua-5.1.5/src/Makefile 做了 4 处修改，\n 增加编译选项  -m32 使用 32 位编译 -ggdb3 -O0 提供更多调试信息，可调试 #define 宏   将 print.c 编译到 lua 解释器中 使用新编译选项，编译 lua 解释器 使用新编译选项，编译 lua 编译器  tool #  在分析代码的过程中，使用了一些三方工具。\n出于方便环境配置的原因，将其拷贝放置在了 tool/ 目录中。\n ChunkSpy 是一个 lua 项目，用于分析并显示由 luac 编译得来的二进制 chunk 的内部结构， 可以方便的了解编译结果，尤其是生成的字节码。\n只在 /home/manjaro/temp/ChunkSpy-0.9.8 存在：5.0.2 diff -ur /home/manjaro/temp/ChunkSpy-0.9.8/5.1/ChunkSpy.lua ../tool/ChunkSpy-0.9.8/5.1/ChunkSpy.lua --- /home/manjaro/temp/ChunkSpy-0.9.8/5.1/ChunkSpy.lua\t2006-03-07 18:56:48.000000000 +0800 +++ ../tool/ChunkSpy-0.9.8/5.1/ChunkSpy.lua\t2020-10-30 11:55:50.229435825 +0800 @@ -1631,8 +1631,8 @@  FormatLine(1, \u0026#34;numparams (\u0026#34;..func.numparams..\u0026#34;)\u0026#34;, pos + 1) FormatLine(1, \u0026#34;is_vararg (\u0026#34;..func.is_vararg..\u0026#34;)\u0026#34;, pos + 2) FormatLine(1, \u0026#34;maxstacksize (\u0026#34;..func.maxstacksize..\u0026#34;)\u0026#34;, pos + 3) - BriefLine(string.format(\u0026#34;; %d upvalues, %d params, %d stacks\u0026#34;, - func.nups, func.numparams, func.maxstacksize)) + BriefLine(string.format(\u0026#34;; %d upvalues, %d params, %d is_vararg, %d stacks\u0026#34;, + func.nups, func.numparams, func.is_vararg, func.maxstacksize))  BriefLine(string.format(\u0026#34;.function%s%d %d %d %d\u0026#34;, config.DISPLAY_SEP, func.nups, func.numparams, func.is_vararg, func.maxstacksize)) 同样的，对源代码做了些许修改\n 删除不需要的 5.0.2 版本代码 增加显示 is_vararg 字段   ditaa 是一个命令行工具，用于将 ascii art 图形转化为图片，用于辅助生成图解。\n lua-gdb-helper 是一个 gdb 脚本项目，用于辅助调试，打印关键数据结构。 在进行本书编写过程中，借鉴了其中的思想，使用 gdb 提供的 python api， 编写了 helper.py 来辅助显示数据结构。\nusage #  在分析代码的过程，经常使用一些分析过程，全部整理在 Makefile 中。\n在此做一些介绍，对理解代码是非常有用的。\ncompile #  $ make compile 在 linux 系统上，使用 gcc 编译 lua 源代码，生成\n lua 解释器 ./lua-5.1.5/src/lua lua 编译器 ./lua-5.1.5/src/luac  并将相关文件安装到 ./install 目录\n$ make clean 删除 gcc 编译生成结果\nrun #  $ make lua 交互模式，执行 lua 解释器\n$ make run source=opcode/move.lua 使用 lua 解释器执行文件 opcode/move.lua\ninspect #  $ make lex source=opcode/move.lua 对文件进行词法分析\n$ make spy 交互模式，执行 ChunkSpy\n$ make inspect source=opcode/move.lua 使用 ChunkSpy 分析文件\ndebug #  $ make debug source=opcode/move.lua 开始调试文件，临时断点在 function chunk()\npublish #  $ make publish 将 book/ 下 org 文件发布为 docs/ 目录下的 html 文件\n$ make server 在本地开启 http server，阅读生成的 html 文件\nbig picture #  source file #  在阅读源代码之前，先对相关代码文件有一个总体感觉。\nlua 源代码的核心文件都在 ./lua-5.1.5/src/ 目录， 按照本书目录的顺序，将相关文件列示如下。\n   file prefix desc     Makefile  makefile   llimits.h  部分常量与类型定义   luaconf.h  lua 核心配置文件，提供部分功能定制   lua.h lua 主要头文件，提供对外的接口   lua.c  lua 解释器   luac.c  lua 编译器   print.c  提供打印 chunk 的方法，用于 luac -l   lobject.h luaO 定义基础数据类型，及相关宏操作   lobject.c luaO -   lmem.h luaM mem 功能   lmem.c luaM -   lstring.h luaS string 功能   lstring.c luaS -   ltable.h luaH table 功能   ltable.c luaH -   ltm.h luaT metatable(tag method) 功能   ltm.c luaT -   lzio.h luaZ buffer \u0026amp; stream 功能   lzio.c luaZ -   llex.h luaX lexer 功能   llex.c luaX -   lparser.h luaY parser 功能   lparser.c luaY -   lopcodes.h luaP opcode 定义及相关宏操作   lopcodes.c luaP -   lcode.h luaK code 模块，用于生成 opcode   lcode.c luaK -   lfunc.h luaF Proto, Closure, Upval 相关的基础操作   lfunc.c luaF -   ldo.h luaD 调用 Lua/C Closure   ldo.c luaD -   lstate.h luaE lua_State, global_State 相关定义与操作   lstate.c luaE -   lvm.h luaV vm 功能   lvm.c luaV -   lapi.h luaA api 功能，提供对外 api 接口的实现   lapi.c luaA -   lauxlib.h luaL 为 lua lib 提供基础方法   lauxlib.c luaL -   lualib.h  定义 lua std lib 的注册接口   linit.c luaL 实现注册所有 std lib 方法   lbaselib.c luaB base lib，实现 print, next, etc 及 coroutine.* 接口   loadlib.c  package lib，实现 require, moduel 及 package.* 接口   ltablib.c  table lib，实现 table.* 接口   liolib.c  io lib，实现 io.* 接口   loslib.c  os lib，实现 os.* 接口   lstrlib.c  string lib，实现 string.* 接口   lmathlib.c  math lib，实现 math.* 接口   ldblib.c  debug lib，实现 debug.* 接口   ldebug.h luaG debug 功能，用于自省   ldebug.c luaG -   lgc.h luaC gc 功能   lgc.c luaC -   lundump.h luaU dump/undump 功能，chunk 的保存与加载   lundump.c luaU -   ldump.c luaU -    大部分模块，都有对应的 .h .c 文件， 大致来看， .h 定义数据结构，宏操作，及函数接口， .c 实现函数接口。 两者协同提供一个模块功能，所以相关的文件描述用 - 来代替了。\n模块 .h 文件中定义的函数接口，是可以被其它模块引用的。 lua 内部使用了一种命名约定，不同模块的函数接口用不同的前缀来标识， 在上表中的 prefix 列已经列示。\n当然，上面的规则不是绝对的，存在部分例外，在阅读时不必严格拘束于此。\nexecution #  同是编程语言，必定有相似的地方。 下面从 C 语言的角度，粗略类比 Lua 语言的执行过程。\n  C 代码通过编译过程，生成可执行文件；可执行文件被机器执行，达成 C 代码描述的语义。\n  Lua 语言通过 compile dump 过程，生成特定格式的二进制文件； 二进制文件可以被加载，并在 VM 中执行，达成 Lua 代码描述的语义。\n如果抽象来看，编程语言是一种语言，一种文本约定，描述程序的语义。 实现语义的程序，称之为编程语言的实现。\nC（语言）通过 gcc（实现）来达成语义，同样地，Lua（语言）需要一个（实现），才能达成语义。\n./lua-5.1.5/src/ 就是这个实现的全部内容。\n虽然大体流程相似，作为编译型语言的 C 和解释型的 Lua 还是存在些许不同。\nC 语言直接编译为面向机器的指令，整体是静态的，一次性全部编译完成，整体加载运行。\nLua 语言的编译面向 VM，生成 opcode 交由 VM 来执行，VM 则由 Machine 来执行，整体多了一层中间层 VM。\nlua 源代码 make 之后，生成两个可执行文件\n lua, lua standalone interpreter luac, lua compiler  luac 程序执行的就是 compile + dump 的过程\nlua 程序根据参数不同，可能会执行\n compile + executed 过程 undump + executed 过程 VM 常驻内存，使用 REPL 的方式，不断输入 lua code，执行 compile + executed 的解释过程  这即是上文中两个程序分别称为编译器 和 解释器 的命名来源，以后的行文中也使用这种约定。\nTODO a little tour #  chain all subject\n big picture of internal talk about lua state and global state, state scope  practice #   按照 source file 章节中提到的文件顺序，粗略浏览所有代码  "});index.add({'id':17,'href':'/lua-5.1-source-guide/docs/example/collapsed/3rd-level/4th-level/','title':"4th Level",'section':"3rd Level",'content':"4th Level of Menu #  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"});index.add({'id':18,'href':'/lua-5.1-source-guide/docs/example/collapsed/3rd-level/','title':"3rd Level",'section':"Collapsed",'content':"3rd Level of Menu #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  "});index.add({'id':19,'href':'/lua-5.1-source-guide/docs/example/hidden/','title':"Hidden",'section':"Example Site",'content':"This page is hidden in menu #  Quondam non pater est dignior ille Eurotas #  Latent te facies #  Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\n Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor  Cum honorum Latona #  O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); }  Fronde cetera dextrae sequens pennis voce muneris #  Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); "});index.add({'id':20,'href':'/lua-5.1-source-guide/docs/shortcodes/buttons/','title':"Buttons",'section':"Shortcodes",'content':"Buttons #  Buttons are styled links that can lead to local page or external link.\nExample #  {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Get Home  Contribute  "});index.add({'id':21,'href':'/lua-5.1-source-guide/docs/shortcodes/columns/','title':"Columns",'section':"Shortcodes",'content':"Columns #  Columns help organize shorter pieces of content horizontally for readability.\n{{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}} Example #  Left Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.  Mid Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!  Right Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.   "});index.add({'id':22,'href':'/lua-5.1-source-guide/docs/shortcodes/details/','title':"Details",'section':"Shortcodes",'content':"Details #  Details shortcode is a helper for details html5 element. It is going to replace expand shortcode.\nExample #  {{\u0026lt; details \u0026#34;Title\u0026#34; [open] \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} {{\u0026lt; details title=\u0026#34;Title\u0026#34; open=true \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} Title Markdown content Lorem markdownum insigne\u0026hellip;   "});index.add({'id':23,'href':'/lua-5.1-source-guide/docs/shortcodes/expand/','title':"Expand",'section':"Shortcodes",'content':"Expand #  Expand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.\nExample #  Default #  {{\u0026lt; expand \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}   展开 ↕  Markdown content Lorem markdownum insigne\u0026hellip;    With Custom Label #  {{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}   Custom Label ...  Markdown content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.    "});index.add({'id':24,'href':'/lua-5.1-source-guide/docs/shortcodes/hints/','title':"Hints",'section':"Shortcodes",'content':"Hints #  Hint shortcode can be used as hint/alerts/notification block.\nThere are 3 colors to choose: info, warning and danger.\n{{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{\u0026lt; /hint \u0026gt;}} Example #  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  "});index.add({'id':25,'href':'/lua-5.1-source-guide/docs/shortcodes/katex/','title':"Katex",'section':"Shortcodes",'content':"KaTeX #  KaTeX shortcode let you render math typesetting in markdown document. See KaTeX\nExample #  {{\u0026lt; katex [display] [class=\u0026#34;text-center\u0026#34;] \u0026gt;}} f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi {{\u0026lt; /katex \u0026gt;}}     \\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\\]    Display Mode Example #  Here is some inline example:  \\(\\pi(x)\\)  , rendered in the same line. And below is display example, having display: block  \\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\\]  Text continues here.\n"});index.add({'id':26,'href':'/lua-5.1-source-guide/docs/shortcodes/mermaid/','title':"Mermaid",'section':"Shortcodes",'content':"Mermaid Chart #   Mermaid is library for generating svg charts and diagrams from text.\nExample #  {{\u0026lt; mermaid [class=\u0026#34;text-center\u0026#34;]\u0026gt;}} sequenceDiagram Alice-\u0026gt;\u0026gt;Bob: Hello Bob, how are you? alt is sick Bob-\u0026gt;\u0026gt;Alice: Not so good :( else is well Bob-\u0026gt;\u0026gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-\u0026gt;\u0026gt;Alice: Thanks for asking end {{\u0026lt; /mermaid \u0026gt;}}    mermaid.initialize({ \"flowchart\": { \"useMaxWidth\":true }, \"theme\": \"default\" } ) sequenceDiagram Alice-Bob: Hello Bob, how are you? alt is sick Bob-Alice: Not so good :( else is well Bob-Alice: Feeling fresh like a daisy end opt Extra response Bob-Alice: Thanks for asking end   "});index.add({'id':27,'href':'/lua-5.1-source-guide/docs/shortcodes/section/','title':"Section",'section':"Shortcodes",'content':"Section #  Section renders pages in section as definition list, using title and description.\nExample #  {{\u0026lt; section \u0026gt;}}   Page1   Page 1 #   Page2   Page 2 #   "});index.add({'id':28,'href':'/lua-5.1-source-guide/docs/shortcodes/section/page1/','title':"Page1",'section':"Section",'content':"Page 1 #  "});index.add({'id':29,'href':'/lua-5.1-source-guide/docs/shortcodes/section/page2/','title':"Page2",'section':"Section",'content':"Page 2 #  "});index.add({'id':30,'href':'/lua-5.1-source-guide/docs/shortcodes/tabs/','title':"Tabs",'section':"Shortcodes",'content':"Tabs #  Tabs let you organize content by context, for example installation instructions for each supported platform.\n{{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} Example #  MacOS MacOS This is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nLinux Linux This is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nWindows Windows This is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n "});})();