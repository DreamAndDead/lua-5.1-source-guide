#+SETUPFILE: setup.org

* DRAFT parser

前面提到，lua 为了效率，将 token -> bytecode 压缩到了一个过程中
没有 ast ir 等中间产物，直接从 token 到 opcode。

相对应的，这部分代码就相对难以理解。

#+CAPTION: lex -> parse -> gen picture


虽然代码实现没有明显的划分，在理解上，先找出不同步骤的影子，最后再联系在一起。

过程综合在一起，但是从语法分析作为入口开始分析的。
语法制导翻译的过程。

本章
- 语法分析过程
- debug 方法


** lang of lang
   :LOGBOOK:
   - Note taken on [2020-12-09 三 09:19] \\
     chunk vs block?
   :END:


官方文档使用上下文无关文法来描述 lua 语言。

[[http://www.lua.org/manual/5.1/manual.html#8]]

根据实际代码中的相关注释，代码的实现过程，做了一些修改，整理 EBNF 如下。

#+begin_example
{ a } 表示 a*，0 个或多个
[ a ] 表示 a?，0 个或一个
( a ) 表示组
  |   表示或

终结符：大写单词，`单字符' 是 lex 阶段生成的 token
非终结符：小写单词，以 chunk 为入口
#+end_example


#+begin_src bnf
  chunk        ::= { stat [ `;' ] }

  stat         ::= ifstat | whilestat | dostat | forstat | repeatstat |
		   funcstat | localstat | retstat | breakstat | exprstat

  ifstat       ::= IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END
  cond         ::= expr
  block        ::= chunk

  whilestat    ::= WHILE cond DO block END

  dostat       ::= DO block END

  forstat      ::= FOR (fornum | forlist) END
  fornum       ::= NAME = expr `,' expr [`,' expr] forbody
  forlist      ::= NAME {`,' NAME} IN explist forbody
  forbody      ::= DO block

  repeatstat   ::= REPEAT block UNTIL cond

  funcstat     ::= FUNCTION funcname body
  funcname     ::= NAME {`.' NAME} [`:' NAME]
  body         ::= `(' parlist `)' chunk END
  parlist      ::= [ DOTS | NAME {`,' NAME} [`,' DOTS] ]

  localstat    ::= LOCAL FUNCTION NAME body | LOCAL NAME {`,' NAME} [`=' explist]

  retstat      ::= RETURN [explist]

  breakstat    ::= BREAK

  exprstat     ::= prefixexp (funccallstat | assignstat)
  prefixexp    ::= NAME | `(' expr `)'

  funccallstat ::= primaryexp (`:' NAME funcargs | funcargs)
  funcargs     ::= `(' [ explist ] `)' | constructor | STRING

  assignstat   ::= primaryexp (`.' NAME | `[' expr `]') assignment
  assignment   ::= `,' assignstat | `=' explist

  primaryexp   ::= {`.' NAME | `[' expr `]' | `:' NAME funcargs | funcargs}


  explist      ::= expr {`,' expr}
  expr         ::= subexpr
  subexpr      ::= (simpleexp | unop subexpr) {binop subexpr}

  simpleexp    ::= NUMBER | STRING | NIL | TRUE | FALSE | DOTS |
		   constructor | FUNCTION body | primaryexp

  binop        ::= `+´ | `-´ | `*´ | `/´ | `^´ | `%´ | CONCAT | 
		   `<´ | LE | `>´ | GE | EQ | NE | AND | OR
  unop         ::= `-´ | NOT | `#´

  constructor  ::= `{' [fieldlist] `}'
  fieldlist    ::= field {fieldsep field} [fieldsep]
  field        ::= `[' expr `]' `=' expr | NAME `=' expr | expr
  fieldsep     ::= `,' | `;'
#+end_src

值得注意的是，和 lex 过程中的 RE 一样，没有正确表示 number ，而在 RE 之外进行了判断
ENBF 语法也存在这样的问题。

没有在语言描述层面对运算符优先级进行限定，而在 subexpr 过程中隐式实现。

** 递归下降

语法分析层面，整体使用递归下降过程。

每个非终结符都用一个同名函数来实现（有部分例外），
在整体运行过程中，函数之间的流程，就像是隐式的 ast 的遍历过程。

所有 opcode 的生成过程，就隐藏在这一个个函数中。

整体来看，
- 以 chunk 为入口
- 分为多个 stat
- 每个 stat 有独立的结构
- expr 是重要的组成部分

像一棵树形结构，从上至下。

分析过程，最好以 stat 为单位。

每个 stat 进行独立的分析。

最终再整合为宏观的理解。



*** TODO inspect with tool

luaY parser 是整体的入口

#+INCLUDE: ../lua-5.1.5/src/lparser.h src c :lines "383-399"

其中从 chunk 入口，递归完成整体分析

 break at chunk

 观察源代码

 观察 token

 n/s 观察代码的走向，只关注语法分析的过程

 e.g. localstat


 print *ls py extension


** practice

尝试随意的代码，在 chunk 处打上断点
n/s 观察代码的走向


