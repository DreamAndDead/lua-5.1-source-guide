#+SETUPFILE: setup.org

* TODO parser

- 上下文无关文法
  - 递归下降过程
    - funcname and ebnf symbol
  - caveats
    - binop precedence
    - ebnf naming
    - online manual/metalua/comments
- everything before generator


前面提到，lua 为了效率，将 token -> bytecode 压缩到了一个过程中
没有 ast ir 等中间产物，直接从 token 到 opcode。

相对应的，这部分代码就相对难以理解。

这一章先讲宏观的过程，在 gen 章节，再针对具体代码，进行 gen 的分析。

#+CAPTION: lex -> parse -> gen picture

** lang of lang

几乎所有 token 都可以使用 RE 表示，但是也有 RE 无法表示的情况

如 `a^kb^k`

但是用 上下文无关 文法就可以方便的表示
因为 上下文无关 文法提供了递归生成的方式




虽然过程综合在一起，还是从语法分析作为入口开始分析的。

语法分析，必须提到 EBNF 描述，lang of lang。
描述语言结构的语言。

综合官方文档和代码注释，以及实际生成的过程，整理 EBNF 如下。


递归下降，每个非终结符号都有一个对应的过程





因为使用 E，一些默认规则如下

#+begin_example
{ a } 表示 a*，0 个或多个
[ a ] 表示 a?，0 个或一个
( a ) 表示一个
| 表示或
大写 与 引号单字符 为 lex 阶段的 token
#+end_example


#+begin_src bnf
chunk        ::= { stat [ `;' ] }

stat         ::= ifstat | whilestat | dostat | forstat | repeatstat |
                 funcstat | localstat | retstat | breakstat | exprstat

ifstat       ::= IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END
cond         ::= expr
block        ::= chunk

whilestat    ::= WHILE cond DO block END

dostat       ::= DO block END

forstat      ::= FOR (fornum | forlist) END
fornum       ::= NAME = expr `,' expr [`,' expr] forbody
forlist      ::= NAME {`,' NAME} IN explist forbody
forbody      ::= DO block

repeatstat   ::= REPEAT block UNTIL cond

funcstat     ::= FUNCTION funcname body
funcname     ::= NAME {`.' NAME} [`:' NAME]
body         ::= `(' parlist `)' chunk END
parlist      ::= [ NAME {`,' NAME} [ DOTS ] ]

localstat    ::= LOCAL FUNCTION NAME body | LOCAL NAME {`,' NAME} [`=' explist]

retstat      ::= RETURN [explist]

breakstat    ::= BREAK

exprstat     ::= prefixexp (funccallstat | assignstat)
prefixexp    ::= NAME | `(' expr `)'

funccallstat ::= primaryexp (`:' NAME funcargs | funcargs)
funcargs     ::= `(' [ explist ] `)' | constructor | STRING

assignstat   ::= primaryexp (`.' NAME | `[' expr `]') assignment
assignment   ::= `,' assignstat | `=' explist

primaryexp   ::= {`.' NAME | `[' expr `]' | `:' NAME funcargs | funcargs}


explist      ::= expr {`,' expr}
expr         ::= subexpr
subexpr      ::= (simpleexp | unop subexpr) {binop subexpr}

simpleexp    ::= NUMBER | STRING | NIL | TRUE | FALSE | DOTS |
                 constructor | FUNCTION body | primaryexp

binop        ::= `+´ | `-´ | `*´ | `/´ | `^´ | `%´ | CONCAT | 
	         `<´ | LE | `>´ | GE | EQ | NE |	AND | OR
unop         ::= `-´ | NOT | `#´

constructor  ::= `{' [fieldlist] `}'
fieldlist    ::= field {fieldsep field} [fieldsep]
field        ::= `[' expr `]' `=' expr | NAME `=' expr | expr
fieldsep     ::= `,' | `;'
#+end_src




ENBF 语法并没有给出完全的限制

subexpr 中进行了比较级的限制（唉，EBNF）


虽然是递归下降，但是各个名称和 函数名称不一定是对应的

explist1 -> explist

并没有描述算术运算的优先级，和 number 一样，是在底层另行实现的。


函数的流程，像是字面意义上的 ast。

函数名与 left hand 同名，方便理清 ast 层面的逻辑。

但是具体的同义生成过程，还需要一番思索。

*** 递归下降
    :LOGBOOK:
    - Note taken on [2020-12-07 一 13:44] \\
    递归下降法与 LL 1 的关系？
    :END:

 lua 使用上下文无关方法描述，且使用 LL 1 方式，进行递归下降法，进行语法分析。

 和通常所见的不同，直接从这个过程中生成了 opcode，而不是 ast ir 之类。

 由于递归下降的特性，大部分函数名和相应的规则相同，所以相应的过程就比较容易梳理。
 但是并不完全，也有一些不完美的地方。

可以逐个模块进行分析


*** inspect

gdb py 插件的介绍

** practice

尝试随意的代码，在 chunk 处打上断点
n/s 观察代码的走向


