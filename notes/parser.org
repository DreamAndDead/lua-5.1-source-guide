#+SETUPFILE: setup.org

* TODO parser

- job
  - token -> ... -> bytecode
  - generic step (no generate)
- 上下文无关文法
  - EBNF
  - LL 1
  - 递归下降过程
    - funcname and ebnf symbol
  - caveats
    - binop precedence
    - ebnf naming
    - online manual/metalua/comments
- everything before generator


** intro

ast 过程可以理解为，在递归下降的过程中发现

至于 ir，由于没有跨平台实现的需求，也可以不考虑（只针对 lua vm 实现）


如果使用多趟式的处理过程，则需要一次完整的遍历
token 数组，交给 parser

lua 使用了流式的处理过程，提供核心的方法，next，供 parser 按需使用
核心使用的便是 lexstate


#+CAPTION: lex -> parse -> gen picture

** EBNF lang of lang

#+begin_example
{ a } 表示 a*，0 个或多个
[ a ] 表示 a?，0 个或一个
( a ) 表示一个
| 表示或
#+end_example


#+begin_src
chunk -> { stat [ `;' ] }

stat -> ifstat | whilestat | dostat | forstat | repeatstat |
        funcstat | localstat | retstat | breakstat | exprstat

ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END
cond -> expr
block -> chunk

whilestat -> WHILE cond DO block END

dostat -> DO block END

forstat -> FOR (fornum | forlist) END
fornum -> NAME = expr `,' expr [`,' expr] forbody
forlist -> NAME {`,' NAME} IN explist forbody
forbody -> DO block

repeatstat -> REPEAT block UNTIL cond

funcstat -> FUNCTION funcname body
funcname -> NAME {`.' NAME} [`:' NAME]
body -> `(' parlist `)' chunk END
parlist -> [ NAME {`,' NAME} [ DOTS ] ]

localstat -> LOCAL FUNCTION NAME body | LOCAL NAME {`,' NAME} [`=' explist]

retstat -> RETURN [explist]

breakstat -> BREAK

exprstat -> prefixexp (funccallstat | assignstat)
prefixexp -> NAME | `(' expr `)'

funccallstat -> primaryexp (`:' NAME funcargs | funcargs)
funcargs -> `(' [ explist ] `)' | constructor | STRING

assignstat -> primaryexp (`.' NAME | `[' expr `]') assignment
assignment -> `,' assignstat | `=' explist

primaryexp -> {`.' NAME | `[' expr `]' | `:' NAME funcargs | funcargs}


explist -> expr {`,' expr}
expr -> subexpr              ; 在 subexpr 中进行了比较级的限制（唉，EBNF）
subexpr -> (simpleexp | unop subexpr) {binop subexpr}

simpleexp -> NUMBER | STRING | NIL | TRUE | FALSE | DOTS |
             constructor | FUNCTION body | primaryexp

binop -> `+´ | `-´ | `*´ | `/´ | `^´ | `%´ | CONCAT | 
	`<´ | LE | `>´ | GE | EQ | NE |	AND | OR
unop -> `-´ | NOT | `#´

constructor -> `{' [fieldlist] `}'
fieldlist -> field {fieldsep field} [fieldsep]
field -> `[' expr `]' `=' expr | NAME `=' expr | expr
fieldsep -> `,' | `;'
#+end_src


ENBF 语法并没有给出完全的限制

虽然是递归下降，但是各个名称和 函数名称不一定是对应的


explist1 -> explist



对于 char 到 token 有明显的分辨力，从 token 到 ast 也还可以
但是从 ast 到 bytecode 就差一些

因为
- 流程的实现
- 寄存器的分配

涉及到运行时的具体实现，虽然没有在运行，但是未来的 vm 一定是完全按照 bytecode 在执行的
相当于在脑海中将执行过程模拟了一遍

