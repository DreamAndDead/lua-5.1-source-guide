#+SETUPFILE: setup.org

* TODO parser

- 上下文无关文法
  - LL 1
  - 递归下降过程
    - funcname and ebnf symbol
  - caveats
    - binop precedence
    - ebnf naming
    - online manual/metalua/comments
- everything before generator


前面提到，lua 为了效率，将 token -> bytecode 压缩到了一个过程中
没有 ast ir 等中间产物，直接从 token 到 opcode。

相对应的，这部分代码就相对难以理解。

这一章先讲宏观的过程，在 gen 章节，再针对具体代码，进行 gen 的分析。

#+CAPTION: lex -> parse -> gen picture

** lang of lang
   :LOGBOOK:
   - Note taken on [2020-12-07 一 16:25] \\
     right extended grammar
   :END:

几乎所有 token 都可以使用 RE 表示，但是也有 RE 无法表示的情况

如 `a^kb^k`

但是用 上下文无关 文法就可以方便的表示
因为 上下文无关 文法提供了递归生成的方式




虽然过程综合在一起，还是从语法分析作为入口开始分析的。

语法分析，必须提到 EBNF 描述，lang of lang。
描述语言结构的语言。

综合官方文档和代码注释，以及实际生成的过程，整理 EBNF 如下。



因为使用 E，一些默认规则如下

#+begin_example
{ a } 表示 a*，0 个或多个
[ a ] 表示 a?，0 个或一个
( a ) 表示一个
| 表示或
#+end_example

整体如下

#+begin_src
chunk -> { stat [ `;' ] }

stat -> ifstat | whilestat | dostat | forstat | repeatstat |
        funcstat | localstat | retstat | breakstat | exprstat

ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END
cond -> expr
block -> chunk

whilestat -> WHILE cond DO block END

dostat -> DO block END

forstat -> FOR (fornum | forlist) END
fornum -> NAME = expr `,' expr [`,' expr] forbody
forlist -> NAME {`,' NAME} IN explist forbody
forbody -> DO block

repeatstat -> REPEAT block UNTIL cond

funcstat -> FUNCTION funcname body
funcname -> NAME {`.' NAME} [`:' NAME]
body -> `(' parlist `)' chunk END
parlist -> [ NAME {`,' NAME} [ DOTS ] ]

localstat -> LOCAL FUNCTION NAME body | LOCAL NAME {`,' NAME} [`=' explist]

retstat -> RETURN [explist]

breakstat -> BREAK

exprstat -> prefixexp (funccallstat | assignstat)
prefixexp -> NAME | `(' expr `)'

funccallstat -> primaryexp (`:' NAME funcargs | funcargs)
funcargs -> `(' [ explist ] `)' | constructor | STRING

assignstat -> primaryexp (`.' NAME | `[' expr `]') assignment
assignment -> `,' assignstat | `=' explist

primaryexp -> {`.' NAME | `[' expr `]' | `:' NAME funcargs | funcargs}


explist -> expr {`,' expr}
expr -> subexpr              ; 在 subexpr 中进行了比较级的限制（唉，EBNF）
subexpr -> (simpleexp | unop subexpr) {binop subexpr}

simpleexp -> NUMBER | STRING | NIL | TRUE | FALSE | DOTS |
             constructor | FUNCTION body | primaryexp

binop -> `+´ | `-´ | `*´ | `/´ | `^´ | `%´ | CONCAT | 
	`<´ | LE | `>´ | GE | EQ | NE |	AND | OR
unop -> `-´ | NOT | `#´

constructor -> `{' [fieldlist] `}'
fieldlist -> field {fieldsep field} [fieldsep]
field -> `[' expr `]' `=' expr | NAME `=' expr | expr
fieldsep -> `,' | `;'
#+end_src




官方的描述

#+begin_src bnf
	chunk ::= {stat [`;´]} [laststat [`;´]]

	block ::= chunk

	stat ::=  varlist `=´ explist | 
		 functioncall | 
		 do block end | 
		 while exp do block end | 
		 repeat block until exp | 
		 if exp then block {elseif exp then block} [else block] end | 
		 for Name `=´ exp `,´ exp [`,´ exp] do block end | 
		 for namelist in explist do block end | 
		 function funcname funcbody | 
		 local function Name funcbody | 
		 local namelist [`=´ explist] 

	laststat ::= return [explist] | break

	funcname ::= Name {`.´ Name} [`:´ Name]

	varlist ::= var {`,´ var}

	var ::=  Name | prefixexp `[´ exp `]´ | prefixexp `.´ Name 

	namelist ::= Name {`,´ Name}

	explist ::= {exp `,´} exp

	exp ::=  nil | false | true | Number | String | `...´ | function | 
		 prefixexp | tableconstructor | exp binop exp | unop exp 

	prefixexp ::= var | functioncall | `(´ exp `)´

	functioncall ::=  prefixexp args | prefixexp `:´ Name args 

	args ::=  `(´ [explist] `)´ | tableconstructor | String 

	function ::= function funcbody

	funcbody ::= `(´ [parlist] `)´ block end

	parlist ::= namelist [`,´ `...´] | `...´

	tableconstructor ::= `{´ [fieldlist] `}´

	fieldlist ::= field {fieldsep field} [fieldsep]

	field ::= `[´ exp `]´ `=´ exp | Name `=´ exp | exp

	fieldsep ::= `,´ | `;´

	binop ::= `+´ | `-´ | `*´ | `/´ | `^´ | `%´ | `..´ | 
		 `<´ | `<=´ | `>´ | `>=´ | `==´ | `~=´ | 
		 and | or

	unop ::= `-´ | not | `#´
#+end_src

ENBF 语法并没有给出完全的限制

虽然是递归下降，但是各个名称和 函数名称不一定是对应的

explist1 -> explist

并没有描述算术运算的优先级，和 number 一样，是在底层另行实现的。


函数的流程，像是字面意义上的 ast。

函数名与 left hand 同名，方便理清 ast 层面的逻辑。

但是具体的同义生成过程，还需要一番思索。

*** 递归下降
    :LOGBOOK:
    - Note taken on [2020-12-07 一 13:44] \\
    递归下降法与 LL 1 的关系？
    :END:

 lua 使用上下文无关方法描述，且使用 LL 1 方式，进行递归下降法，进行语法分析。

 和通常所见的不同，直接从这个过程中生成了 opcode，而不是 ast ir 之类。

 由于递归下降的特性，大部分函数名和相应的规则相同，所以相应的过程就比较容易梳理。
 但是并不完全，也有一些不完美的地方。



可以逐个模块进行分析

*** TODO expdesc
    :LOGBOOK:
    - Note taken on [2020-12-07 一 17:34] \\
      各个状态如何发生作用？
    :END:

exp desc

exp 基本运作单元

desc 描述其属性，是 ast 到 code 的纽带

*** inspect

gdb py 插件的介绍

** practice

尝试随意的代码，在 chunk 处打上断点
n/s 观察代码的走向

** generate

- generic
  - expdesc
  - alloc stack
  - var type
    - local
    - upval
    - global
  - k table
  - proto list
  - upval list
- statement
  - if
    - jump chain
  - for
    - blockCnt
    - do end, chunk is not block
  - function
    - upval
  - ...
- opcode
  - close
  - ...


生成过程，就是等义转换的过程

隐藏在语法分析下的艺术


*** big picture
    :LOGBOOK:
    - Note taken on [2020-12-07 一 13:54] \\
    lexical scoping 和 syntax scoping 的区别？ 闭包的不同实现？
    :END:

 #+CAPTION: luaY_parser function



 概念 vs
 - function，是 lua 中的概念，函数
 - proto，是 function 分析之后的同语义结构
 - closure，封装 proto，提供 upval 空间，用于 vm 运行时



 Proto 最终生成的 bytecode 与相关环境
 基本可以将 proto 等同于生成的可执行文件，交给 vm 就可以执行，不过其中有一些结构上的安排。

 一个 function 对应生成一个 proto，一个 lua 文件，可被认为是一个匿名函数
 故最终返回的是一个 proto。

 function 是基础类型，如果 lua 文件作为一级函数，则其中定义的函数为二级函数

 其中函数内部定义的函数为三级函数，可以不断向下延伸

 每一级函数，在 **p 中记录其包含的下一级函数，根据出现的顺序，用数组来记录。


 #+CAPTION: proto and function


 以 function 为单位，生成一块一块的 proto，组合在一起。


 前面提到过，在词法分析的过程中，有 lexstate 结构，它存储了一切词法分析过程中的状态
 在生成过程中，也存在如此结构，称为 funcstate，存储生成过程中涉及到的状态
 其中的 proto 就是生成的结果。

 总体过程如下。

 #+CAPTION: ls fs p big picture

 可以看出，ls 是单例，向 fs 输入 token，并在不同的 func 层次，对接不同的 fs 结构。

 每当生成一个新的 function，都会新建一个 fs，并指向父 fs，并对接 ls，生成自己的 f
 在结束之后，将 f 的结果并入父 fs 的 f 中。


 其实 fs 和 f 几乎是一个整体，总是同时行动。
 区别在于，proto 作为最终返回的结果，内容最小化，不多不少
 而作为中间过程中相关的 state，并不是 vm 需要关心的，所以就剔除到 fs 结构中了。


 ls fs 在 gen 的过程中，都只是承担着一个中间作用，辅助作用，生成返回 f 之后，就被丢弃。








 其中的 k 表，opcode，就是在 vm 模型讨论的，
 关于 upval 的信息，隐藏在了 code 中。
 #+INCLUDE: ../lua-5.1.5/src/lobject.h src c :lines "228-254"


 - func state
 #+INCLUDE: ../lua-5.1.5/src/lparser.h src c :lines "57-76"






 为什么 local var 和 active local var 存储在两个部分？

 因为相应的索引，在生成 code 之后，相当于信息已经存储于 code 的参数中，不需要另行存储
 且 active 只记录一种状态而已，辅助生成正确的代码，在不同阶段是不同的。

 因为 active 状态只能在 parse 过程分辨。
 离开作用域自然不是 active 的。
 而是否 active 对于 bytecode 并不重要。
 active 状态用于辅助 funcstate 生成 bytecode。




 discharge vars 意思是解析变量，比如

 ```
 a = 1
 ```

 在赋值之间，要先解析 1，从 k 表中将 1 加载到栈中，
 然后再设置到全局表。

 解析 1 的过程就是 discharge。

 生成的 bytecode 也就在 assignment 的前面。




 fs->f->sizek 和 fs->nk 是有区别的
 nk 是随着实际情况准确的在变化，而 sizek 准确的说，更像是在记录扩容的空间大小
 如 length 和 capacity 的区别
 当然，最终分析完成之后，会使用赋值 sizek = nk，作为最终的生成结果







 - expdesc

 #+INCLUDE: ../lua-5.1.5/src/lparser.h src c :lines "19-46"





 #+CAPTION: lex next -> Y parser -> proto



 #+CAPTION: L ls fs p structure


*** register
    :LOGBOOK:
    - Note taken on [2020-12-07 一 14:01] \\
      如何调度寄存器？
    :END:


parse 生成 bytecode，关于寄存器的使用，只是从表面上生成相应的索引
因为 parser 知道自己使用了哪些寄存器，还有哪些可以使用，这些信息是 运行时的 vm 所不知道的

move a b

但是并不分配寄存器的空间，只是用来调度使用哪个寄存器
因为这是编译时，而不是运行时
    

*** statement

**** local assignment

 ```lua
 local a = 10
 ```

 将 10 存入 k 表，将 a 存入 locvars 表中（其中存储了名字 "a"）。
 使用 loadk 指令，将 k 中的 10 加载入 reg 中。


 如果是

 ```lua
 a = 1
 ```

 则直接将名字 "a" 和 1 都保存在 k 表。

 需要通过 "a" 来索引全局变量。这一点和 local var 完全不同。


 通过 numberK 和 stringK 方法

 每个 function 都有一个 k 表，而且可以去重存储。

**** arithmetic


**** compare

lua 在进行解析时，没有进行关系运算的实时解析，但是对 constant 算法运算有编译时执行

如 `local a = 5 > 2` 和 `local a = 1 + 2` 的区别

前者需要生成 jmp 指令，但是后者，直接是 loadk 0 0 ; 3


**** loop

***** for

for loop 特别开发了底层指令来处理，而 repeat 和 while 则没有相应的指令。
依然是通过 jmp 来实现的。

***** while & repeat


*** opcode
    
**** move
     
move code 发生在 assignment 环节

在这里要进行值的迁移


luaK_storevar 生成了 move 指令

exp2reg?

对于赋值，= 后是 exp，前是存储空间

后面的 exp 要经过解析，才能向前赋值



**** loadnil

luaK_nil()


**** table related

gettable 中，之所以使用 RK(C) 这种方法，是因为索引值未必是 constant，也可能是
一个表，一个函数，等其它值，这种值只能由 寄存器 存储

同时，加上了 k，也可以节省临时寄存器的使用

如果超出了 k 表的范围，大于 256，需要临时先加载入 寄存器


**** upval related

在 pascal 中，在 outer scope 的变量，可以通过 frame stack 去查找

但是在 lua 中，函数也是一种值，可以四处流转，说不定在什么地方调用
所以其 upvalue 不一定出现在 stack frame 上

