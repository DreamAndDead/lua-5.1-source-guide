#+SETUPFILE: setup.org

* TODO vm

生成图纸之后，按图纸来执行

完全是 proto 内部的东西



** state

G
L

#+begin_src c
struct lua_State {
  CommonHeader;
  lu_byte status;             // 状态？可能用于协程中
  StkId top;                  // 栈顶指针，（第一个空的位置）
  StkId base;                 // 栈基指针
  global_State *l_G;          // 指向 global state
  CallInfo *ci;               // 当前函数的 callinfo
  const Instruction *savedpc; // savedpc？
  StkId stack_last;           // 栈的最后？
  StkId stack;                // 栈基？
  CallInfo *end_ci;           // 指向 callinfo 数组的最后
  CallInfo *base_ci;          // callinfo 数组的开始
  int stacksize;              // 栈大小
  int size_ci;                // callinfo 数组大小
  unsigned short nCcalls;     // 嵌套函数调用的个数？（控制 LL 1 过程中递归层数，enterlevel, leavelevel）
  unsigned short baseCcalls;  // 协程 resume 时？
  lu_byte hookmask;           // ？
  lu_byte allowhook;          // ？
  int basehookcount;          // ？
  int hookcount;              // ？
  lua_Hook hook;              // ？
  TValue l_gt;                // 全局表？
  TValue env;                 // 临时存储环境？
  GCObject *openupval;        // upvalue 的链表？
  GCObject *gclist;           // ？
  struct lua_longjmp *errorJmp; // 错误回调？
  ptrdiff_t errfunc;            // 用栈索引表示的 error handling 函数？
};
#+end_src

** model

virtual machine

stack

TValue & StkId


pc

ci

internal


** internal

lua 中各种机制的实现方式

以示例代码的方式来探索


多数在绘制图纸的时候，已经得到了解决，虚拟中和实际运行时差别不大

    

*** c closure?

*** closure

args

def and pass

vararg

*** call
    
*** tailcall
    
*** return

*** upval
  
upval, open and close

*** metatable


*** env global

*** TODO coroutine

   
