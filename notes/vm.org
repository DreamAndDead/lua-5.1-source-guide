#+SETUPFILE: setup.org

* TODO vm

生成图纸之后，按图纸来执行

完全是 proto 内部的东西



** state

G
L

#+begin_src c
struct lua_State {
  CommonHeader;
  lu_byte status;             // 状态？可能用于协程中
  StkId top;                  // 栈顶指针，（第一个空的位置）
  StkId base;                 // 栈基指针
  global_State *l_G;          // 指向 global state
  CallInfo *ci;               // 当前函数的 callinfo
  const Instruction *savedpc; // savedpc？
  StkId stack_last;           // 栈的最后？
  StkId stack;                // 栈基？
  CallInfo *end_ci;           // 指向 callinfo 数组的最后
  CallInfo *base_ci;          // callinfo 数组的开始
  int stacksize;              // 栈大小
  int size_ci;                // callinfo 数组大小
  unsigned short nCcalls;     // 嵌套函数调用的个数？（控制 LL 1 过程中递归层数，enterlevel, leavelevel）
  unsigned short baseCcalls;  // 协程 resume 时？
  lu_byte hookmask;           // ？
  lu_byte allowhook;          // ？
  int basehookcount;          // ？
  int hookcount;              // ？
  lua_Hook hook;              // ？
  TValue l_gt;                // 全局表？
  TValue env;                 // 临时存储环境？
  GCObject *openupval;        // upvalue 的链表？
  GCObject *gclist;           // ？
  struct lua_longjmp *errorJmp; // 错误回调？
  ptrdiff_t errfunc;            // 用栈索引表示的 error handling 函数？
};
#+end_src

** model

virtual machine

stack




ldo.c:144

stack
stack_last
stacksize

EXTRA_STACK
1

relations





TValue & StkId

pc



ci

base_ci
size_ci
end_ci

ldo.c:169 157




** internal

lua 中各种机制的实现方式

以示例代码的方式来探索

多数在绘制图纸的时候，已经得到了解决，虚拟中和实际运行时差别不大



continue 不作用于 switch 语句

*** closure

store proto to closure

getupval, just ref pointer

move, using luaF_findupval lfunc.c:53

71 72 行太隐晦了

pp 是 &p->next
pp 是指向 p 中 next 成员的指针

所以 *pp = obj2gco(uv) 的时候，修改了 p next 成员的值

在这里将 openupval 按 level 顺序链接起来！




and save to stack

*** call

*** args

def and pass

vararg
    
*** return

*** tailcall
    
*** upval
  
new in closure process

open and close

*** c closure?
   
*** metatable


*** env global

*** TODO coroutine

