#+SETUPFILE: setup.org

* DRAFT string

lua 中使用字符串是比较方便的，因为其在内存中的新建由底层完成，
gc 回收也由底层完成，极大方便了上层使用者。

作为 lua 语言的基础类型之一，在 lua 实现的底层也提供着重要的作用


** feature

可能是出于优化的考虑，lua 中所有 string 都是不可变的，且只有一份留存在内存中。

#+begin_src lua
  local a = "pre"
  local b = "post"
  local c = a .. b
local d = "pre"
#+end_src


#+CAPTION: immutable string
fig.ref to immutable string

a 和 b 分别指向内存中，存储字符串的区域，

进行连接时，并没有在 "pre" 内存区域，新增 "post" 进行修改，而是
新建字符串 "prepost"，由 c 指向

当 d 再度使用 "pre" 字符串时，因为内存中已经存在相应实例，所以
a 和 d 引用的是相同的字符串。

如果说存在以上的特性，在底层必定存在一个字符串池，用来存储所有在使用的字符串，
就是 g->stringtable

** data structure

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c -n 196 :lines "196-208"

string 的内存结构很简单，包含
- meta
- content

- 本身是 union
  - dummy 用来对齐内存？how？本身比 tsv 小很多。并不用来引用数据
  - 作为 gcobject，配置了 commonHeader
  - reserved 用于缓存关键字，比如 if end，不会被 gc，> 0 即可
  - hash 是字符串内容计算得到的
    - 相同串 hash 相同
    - 可比较大小
    - TODO hash algo 的原理
  - len，字符串内容的长度
- 字符串的具体内容存放在，符合 tstring 对齐原则的（？）下一个内存地址处，紧紧凑在一起
  而没有使用 next 之类的指针来存储


知晓了内存结构，下面相关的宏就很容易理解
- getstr
- svalue

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c -n 210 :lines "210-212"

tstring 的大小空间
- +1 是因为末尾的 '\0'

#+INCLUDE: ../lua-5.1.5/src/lstring.h src c -n 16 :lines "16-17"

** method

对于 tstring，只有两个方法是最重要的。

一个是 new string，新建 string 对象，释放的过程由 gc 来处理。

一个是底层使用的 resize，用于动态调整 hash bucket
      
*** new

string 只会被新建，不会被修改

所有的 string 都存储在 global->strt 中。
存储的方式，是教科书式的 hash bucket 实现。

#+INCLUDE: ../lua-5.1.5/src/lstate.h src c -n 38 :lines "38-43"

- hash 是桶数组，元素为 gcobject *
- nuse 为所有字符串的数量
- size 为桶数组的长度

每个 string 都有一个唯一的 hash，string 就存放在 hash % size 的桶里
如果 hash 出现冲突，就用 next（commonHeader 还记得吗） 将相同 hash 的字符串串起来

- [ ] graph

当新建字符串的时候，很计算出 string 的 hash 值，到桶中去寻找，是否已经存在
- 存在则直接返回相应指针
- 不存在则调用私有方法，新建 string

#+INCLUDE: ../lua-5.1.5/src/lstring.c src c -n 75 :lines "75-94"



- 检测是否超出长度限制，右侧 - 防止溢出
- 分配 l+1 长度 + TSring 头部的内存，+1 是为了添加最后的 '\0'
- 设置相应的字段，ts+1 就是 char * 的开始处
- 添加后置 '\0'
- 使用头插法，插入到 global string table 中
- 是否触发 resize 操作

#+INCLUDE: ../lua-5.1.5/src/lstring.c src c -n 50 :lines "50-73"


相关的两个宏也容易理解
- TODO strlen 和 sizeof / sizeof 的区别？

#+INCLUDE: ../lua-5.1.5/src/lstring.h src c -n 20 :lines "20-23"

*** resize
    
resize 的作用，就是动态根据所有桶中元素的多少，进行桶的数量的调整。

在 new string 中，触发的条件为
- 元素超过桶的个数
- 桶的个数小于等于最大整数的一半

进行桶的数量调整，调整为原来的 2 倍大小，使其中元素更合理的分散开。
提高效率。

- 先开辟桶内存，置为 NULL
- 遍历原 string table，插入新的桶
- 释放原来的桶
- global string table 设置为新桶


#+INCLUDE: ../lua-5.1.5/src/lstring.c src c -n 22 :lines "22-48"


** practice

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c -n 215 :lines "215-224"

userdata 的实现方法和 string 很相似，就一并放在 lstring.c.h 中

- ~sizeudata~
- ~luaS_newudata~

可以参考相关实现


