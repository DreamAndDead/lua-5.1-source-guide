#+SETUPFILE: setup.org

* DRAFT string

lua 中使用字符串是比较方便的，因为其在内存中的新建由底层完成，
gc 回收也由底层完成，极大方便了上层使用者。

作为 lua 语言的基础类型之一，在 lua 实现的底层也提供着重要的作用

** feature

可能是出于优化的考虑，lua 中所有 string 都是不可变的，且只有一份留存在内存中。

#+begin_src lua
local a = "pre"
local b = "post"
local c = a .. b
local d = "pre"
#+end_src


#+CAPTION: immutable string

a 和 b 分别指向内存中，存储字符串的区域，

进行连接时，并没有在 "pre" 内存区域，新增 "post" 进行修改，而是
新建字符串 "prepost"，由 c 指向

当 d 再度使用 "pre" 字符串时，因为内存中已经存在相应实例，所以
a 和 d 引用的是相同的字符串。

** data representation
   :LOGBOOK:
   - Note taken on [2020-12-03 四 09:38] \\
     how hash alog work?
   - Note taken on [2020-12-03 四 09:38] \\
     how dummy align memory?
   :END:

string 数据作为一种 gcobject，在 gcobject 中用 tstring ts 表示。

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c -n 196 :lines "196-208"

tstring 结构上看是一个 union，但是 dummy 是用来做对齐，并不用作数据用途
所以本质还是一个 struct 结构


tstring 包含如下信息
- meta，本身的一些信息
- content，string 内容

除了 commonheader 熟知的部分，新增了几个字段，就是 meta 的部分
- reserved，只用于关键字，在 lex 过程中发挥辅助作用，同时标识 gc 永远不清除（reserved > 0？），在 lex 部分详细解释
  - luaS_fix 的作用，提前一些 gc 知识
- hash，根据 content 计算得到的 hash 值，相同的字符串，相同 hash，并且有大小区别，且辅助在 bucket 中落位
- len，string content char 长度，不包含最后的 '\0'

而 content 部分，就紧紧跟在 tstring 的后面，紧紧凑在一起，而没有使用 next 之类的指针来存储

#+CAPTION: tstring mem graph

知晓了内存结构，下面相关的宏就很容易理解
- getstr
- svalue

使用 ts + 1 来索引到紧跟其后的位置，一种讨巧的做法

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c -n 210 :lines "210-212"

在这种内存安排上，tstring 的大小空间就是 meta + content 的大小，+1 是因为要计入 content 末尾的 '\0'

#+INCLUDE: ../lua-5.1.5/src/lstring.h src c -n 16 :lines "16-17"

** method

对于 tstring，有两个方法是最重要的。

一个是 new string，新建 tstring，提供给外部使用，释放的过程由 gc 来处理。

一个是 resize，用于动态调整 hash bucket，避免效率的下降。
内部有一个标准来判断，何时进行 resize。
      
*** new
    :LOGBOOK:
    - Note taken on [2020-12-03 四 10:09] \\
      strlen 和 sizeof / sizeof 的区别？
    :END:

前面提到过，string 只会被新建，不会被修改

如果说存在以上的特性，在底层必定存在一个字符串池，用来存储所有在使用的字符串，
就是 g->strt

stringtable

#+INCLUDE: ../lua-5.1.5/src/lstate.h src c -n 38 :lines "38-43"

stringtable 采用了教科书式的 hash bucket 实现。
- hash，桶数组，元素为 gcobject *
- nuse，所有已存储字符串的数量
- size，bucket 的数量

每个 string 都有一个唯一的 hash，string 就存放在 hash % size 的桶里
如果 hash 出现冲突，就用 next（commonHeader 还记得吗） 将相同 hash 的字符串串起来

当新建字符串的时候，很计算出 string 的 hash 值，到桶中去寻找，是否已经存在
- 存在则直接返回相应指针
- 不存在则调用私有方法，新建 string

#+INCLUDE: ../lua-5.1.5/src/lstring.c src c -n 75 :lines "75-94"

newlstr 新建字符串的过程也很容易理解

- 检测是否超出长度限制，右侧 - 防止溢出
- 分配 l+1 长度 + TSring 头部的内存，+1 是为了添加最后的 '\0'
- 设置相应的字段，ts+1 就是 char * 的开始处，添加后置 '\0'
- 使用头插法，插入到 global string table 中，一举两得，不用判断桶中是否有元素，头插就可以
- 按需进行 resize

#+INCLUDE: ../lua-5.1.5/src/lstring.c src c -n 50 :lines "50-73"


理解了基础的 newlstr 方法后，相关的两个宏也容易理解

#+INCLUDE: ../lua-5.1.5/src/lstring.h src c -n 20 :lines "20-23"

*** resize
    
resize 的作用，就是动态根据所有桶中元素的多少，进行桶的数量的调整。

在 new string 中，自动触发的条件为
- 元素数量超过桶的个数
- 桶的个数小于等于最大整数的一半

进行桶的数量调整，调整为原来的 2 倍大小，使其中元素更合理的分散开，提高效率。
- 先开辟桶内存，置为 NULL
- 遍历原 string table，插入新的桶
- 释放原来的桶
- global string table 设置为新桶

#+INCLUDE: ../lua-5.1.5/src/lstring.c src c -n 22 :lines "22-48"

** practice

userdata 的新建方法和 tstring 非常相似，就一并放在 lstring.c.h 中
- ~sizeudata~
- ~luaS_newudata~

可以参考相关实现

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c -n 215 :lines "215-224"


