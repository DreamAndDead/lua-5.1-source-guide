#+SETUPFILE: setup.org

* generate

parser 介绍了整体的语法分析过程

gen 来详细深入，隐藏在语法分析过程之下的代码生成部分

#+CAPTION: fs f combine picture

生成过程的模型和实际运行的模型，连接点是对 stack 的隐式共识，实际以 proto 传递。


规则间的同义转换

语法规则    vm opcode 规则

生成过程，就是等义转换的过程

隐藏在语法分析下的艺术


语法制导翻译

把一些属性附加到代表语言构造的文法符号上，从而把信息和一个语言的构造联系起来


通用方式，是通过语法分析，得到 ast，进行属性计算
很多情况下，翻译可以在扫描过程中完成

L 属性翻译


语法制导
中间代码
代码生成

完全整合在一起

能正确运行已经是奇迹



gen 的这一步，多关乎两者之间的连接过程
中间状态

为了达到最终的结果，中间的阶段



在生成的过程中，有一个 imaginary 的栈，和相应 imaginary 的操作存储在 code



总体原则，
- 语法制导
- 后缀方法
- 栈模拟运算


关注 compile time

因为分析从左向右，从前至后的，所以对于一些结构需要特别的方法来处理
比如 if 分支的处理，回填 jmp 地址

以及 function proto 分析过程出现的栈过程


** big picture
   :LOGBOOK:
   - Note taken on [2020-12-10 四 10:08] \\
     why ~function~ concept is important in lua!
   - Note taken on [2020-12-07 一 13:54] \\
   lexical scoping 和 syntax scoping 的区别？ 闭包的不同实现？
   :END:

#+CAPTION: luaY_parser function

概念 vs
- function，是 lua 中的概念，函数
- proto，是 function 分析之后的同语义结构
- closure，封装 proto，提供 upval 空间，用于 vm 运行时

Proto 最终生成的 bytecode 与相关环境
基本可以将 proto 等同于生成的可执行文件，交给 vm 就可以执行，不过其中有一些结构上的安排。

一个 function 对应生成一个 proto，一个 lua 文件，可被认为是一个匿名函数
故最终返回的是一个 proto。

function 是基础类型，如果 lua 文件作为一级函数，则其中定义的函数为二级函数

其中函数内部定义的函数为三级函数，可以不断向下延伸

每一级函数，在 **p 中记录其包含的下一级函数，根据出现的顺序，用数组来记录。


#+CAPTION: proto and function


以 function 为单位，生成一块一块的 proto，组合在一起。


前面提到过，在词法分析的过程中，有 lexstate 结构，它存储了一切词法分析过程中的状态
在生成过程中，也存在如此结构，称为 funcstate，存储生成过程中涉及到的状态
其中的 proto 就是生成的结果。

总体过程如下。

#+CAPTION: ls fs f big picture

可以看出，ls 是单例，向 fs 输入 token，并在不同的 func 层次，对接不同的 fs 结构。

每当生成一个新的 function，都会新建一个 fs，并指向父 fs，并对接 ls，生成自己的 f
在结束之后，将 f 的结果并入父 fs 的 f 中。


其实 fs 和 f 几乎是一个整体，总是同时行动。
区别在于，proto 作为最终返回的结果，内容最小化，不多不少
而作为中间过程中相关的 state，并不是 vm 需要关心的，所以就剔除到 fs 结构中了。


ls fs 在 gen 的过程中，都只是承担着一个中间作用，辅助作用，生成返回 f 之后，就被丢弃。








其中的 k 表，opcode，就是在 vm 模型讨论的，
关于 upval 的信息，隐藏在了 code 中。
#+INCLUDE: ../lua-5.1.5/src/lobject.h src c :lines "228-254"


- func state
#+INCLUDE: ../lua-5.1.5/src/lparser.h src c :lines "57-76"





为什么 local var 和 active local var 存储在两个部分？

因为相应的索引，在生成 code 之后，相当于信息已经存储于 code 的参数中，不需要另行存储
且 active 只记录一种状态而已，辅助生成正确的代码，在不同阶段是不同的。

因为 active 状态只能在 parse 过程分辨。
离开作用域自然不是 active 的。
而是否 active 对于 bytecode 并不重要。
active 状态用于辅助 funcstate 生成 bytecode。












#+CAPTION: lex next -> Y parser -> proto



#+CAPTION: ls fs f structure, proto and cascade proto for functions



#+CAPTION: fs f inside

fs->f->sizek 和 fs->nk 是有区别的
nk 是随着实际情况准确的在变化，而 sizek 准确的说，更像是在记录扩容的空间大小
如 length 和 capacity 的区别
当然，最终分析完成之后，会使用赋值 sizek = nk，作为最终的生成结果

f k  fs nk
f p  fs np
f code  fs pc
fs actvar  fs nactvar
f locvars  fs nlocvars

fs upvalues  f nups
f upvalues  f nups




代码的生成过程有一个隐式的假设，对 vm 的运作方式有明显的假定
如果纯粹的分离开来，应该对一套 opcode 进行编程
但是这里 opcode 的定义显然就是 vm 本身

*** register
    :LOGBOOK:
    - Note taken on [2020-12-07 一 14:01] \\
    如何调度寄存器？
    :END:

 register is stack

 parse 生成 bytecode，关于寄存器的使用，只是从表面上生成相应的索引
 因为 parser 知道自己使用了哪些寄存器，还有哪些可以使用，这些信息是 运行时的 vm 所不知道的

 move a b

 但是并不分配寄存器的空间，只是用来调度使用哪个寄存器
 因为这是编译时，而不是运行时
    
*** variable

 变量有 3 类，local upval global

**** local
     :LOGBOOK:
     - Note taken on [2020-12-15 二 11:14] \\
       变量逆序查找，比如出现 local 覆盖的情况
       searchvar() lparser.c:207
     :END:

 local 变量的作用范围（active），开始于在作用域中出现的一刻，到作用域结束。

 作用域是有明显的栈特性的，新作用域入栈，离开作用域出栈

 在一个作用域内，local 变量按照声明顺序入栈，离开作用域时全部出栈，local var dead，让出空间

 这样栈中从 base 到 top，就始终记录着 active local 变量，作用范围由大到小。

 #+CAPTION: 16 active local scope & fs->actvar nactvar

 利用这种特征，在 fs 中用 actvar 和 nactvar 始终记录着当前 active local var 的状态。

 #+CAPTION: 16 actvar & locvars

 statement/scope.lua

 b lparser.c:1306

 fs->nlocvars 的原因，不需要这个变量，nlocvars 只用来指向下一个可放置的位置

 local 只在使用时发生作用，而在使用时，已经被记录在 code 中了

**** upvalue

 在 pascal 中，在 outer scope 的变量，可以通过 frame stack 去查找

 但是在 lua 中，函数也是一种值，可以四处流转，说不定在什么地方调用
 所以其 upvalue 不一定出现在 stack frame 上


 #+begin_quote
 对象是带函数的值
 闭包是带值的函数
 #+end_quote

 #+begin_src lua :results output
 local function outer()
    local a = 0

    local function inner()
       local b = 0

       a = a + 1
       return a
    end

    inner()

    return inner
 end

 local f = outer()

 print(f())
 print(f())
 print(f())

 local g = outer()

 print(g())
 print(g())
 print(g())
 #+end_src

 #+RESULTS:
 : 2
 : 3
 : 4
 : 2
 : 3
 : 4

 function 作为基础类型之一，可以作为普通变量，参数，返回值，赋值，而四处流转

 这种情况下，和 local 作用域机制在一起，就会出现问题

 a 的作用域在 outer 内部，同时被 inner 引用并修改，最终 outer 返回 inner

 调用 outer，赋值给 f

 按照语义，f 应该是内部的 inner func，每次调用都得到 a 的自增值

 调用 3 次，得到 1 2 3

 问题在于，a 只作用在 outer 内部，而 f 在 outer 外部，已经离开了 a 的作用域，
 在这种情况下如何保证语义的正确？

 这便是闭包机制的由来，a 对于 inner 而言，不是 local，而是 upvalue 类型。

 这也是 lua 中为何 func 不是 func 而是 closure 的原因，func 及 upvalue 组成了 closure，
 所有 func 在运行时都封装为 closure 来运行，其中重要的原因就在于分配 upvalue 空间。

 #+CAPTION: 17 upvalue at runtime

 再调用 outer，赋值给 g，调用 3 次，得到一样的结果，从中可以得到 upvalue 作用于 active 和
 dead 状态的区别。

**** global

 前面提到了 local 变量的作用域，以及 upvalue 出现的原因及解决方法。

 其中隐含的一点，外层变量对于内层可见，假如强制设定外层对于内部不可见，便不会有 upvalue 的问题。

 对于可见的情况，对于当前引用的变量，自然有一个查找的过程。
 和嵌套相反，是层层向上寻找的过程。

 变量
 在本层可以找到的，为 local
 在本层之外可以找到的，为 upvalue
 所有层都无法找到的，为 global

 global 的概念解决了两个细节问题
 为什么顶层的 function 是没有 upvalue 的？
 因为在本层找不到的变量，向上已经没有层级，只能是 global

 setfenv 的概念
 函数的运行环境，即是 global，在编译的 chunk 运行之前，设定 global 的值，
 可以影响内部对 global 值的引用，从而实现不同的运行效果。


 在实现中，global 是单独于基层的 closure 存在的，是运行状态的一部分
 所以不存在作用域的问题，始终在顶层。


 #+begin_src lua :results output
 local function outer()
   a = 10

   local function inner()
     a = a + 1
     return a
   end

   return inner
 end

 local f = outer()

 print(f(), a)
 print(f(), a)
 print(f(), a)
 #+end_src

 #+RESULTS:
 : 11	11
 : 12	12
 : 13	13

 #+CAPTION: 18 global at runtime

*** TODO expdesc
     :LOGBOOK:
     - Note taken on [2020-12-07 一 17:34] \\
     各个状态如何发生作用？
     :END:

递归下降
语法制导
后缀方法
配合 vm opcode 共同作用的结果


 exp desc

 exp 基本运作单元

 desc 描述其属性，是 ast 到 code 的纽带

 #+INCLUDE: ../lua-5.1.5/src/lparser.h src c :lines "19-46"



 - VVOID 什么都不做
 - VNIL  nil 值
 - VTRUE
 - VFALSE bool
 - VK    在 k 表中的值
 - VKNUM 数字字面量

 没有 string 类型，因为在读取的过程中，直接将其放入 k 表中，变成 VK 类型了


 TODO desc 到 reg 的轨迹追踪？


 discharge2reg
 lcode.c:343

 操作的只是 exp 相关的类型

 exp 需要解析到值，而 var 需要解析到位置

 reg 是目的地

 VRELOCABLE 说明 A 本身还不确定，在 discharge 的时候，补全到 A 位置

 VNONRELOC 则说明本身已经解析到栈中 或 A 已经正确

 | exp desc   | gen code                                 |
 |------------+------------------------------------------|
 | VNIL       | loadnil                                  |
 | VTRUE      | loadbool                                 |
 | VFALSE     | loadbool                                 |
 | VK         | loadk                                    |
 | VKNUM      | loadk                                    |
 | VRELOCABLE | get its code and change A to reg         |
 | VNONRELOC  | reg != self reg, move; otherwise nothing |
 | VVOID      | nothing                                  |
 | VJMP       | nothing                                  |


 dischargevars

 | exp desc | discharge                                            |
 |----------+------------------------------------------------------|
 | VLOCAL   | to VNONRELOC                                         |
 | VUPVAL   | gen code GETUPVAL, A is uncertain, to VRELOCABLE     |
 | VGLOBAL  | gen code GETGLOBAL, A is uncertain, to VRELOCABLE    |
 | VINDEXED | free table and idx, gen code GETTABLE, to VRELOCABLE |
 | VCALL    | to VNONRELOC, store call code A value                |
 | VVARARG  | set B to 2? to VRELOCABLE                            |

*** TODO how freereg & freeexp works

#+CAPTION: page 19 & 20

freereg 的作用

在栈的特性上，更深入的理解

何时分配，何时回收

根据抽象栈演算的顺序来

和 nactvar 的关系


** tools

以实例为基础的探索
基础方法
   
make spy

make inspect

chunkspy 中 .local .const 的概念对应

#+begin_example
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 3 stacks
.function  0 0 2 3
.local  "a"  ; 0
.local  "b"  ; 1
.local  "c"  ; 2
[1] return     0   1      
; end of function
#+end_example

line 1
level 1 指的是第一层级
function [0] 表明是当前层级的第 1 个函数（以 0 开始索引）

line 2
0 个 upvalue
0 个参数
0b010 接收可变参数
3 需要分配栈容量，2 是最小值，来源于在不断的运算过程中，栈增长减少，遇到的最大值

line 3
和 line 2 相同，2 是 3 的注释

line 4 5 6
.local f->locvars 内容

line 7
f->code 指令
最终一行总是默认生成一条 return 指令
这里只有一条 return，说明代码并没有生成代码

line 8
function 结束注释



** statement
   :LOGBOOK:
   - Note taken on [2020-12-09 三 13:35] \\
     先从 stat 开始分析，将得到的经验抽象为内容。
   :END:

- 原子性
- 依赖性
- 实例分析
- 生成模式

递归结合是无限的
只讲解 atom ，组合交由读者探索


*** function

compile time

enf 结构

body 方便定义匿名函数

func 有同名和匿名两种
从 ebnf 中可以看出，两者只差在 NAME
几乎全部由 body 处理
包含了参数，函数体等全部
动态类型，名称与值的绑定，所以由 body 来处理全部

#+CAPTION: 29 function


body 过程不过是参数和 chunk 的递归过程

**** upval

和 closure 同一级的变量被引用，使用 move 指令
>= 级的变量，使用 getupval 指令


move A B

A 无用，B 指代 local 的 active 栈索引

getupval A B

A 无用，B 指代上层 closure 中 upval 表的序号

getupval 一直向上链，总会找到 local 对应的位置


Q: f 没有明显引用 a，但是但 a 却存在于 f 的 upval 数组中？

A:

singlevar
singlevaraux

从底层向上寻找，从 f 向上找到 a，调用 indexupvalue (lparser.c:183)
作为 upval 使用，而非 local，在 index upval 的过程中，
添加到 f 的 upval 表中

新增 upval 并返回 upval 对应的索引


**** vararg
     :LOGBOOK:
     - Note taken on [2020-12-15 二 13:38] \\
       在 vm 运行时，再详细深入栈过程
     :END:

lobject.h:256

|        4 |        2 |      1 |
|----------+----------+--------|
| NEEDSARG | ISVARARG | HASARG |


在 lua5.0 中，没有 ... 的表达式，只能在参数定义时使用

而在内部引用 vararg 时，通过变量 arg 来使用

arg 是一个 table，内部以数组形式存储了 vararg

arg.n 是数组的长度

#+begin_src lua
function foo(a, b, ...)
  local arg = {...}
  arg.n = select("#", ...)
end
#+end_src


lua5.1 默认有对上面形式的兼容性

NEEDSARG 表明是否在内部构造 arg 的值

ldo.c:215

lua5.1 判断，如果内部出现了 ... exp，就不使用 arg，
NEEDSARG = 0

lparser.c:756

HASARG 用于在计算 nparam 时很方便，直接使用 & 运算就可以

lparser.c:571

ISVARARG 和 HASARG 应该是相同的？
chunk main func 只有 ISVARARG 标志


无即是 0
chunk func 是 2
不引用 arg 是 3
引用 arg 是 7


存储在 proto
- numparams，vararg 不算一个参数
- is_vararg

*** local assignment

#+begin_src bnf
localstat ::= LOCAL NAME {`,' NAME} [`=' explist]
localstat ::= LOCAL FUNCTION NAME body
#+end_src


#+begin_src lua
local function f()
end

local f = function ()
end
#+end_src

localstat 有两种情况，func 的情况之后到 function 部分再讨论。
另一种情况是局部变量声明，分为是否赋值两种情况。

localstat vs localfunc

**** no assignment

#+begin_src lua
local a, b, c
#+end_src

#+begin_example
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 3 stacks
.function  0 0 2 3
.local  "a"  ; 0
.local  "b"  ; 1
.local  "c"  ; 2
[1] return     0   1      
; end of function
#+end_example

考虑如上代码，声明局部变量 a。

没有生成代码，毕竟没有任何运算或者操作

所以只存储了 local 变量的信息

#+CAPTION: 18 local no assignment

lparser.c:143
=registerlocalvar= 是操作 f->locvars 的过程

lparser.c:163
=new_localvar= 是操作 fs->actvar 的过程

先注册，再存储相应的索引


expdesc 为 VVOID，因为没有 exp，没有赋值
e 记录的是最后一个 expr 的属性



nvars = nexps


=adjust_assign= 进行左右数量的调整

多余空间置为 nil

TODO 因为 luaK_nil 的优化过程，没有生成代码

调整了 freereg 的值，是进行中间运算的安排的



=adjustlocalvars= 调整 nactvar 的值，并设置相应的 startpc


**** with assignment

***** TODO multret

TODO 有 multret 的再讨论

下面的情况是合法的，只不过前面的 multret 只返回一个值，而最后的可利用多个值

#+begin_src lua
local a, b, c = ..., ..., ...
#+end_src

***** normal

没有赋值，等于 nexps = 0 的最小情况

var exp 的数量关系

exp 多则舍弃
var 多则置 nil

#+begin_src lua
local a, b, c, d, e = 10, "second", nil, true, false
#+end_src

#+begin_example
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 5 stacks
.function  0 0 2 5
.local  "a"  ; 0
.local  "b"  ; 1
.local  "c"  ; 2
.local  "d"  ; 3
.local  "e"  ; 4
.const  10  ; 0
.const  "second"  ; 1
[1] loadk      0   0        ; 10
[2] loadk      1   1        ; "second"
[3] loadnil    2   2      
[4] loadbool   3   1   0    ; true
[5] loadbool   4   0   0    ; false
[6] return     0   1      
; end of function
#+end_example


下面来看赋值的情况，3 个变量均衡赋值。

根据语法描述，左侧 var 结束之后，右侧部分都作为 explist 来解析，最终再完成赋值

是典型的后缀形式的语法制导。

这里先不重点讲 explist -> expr 的解析过程，只用几个基本类型，在 lex 阶段就可以确定的。

lparser.c:599

可确定 expr 的描述 v




使用 luaK_exp2nextreg

TODO freereg 的指导作用
TODO 为何这样是正确的，什么时候进行回收？

按照 freereg 所指的顺序，依次向上存储

exp2reg freereg

discharge2reg，将 exp 对应到 reg 即 local 中

其中 VKNUM 直接存储入 k 表，生成 loadk 指令，使用 k 索引

TK_STRING 在之前已经变成 VK，加在 k 表中的索引，同样生成 loadk 指令

解析之后，exp 类型变为 VNONRELOC，info 中存储结果所在的寄存器


在这个过程中，已经生成了 相关的 load 指令，到 freereg 的位置
因为 exp 出现的顺序，和 var 出现的顺序对应，巧妙完成了赋值

***** k table

通过 numberK 和 stringK 方法

在 addk 过程，
fs->h 是一个 table，用于对 f->k 进行反向索引
先在 h 中查找，是否已经有相应索引，可以直接返回
如果没有，则新增一项

fs->nk++


lcode.c:229-278

k 表只存储如下几种常量
- nil
- bool
- number
- string

nil bool 在赋值时并没有使用 loadk，而使用 loadnil loadbool 指令
插入 k 表用在别的地方
- index
- binop
- compare


*** nonlocal assignment

exprstat -> assignment stat

**** global

#+begin_src lua
a, b, c = 10, 20, 30
#+end_src

进入 primaryexp prefixexp 查找的时候，TK NAME 要进行 singlevar 查找

赋值为 VGLOBAL，且 info 存储了名字对应的 k 表索引
和 expkind 的注释不符合？



进入 assignment，按照 ebnf ，本身是嵌套的
进入之前，先将 v prev 设置为 NULL，后面全部链接起来


LHS_assign 结构，在 expdesc 的基础上，添加了 prev 指针

在 多个 , 之间的 var 全部链接起来

其中可赋值的类型为
VLOCAL VUPVAL VGLOBAL VINDEXED
由 primaryexp 决定


赋值阶段，在每个递归层次，用 luaK_storevar 来存储



var ex

先 discharge ex
再生成 SETGLOBAL，使用 info 中存储的 k 索引
gbl[kst[info]] = R(A)




luaK_exp2anyreg

只需要解析到 reg 就可以，临时使用，赋值之后就废弃


exp 可能是 var，也可能是 值
但是通过 dis var 是保险的

默认依然使用 exp2nextreg，只不过在之前，添加了解析 jump 的部分

exp2nextreg，存储在 freereg 之后

exp2reg，存储到指定 reg

其中解析了 jump 相关的内容

最终成为 VNONRELOC



**** upvalue

#+begin_src lua
local a = 10

function f()
  a = 20
end
#+end_src

和 global 相似

**** indexed

a.b   a['b']
是相同语义

a 必须是 table，语义才正确


gettable 中，之所以使用 RK(C) 这种方法，是因为索引值未必是 constant，也可能是
一个表，一个函数，等其它值，这种值只能由 寄存器 存储

同时，加上了 k，也可以节省临时寄存器的使用

如果超出了 k 表的范围，大于 256，需要临时先加载入 寄存器

*** do

- block vs chunk
  - 整体文件按照 chunk 来解析，chunk 是入口
  - block ::= chunk，但具体使用方式要根据语句的类型来分析
    并非所有引用 chunk 的地方都会像 function 结构使用 chunk 会影响 fs 结构，
    更多依赖 chunk 递归处理语句的便利
- 分类
  - loop 中
  - 非 loop 中

blockCnt
- previous
- nactvar，进入 block 前 nactvar 的个数
- isbreakable，是否用在循环中，从 bnf 中可看到
- breaklist，chain of jump out of the loop，在 while 时深入
- upval，bool，当前作用域中是否有 local var 作为 upval，在 for 时深入

明显的作用域分隔作用

enterblock
leaveblock

在进入时，nactvar 记录 active local var 的数量，
block 内新的 local var 会在离开时，全部释放
符合作用域的原则
内部使用，销毁，不污染外部

#+CAPTION: 24 do block

作用域记录在 fs 中，最终要体现到 f 中
最终在 do 之外，使用 b，会顺着 a 0 的顺序向后，b 1
说明前面的所有变量已回收

虽然有多个 block 相隔，但是在最内层进行变量查找的时候，上层的所有 act local var 都
属于同一个 fs，查找 a 的时候，a 的类型为 local，直接进行了修改
a 并不是 upval，可见 upval 只针对 function 而言

非 loop 只有 nactvar 起作用

loop 情况，到 while for 具体分析。

*** if

顺序解析的难题之一
分支

- jump chain resolve

#+CAPTION: 25 if else code pattern


concat

patch

patch to here, concat

patch to list, discharge right now to target

they are the same

dischargejpc




luaK_jump 时，使用 jpc 重置的技巧，防止在生成 jump 时，触发 dischargejpc

**** if

dischargejpc
负责从当前 pc 解析 jump chain

隐藏在 luaK_code 中


问题添加 return 0 1 的原因

#+CAPTION: 26 if chain

**** if else

#+CAPTION: 27 if else chain

**** if elseif

#+CAPTION: 28 if elseif chain

**** if elseif else

#+CAPTION: 29 if elseif else chain

*** while

#+CAPTION: 30 while pattern

block

breakable  1
这样其中才可以生成 break 语句

breaklist
用于记录 break 语句，chain 到 block 外的第一条语句

enterblock 自然生成 0 block

相当于有双层 block

**** break

#+CAPTION: 30 break in while
     
*** repeat

repeat    

#+CAPTION: 31 repeat

break 同 while 时的表现相同


不过对于 upval，有自己的处理方式


因为 while 在 cond 中不能定义新的 local var
而 repeat 的 block 中可能先定义 local var
再被其中的 func 引用，而 i 在不断变化，就需要及时 close




#+begin_src lua :results output
local t = {}

local c = 0

repeat
   c = c + 1

   local i = c

   t[i] = function ()
      return i
   end
until i > 10

for i, f in ipairs(t) do
   print(f())
end
#+end_src

#+RESULTS:
#+begin_example
1
2
3
4
5
6
7
8
9
10
11
#+end_example

进行 upval 判断的原因

每个 func 记录的都是 i，但是每次 loop 结束都进行了 close，


#+CAPTION: 31 repeat upval


*** for

for loop 特别开发了底层指令来处理，而 repeat 和 while 则没有相应的指令。
依然是通过 jmp 来实现的。

分为两种

数字迭代 fornum

#+begin_src lua
for i = 1, 10, 2 do
  print(i)
end
#+end_src

通用迭代 forlist

#+begin_src lua
for k, v in pairs(t) do
  print(k, v)
end
#+end_src


**** fornum

隐式生成的变量，用 ( 来标识，是不会与正常 lua 代码中分析得到的 NAME 冲突的
因为 lex 规则的限定

#+begin_example
.local  "(for generator)"  ; 0
.local  "(for state)"  ; 1
.local  "(for control)"  ; 2
#+end_example

#+CAPTION: 32 for and upval

**** forlist

#+begin_src lua :results output
local g, s = pairs({1,2,3})

for k, v in g, s, nil do
  print(k, v)
end
#+end_src

#+RESULTS:
: 1	1
: 2	2
: 3	3

#+CAPTION: 33 for and upval

upvalue 同 fornum

*** function call

如果不匹配，应该在 vm 时发生作用    

call ins

**** args?

**** returns?

**** vararg


**** tailcall?

*** ret

return ins

return 在 chunk 中发挥作用
从当前 closure 中返回

return 必须是 chunk 的最后一个语句



** practice

*** arithmetic

- 优先级

lua 在进行解析时，没有进行关系运算的实时解析，但是对 constant 算法运算有编译时执行

如 `local a = 5 > 2` 和 `local a = 1 + 2` 的区别

前者需要生成 jmp 指令，但是后者，直接是 loadk 0 0 ; 3

*** logic

- and or

*** constructor

- setlist always consistent, diff with settable

