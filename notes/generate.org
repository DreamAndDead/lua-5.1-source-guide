#+SETUPFILE: setup.org

* generate

parser 介绍了整体的语法分析过程

gen 来详细深入，隐藏在语法分析过程之下的代码生成部分

#+CAPTION: fs f combine picture

生成过程的模型和实际运行的模型，连接点是对 stack 的隐式共识，实际以 proto 传递。


规则间的同义转换

语法规则    vm opcode 规则

生成过程，就是等义转换的过程

隐藏在语法分析下的艺术


语法制导翻译

把一些属性附加到代表语言构造的文法符号上，从而把信息和一个语言的构造联系起来


通用方式，是通过语法分析，得到 ast，进行属性计算
很多情况下，翻译可以在扫描过程中完成

L 属性翻译


语法制导
中间代码
代码生成

完全整合在一起

能正确运行已经是奇迹



gen 的这一步，多关乎两者之间的连接过程
中间状态

为了达到最终的结果，中间的阶段



在生成的过程中，有一个 imaginary 的栈，和相应 imaginary 的操作存储在 code


** big picture
   :LOGBOOK:
   - Note taken on [2020-12-10 四 10:08] \\
     why ~function~ concept is important in lua!
   - Note taken on [2020-12-07 一 13:54] \\
   lexical scoping 和 syntax scoping 的区别？ 闭包的不同实现？
   :END:




#+CAPTION: luaY_parser function

概念 vs
- function，是 lua 中的概念，函数
- proto，是 function 分析之后的同语义结构
- closure，封装 proto，提供 upval 空间，用于 vm 运行时

Proto 最终生成的 bytecode 与相关环境
基本可以将 proto 等同于生成的可执行文件，交给 vm 就可以执行，不过其中有一些结构上的安排。

一个 function 对应生成一个 proto，一个 lua 文件，可被认为是一个匿名函数
故最终返回的是一个 proto。

function 是基础类型，如果 lua 文件作为一级函数，则其中定义的函数为二级函数

其中函数内部定义的函数为三级函数，可以不断向下延伸

每一级函数，在 **p 中记录其包含的下一级函数，根据出现的顺序，用数组来记录。


#+CAPTION: proto and function


以 function 为单位，生成一块一块的 proto，组合在一起。


前面提到过，在词法分析的过程中，有 lexstate 结构，它存储了一切词法分析过程中的状态
在生成过程中，也存在如此结构，称为 funcstate，存储生成过程中涉及到的状态
其中的 proto 就是生成的结果。

总体过程如下。

#+CAPTION: ls fs f big picture

可以看出，ls 是单例，向 fs 输入 token，并在不同的 func 层次，对接不同的 fs 结构。

每当生成一个新的 function，都会新建一个 fs，并指向父 fs，并对接 ls，生成自己的 f
在结束之后，将 f 的结果并入父 fs 的 f 中。


其实 fs 和 f 几乎是一个整体，总是同时行动。
区别在于，proto 作为最终返回的结果，内容最小化，不多不少
而作为中间过程中相关的 state，并不是 vm 需要关心的，所以就剔除到 fs 结构中了。


ls fs 在 gen 的过程中，都只是承担着一个中间作用，辅助作用，生成返回 f 之后，就被丢弃。








其中的 k 表，opcode，就是在 vm 模型讨论的，
关于 upval 的信息，隐藏在了 code 中。
#+INCLUDE: ../lua-5.1.5/src/lobject.h src c :lines "228-254"


- func state
#+INCLUDE: ../lua-5.1.5/src/lparser.h src c :lines "57-76"





为什么 local var 和 active local var 存储在两个部分？

因为相应的索引，在生成 code 之后，相当于信息已经存储于 code 的参数中，不需要另行存储
且 active 只记录一种状态而已，辅助生成正确的代码，在不同阶段是不同的。

因为 active 状态只能在 parse 过程分辨。
离开作用域自然不是 active 的。
而是否 active 对于 bytecode 并不重要。
active 状态用于辅助 funcstate 生成 bytecode。












#+CAPTION: lex next -> Y parser -> proto



#+CAPTION: ls fs f structure, proto and cascade proto for functions



#+CAPTION: fs f inside

fs->f->sizek 和 fs->nk 是有区别的
nk 是随着实际情况准确的在变化，而 sizek 准确的说，更像是在记录扩容的空间大小
如 length 和 capacity 的区别
当然，最终分析完成之后，会使用赋值 sizek = nk，作为最终的生成结果

f k  fs nk
f p  fs np
f code  fs pc
fs actvar  fs nactvar
f locvars  fs nlocvars

fs upvalues  f nups
f upvalues  f nups




代码的生成过程有一个隐式的假设，对 vm 的运作方式有明显的假定
如果纯粹的分离开来，应该对一套 opcode 进行编程
但是这里 opcode 的定义显然就是 vm 本身


** tools

make spy

make inspect

chunkspy 中 .local .const 的概念对应

#+begin_example
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 3 stacks
.function  0 0 2 3
.local  "a"  ; 0
.local  "b"  ; 1
.local  "c"  ; 2
[1] return     0   1      
; end of function
#+end_example

line 1
level 1 指的是第一层级
function [0] 表明是当前层级的第 1 个函数（以 0 开始索引）

line 2
0 个 upvalue
0 个参数
0b010 接收可变参数
3 需要分配栈容量，2 是最小值，来源于在不断的运算过程中，栈增长减少，遇到的最大值

line 3
和 line 2 相同，2 是 3 的注释

line 4 5 6
.local f->locvars 内容

line 7
f->code 指令
最终一行总是默认生成一条 return 指令
这里只有一条 return，说明代码并没有生成代码

line 8
function 结束注释



** TODO expdesc
    :LOGBOOK:
    - Note taken on [2020-12-07 一 17:34] \\
      各个状态如何发生作用？
    :END:

exp desc

exp 基本运作单元

desc 描述其属性，是 ast 到 code 的纽带

#+INCLUDE: ../lua-5.1.5/src/lparser.h src c :lines "19-46"



- VVOID 什么都不做
- VNIL  nil 值
- VTRUE
- VFALSE bool
- VK    在 k 表中的值
- VKNUM 数字字面量

没有 string 类型，因为在读取的过程中，直接将其放入 k 表中，变成 VK 类型了


- 
- 



TODO desc 到 reg 的轨迹追踪？


discharge2reg

VNIL loadnil 
VTRUE VFALSE loadbool




全部变成 NONRELOC，并保存 reg 值

VVOID VJMP 不处理





** register
   :LOGBOOK:
   - Note taken on [2020-12-07 一 14:01] \\
   如何调度寄存器？
   :END:

register is stack

parse 生成 bytecode，关于寄存器的使用，只是从表面上生成相应的索引
因为 parser 知道自己使用了哪些寄存器，还有哪些可以使用，这些信息是 运行时的 vm 所不知道的

move a b

但是并不分配寄存器的空间，只是用来调度使用哪个寄存器
因为这是编译时，而不是运行时
    

** variable

变量有 3 类，local upval global

*** local

local 变量的作用范围（active），开始于在作用域中出现的一刻，到作用域结束。

作用域是有明显的栈特性的，新作用域入栈，离开作用域出栈

在一个作用域内，local 变量按照声明顺序入栈，离开作用域时全部出栈，local var dead，让出空间

这样栈中从 base 到 top，就始终记录着 active local 变量，作用范围由大到小。

#+CAPTION: 16 active local scope & fs->actvar nactvar

利用这种特征，在 fs 中用 actvar 和 nactvar 始终记录着当前 active local var 的状态。

#+CAPTION: 16 actvar & locvars

statement/scope.lua

b lparser.c:1306

fs->nlocvars 的原因，不需要这个变量，nlocvars 只用来指向下一个可放置的位置

local 只在使用时发生作用，而在使用时，已经被记录在 code 中了

*** upvalue

#+begin_quote
对象是带函数的值
闭包是带值的函数
#+end_quote

#+begin_src lua :results output
local function outer()
   local a = 0

   local function inner()
      local b = 0

      a = a + 1
      return a
   end

   inner()

   return inner
end

local f = outer()

print(f())
print(f())
print(f())

local g = outer()

print(g())
print(g())
print(g())
#+end_src

#+RESULTS:
: 2
: 3
: 4
: 2
: 3
: 4

function 作为基础类型之一，可以作为普通变量，参数，返回值，赋值，而四处流转

这种情况下，和 local 作用域机制在一起，就会出现问题

a 的作用域在 outer 内部，同时被 inner 引用并修改，最终 outer 返回 inner

调用 outer，赋值给 f

按照语义，f 应该是内部的 inner func，每次调用都得到 a 的自增值

调用 3 次，得到 1 2 3

问题在于，a 只作用在 outer 内部，而 f 在 outer 外部，已经离开了 a 的作用域，
在这种情况下如何保证语义的正确？

这便是闭包机制的由来，a 对于 inner 而言，不是 local，而是 upvalue 类型。

这也是 lua 中为何 func 不是 func 而是 closure 的原因，func 及 upvalue 组成了 closure，
所有 func 在运行时都封装为 closure 来运行，其中重要的原因就在于分配 upvalue 空间。

#+CAPTION: 17 upvalue at runtime

再调用 outer，赋值给 g，调用 3 次，得到一样的结果，从中可以得到 upvalue 作用于 active 和
dead 状态的区别。

*** global

前面提到了 local 变量的作用域，以及 upvalue 出现的原因及解决方法。

其中隐含的一点，外层变量对于内层可见，假如强制设定外层对于内部不可见，便不会有 upvalue 的问题。

对于可见的情况，对于当前引用的变量，自然有一个查找的过程。
和嵌套相反，是层层向上寻找的过程。

变量
在本层可以找到的，为 local
在本层之外可以找到的，为 upvalue
所有层都无法找到的，为 global

global 的概念解决了两个细节问题
为什么顶层的 function 是没有 upvalue 的？
因为在本层找不到的变量，向上已经没有层级，只能是 global

setfenv 的概念
函数的运行环境，即是 global，在编译的 chunk 运行之前，设定 global 的值，
可以影响内部对 global 值的引用，从而实现不同的运行效果。


在实现中，global 是单独于基层的 closure 存在的，是运行状态的一部分
所以不存在作用域的问题，始终在顶层。


#+begin_src lua :results output
local function outer()
  a = 10

  local function inner()
    a = a + 1
    return a
  end

  return inner
end

local f = outer()

print(f(), a)
print(f(), a)
print(f(), a)
#+end_src

#+RESULTS:
: 11	11
: 12	12
: 13	13

#+CAPTION: 18 global at runtime

** statement
   :LOGBOOK:
   - Note taken on [2020-12-09 三 13:35] \\
     先从 stat 开始分析，将得到的经验抽象为内容。
   :END:

*** local assignment

#+begin_src bnf
localstat ::= LOCAL NAME {`,' NAME} [`=' explist]
localstat ::= LOCAL FUNCTION NAME body
#+end_src


#+begin_src lua
local function f()
end

local f = function ()
end
#+end_src

localstat 有两种情况，func 的情况之后到 function 部分再讨论。
另一种情况是局部变量声明，分为是否赋值两种情况。

localstat vs localfunc


**** no assignment

#+begin_src lua
local a, b, c
#+end_src

#+begin_example
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 3 stacks
.function  0 0 2 3
.local  "a"  ; 0
.local  "b"  ; 1
.local  "c"  ; 2
[1] return     0   1      
; end of function
#+end_example

考虑如上代码，声明局部变量 a。

没有生成代码，毕竟没有任何运算或者操作

所以只存储了 local 变量的信息

#+CAPTION: 18 local no assignment

lparser.c:143
=registerlocalvar= 是操作 f->locvars 的过程

lparser.c:163
=new_localvar= 是操作 fs->actvar 的过程

先注册，再存储相应的索引


expdesc 为 VVOID，因为没有 exp，没有赋值
e 记录的是最后一个 expr 的属性



nvars = nexps


=adjust_assign= 进行左右数量的调整

多余空间置为 nil

TODO 因为 luaK_nil 的优化过程，没有生成代码

调整了 freereg 的值，是进行中间运算的安排的



=adjustlocalvars= 调整 nactvar 的值，并设置相应的 startpc


**** with assignment

***** TODO multret

TODO 有 multret 的再讨论

下面的情况是合法的，只不过前面的 multret 只返回一个值，而最后的可利用多个值

#+begin_src lua
local a, b, c = ..., ..., ...
#+end_src

***** normal

没有赋值，等于 nexps = 0 的最小情况

var exp 的数量关系

exp 多则舍弃
var 多则置 nil

#+begin_src lua
local a, b, c, d, e = 10, "second", nil, true, false
#+end_src

#+begin_example
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 5 stacks
.function  0 0 2 5
.local  "a"  ; 0
.local  "b"  ; 1
.local  "c"  ; 2
.local  "d"  ; 3
.local  "e"  ; 4
.const  10  ; 0
.const  "second"  ; 1
[1] loadk      0   0        ; 10
[2] loadk      1   1        ; "second"
[3] loadnil    2   2      
[4] loadbool   3   1   0    ; true
[5] loadbool   4   0   0    ; false
[6] return     0   1      
; end of function
#+end_example


下面来看赋值的情况，3 个变量均衡赋值。

根据语法描述，左侧 var 结束之后，右侧部分都作为 explist 来解析，最终再完成赋值

是典型的后缀形式的语法制导。

这里先不重点讲 explist -> expr 的解析过程，只用几个基本类型，在 lex 阶段就可以确定的。

lparser.c:599

可确定 expr 的描述 v




使用 luaK_exp2nextreg

TODO freereg 的指导作用
TODO 为何这样是正确的，什么时候进行回收？

按照 freereg 所指的顺序，依次向上存储

exp2reg freereg

discharge2reg，将 exp 对应到 reg 即 local 中

其中 VKNUM 直接存储入 k 表，生成 loadk 指令，使用 k 索引

TK_STRING 在之前已经变成 VK，加在 k 表中的索引，同样生成 loadk 指令

解析之后，exp 类型变为 VNONRELOC，info 中存储结果所在的寄存器


在这个过程中，已经生成了 相关的 load 指令，到 freereg 的位置
因为 exp 出现的顺序，和 var 出现的顺序对应，巧妙完成了赋值


***** k table

通过 numberK 和 stringK 方法

在 addk 过程，
fs->h 是一个 table，用于对 f->k 进行反向索引
先在 h 中查找，是否已经有相应索引，可以直接返回
如果没有，则新增一项

fs->nk++


lcode.c:229-278

k 表只存储如下几种常量
- nil
- bool
- number
- string

nil bool 在赋值时并没有使用 loadk，而使用 loadnil loadbool 指令

插入 k 表用在别的地方
- index
- binop
- compare




discharge vars 意思是解析变量，比如

```
a = 1
```

在赋值之间，要先解析 1，从 k 表中将 1 加载到栈中，
然后再设置到全局表。

解析 1 的过程就是 discharge。

生成的 bytecode 也就在 assignment 的前面。





**** globals

将 10 存入 k 表，将 a 存入 locvars 表中（其中存储了名字 "a"）。
使用 loadk 指令，将 k 中的 10 加载入 reg 中。

如果是

```lua
a = 1
```

则直接将名字 "a" 和 1 都保存在 k 表。

需要通过 "a" 来索引全局变量。这一点和 local var 完全不同。




*** if

jump chain    

*** do

*** while & repeat

*** break

*** for

- blockCnt

for loop 特别开发了底层指令来处理，而 repeat 和 while 则没有相应的指令。
依然是通过 jmp 来实现的。

两种


数字迭代 fornum

#+begin_src lua
for i = 1, 10, 2 do
  local j = i * i
end
#+end_src

通用迭代 forlist

#+begin_src lua
for k, v in pairs(t) do
  print(k, v)
end
#+end_src


隐式生成的变量，用 ( 来标识，是不会与正常 lua 代码中分析得到的 NAME 冲突的
因为 lex 规则的限定

#+begin_example
.local  "(for generator)"  ; 0
.local  "(for state)"  ; 1
.local  "(for control)"  ; 2
#+end_example

*** function
    
func 有同名和匿名两种

从 ebnf 中可以看出，两者只差在 NAME

几乎全部由 body 处理

包含了参数，函数体等全部

动态类型，名称与值的绑定，所以由 body 来处理全部


  - proto list

*** ret

*** expr


**** function call

**** assignment

**** arithmetic
    
**** compare

 lua 在进行解析时，没有进行关系运算的实时解析，但是对 constant 算法运算有编译时执行

 如 `local a = 5 > 2` 和 `local a = 1 + 2` 的区别

 前者需要生成 jmp 指令，但是后者，直接是 loadk 0 0 ; 3

**** constructor

*** upvalue

- upval list
- close op

** opcode
    
*** move
     
move code 发生在 assignment 环节

在这里要进行值的迁移


luaK_storevar 生成了 move 指令

exp2reg?

对于赋值，= 后是 exp，前是存储空间

后面的 exp 要经过解析，才能向前赋值



*** table related

gettable 中，之所以使用 RK(C) 这种方法，是因为索引值未必是 constant，也可能是
一个表，一个函数，等其它值，这种值只能由 寄存器 存储

同时，加上了 k，也可以节省临时寄存器的使用

如果超出了 k 表的范围，大于 256，需要临时先加载入 寄存器


*** upval related

在 pascal 中，在 outer scope 的变量，可以通过 frame stack 去查找

但是在 lua 中，函数也是一种值，可以四处流转，说不定在什么地方调用
所以其 upvalue 不一定出现在 stack frame 上

