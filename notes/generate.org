#+SETUPFILE: setup.org

* generate

- generic
  - expdesc
  - alloc stack
  - var type
    - local
    - upval
    - global
  - k table
  - proto list
  - upval list
- statement
  - if
    - jump chain
  - for
    - blockCnt
    - do end, chunk is not block
  - function
    - upval
  - ...
- opcode
  - close
  - ...


规则间的同义转换

语法规则    vm opcode 规则

生成过程，就是等义转换的过程

隐藏在语法分析下的艺术


语法制导翻译

把一些属性附加到代表语言构造的文法符号上，从而把信息和一个语言的构造联系起来


通用方式，是通过语法分析，得到 ast，进行属性计算
很多情况下，翻译可以在扫描过程中完成

L 属性翻译


语法制导
中间代码
代码生成

完全整合在一起

能正确运行已经是奇迹



gen 的这一步，多关乎两者之间的连接过程
中间状态

为了达到最终的结果，中间的阶段


** big picture
   :LOGBOOK:
   - Note taken on [2020-12-07 一 13:54] \\
   lexical scoping 和 syntax scoping 的区别？ 闭包的不同实现？
   :END:

#+CAPTION: luaY_parser function



概念 vs
- function，是 lua 中的概念，函数
- proto，是 function 分析之后的同语义结构
- closure，封装 proto，提供 upval 空间，用于 vm 运行时



Proto 最终生成的 bytecode 与相关环境
基本可以将 proto 等同于生成的可执行文件，交给 vm 就可以执行，不过其中有一些结构上的安排。

一个 function 对应生成一个 proto，一个 lua 文件，可被认为是一个匿名函数
故最终返回的是一个 proto。

function 是基础类型，如果 lua 文件作为一级函数，则其中定义的函数为二级函数

其中函数内部定义的函数为三级函数，可以不断向下延伸

每一级函数，在 **p 中记录其包含的下一级函数，根据出现的顺序，用数组来记录。


#+CAPTION: proto and function


以 function 为单位，生成一块一块的 proto，组合在一起。


前面提到过，在词法分析的过程中，有 lexstate 结构，它存储了一切词法分析过程中的状态
在生成过程中，也存在如此结构，称为 funcstate，存储生成过程中涉及到的状态
其中的 proto 就是生成的结果。

总体过程如下。

#+CAPTION: ls fs p big picture

可以看出，ls 是单例，向 fs 输入 token，并在不同的 func 层次，对接不同的 fs 结构。

每当生成一个新的 function，都会新建一个 fs，并指向父 fs，并对接 ls，生成自己的 f
在结束之后，将 f 的结果并入父 fs 的 f 中。


其实 fs 和 f 几乎是一个整体，总是同时行动。
区别在于，proto 作为最终返回的结果，内容最小化，不多不少
而作为中间过程中相关的 state，并不是 vm 需要关心的，所以就剔除到 fs 结构中了。


ls fs 在 gen 的过程中，都只是承担着一个中间作用，辅助作用，生成返回 f 之后，就被丢弃。








其中的 k 表，opcode，就是在 vm 模型讨论的，
关于 upval 的信息，隐藏在了 code 中。
#+INCLUDE: ../lua-5.1.5/src/lobject.h src c :lines "228-254"


- func state
#+INCLUDE: ../lua-5.1.5/src/lparser.h src c :lines "57-76"






为什么 local var 和 active local var 存储在两个部分？

因为相应的索引，在生成 code 之后，相当于信息已经存储于 code 的参数中，不需要另行存储
且 active 只记录一种状态而已，辅助生成正确的代码，在不同阶段是不同的。

因为 active 状态只能在 parse 过程分辨。
离开作用域自然不是 active 的。
而是否 active 对于 bytecode 并不重要。
active 状态用于辅助 funcstate 生成 bytecode。




discharge vars 意思是解析变量，比如

```
a = 1
```

在赋值之间，要先解析 1，从 k 表中将 1 加载到栈中，
然后再设置到全局表。

解析 1 的过程就是 discharge。

生成的 bytecode 也就在 assignment 的前面。




fs->f->sizek 和 fs->nk 是有区别的
nk 是随着实际情况准确的在变化，而 sizek 准确的说，更像是在记录扩容的空间大小
如 length 和 capacity 的区别
当然，最终分析完成之后，会使用赋值 sizek = nk，作为最终的生成结果







- expdesc

#+INCLUDE: ../lua-5.1.5/src/lparser.h src c :lines "19-46"





#+CAPTION: lex next -> Y parser -> proto



#+CAPTION: L ls fs p structure


** TODO expdesc
    :LOGBOOK:
    - Note taken on [2020-12-07 一 17:34] \\
      各个状态如何发生作用？
    :END:

exp desc

exp 基本运作单元

desc 描述其属性，是 ast 到 code 的纽带

** register
   :LOGBOOK:
   - Note taken on [2020-12-07 一 14:01] \\
   如何调度寄存器？
   :END:


parse 生成 bytecode，关于寄存器的使用，只是从表面上生成相应的索引
因为 parser 知道自己使用了哪些寄存器，还有哪些可以使用，这些信息是 运行时的 vm 所不知道的

move a b

但是并不分配寄存器的空间，只是用来调度使用哪个寄存器
因为这是编译时，而不是运行时
    

** statement

*** local assignment

```lua
local a = 10
```

将 10 存入 k 表，将 a 存入 locvars 表中（其中存储了名字 "a"）。
使用 loadk 指令，将 k 中的 10 加载入 reg 中。


如果是

```lua
a = 1
```

则直接将名字 "a" 和 1 都保存在 k 表。

需要通过 "a" 来索引全局变量。这一点和 local var 完全不同。


通过 numberK 和 stringK 方法

每个 function 都有一个 k 表，而且可以去重存储。

*** arithmetic


*** compare

lua 在进行解析时，没有进行关系运算的实时解析，但是对 constant 算法运算有编译时执行

如 `local a = 5 > 2` 和 `local a = 1 + 2` 的区别

前者需要生成 jmp 指令，但是后者，直接是 loadk 0 0 ; 3


*** loop

**** for

for loop 特别开发了底层指令来处理，而 repeat 和 while 则没有相应的指令。
依然是通过 jmp 来实现的。

**** while & repeat


** opcode
    
*** move
     
move code 发生在 assignment 环节

在这里要进行值的迁移


luaK_storevar 生成了 move 指令

exp2reg?

对于赋值，= 后是 exp，前是存储空间

后面的 exp 要经过解析，才能向前赋值



*** loadnil

luaK_nil()


*** table related

gettable 中，之所以使用 RK(C) 这种方法，是因为索引值未必是 constant，也可能是
一个表，一个函数，等其它值，这种值只能由 寄存器 存储

同时，加上了 k，也可以节省临时寄存器的使用

如果超出了 k 表的范围，大于 256，需要临时先加载入 寄存器


*** upval related

在 pascal 中，在 outer scope 的变量，可以通过 frame stack 去查找

但是在 lua 中，函数也是一种值，可以四处流转，说不定在什么地方调用
所以其 upvalue 不一定出现在 stack frame 上

