#+SETUPFILE: setup.org

* generate

parser 介绍了整体的语法分析过程

gen 来详细深入，隐藏在语法分析过程之下的代码生成部分

#+CAPTION: fs f combine picture

生成过程的模型和实际运行的模型，连接点是对 stack 的隐式共识，实际以 proto 传递。


规则间的同义转换

语法规则    vm opcode 规则

生成过程，就是等义转换的过程

隐藏在语法分析下的艺术


语法制导翻译

把一些属性附加到代表语言构造的文法符号上，从而把信息和一个语言的构造联系起来


通用方式，是通过语法分析，得到 ast，进行属性计算
很多情况下，翻译可以在扫描过程中完成

L 属性翻译


语法制导
中间代码
代码生成

完全整合在一起

能正确运行已经是奇迹



gen 的这一步，多关乎两者之间的连接过程
中间状态

为了达到最终的结果，中间的阶段


** big picture
   :LOGBOOK:
   - Note taken on [2020-12-07 一 13:54] \\
   lexical scoping 和 syntax scoping 的区别？ 闭包的不同实现？
   :END:

#+CAPTION: luaY_parser function

概念 vs
- function，是 lua 中的概念，函数
- proto，是 function 分析之后的同语义结构
- closure，封装 proto，提供 upval 空间，用于 vm 运行时

Proto 最终生成的 bytecode 与相关环境
基本可以将 proto 等同于生成的可执行文件，交给 vm 就可以执行，不过其中有一些结构上的安排。

一个 function 对应生成一个 proto，一个 lua 文件，可被认为是一个匿名函数
故最终返回的是一个 proto。

function 是基础类型，如果 lua 文件作为一级函数，则其中定义的函数为二级函数

其中函数内部定义的函数为三级函数，可以不断向下延伸

每一级函数，在 **p 中记录其包含的下一级函数，根据出现的顺序，用数组来记录。


#+CAPTION: proto and function


以 function 为单位，生成一块一块的 proto，组合在一起。


前面提到过，在词法分析的过程中，有 lexstate 结构，它存储了一切词法分析过程中的状态
在生成过程中，也存在如此结构，称为 funcstate，存储生成过程中涉及到的状态
其中的 proto 就是生成的结果。

总体过程如下。

#+CAPTION: ls fs f big picture

可以看出，ls 是单例，向 fs 输入 token，并在不同的 func 层次，对接不同的 fs 结构。

每当生成一个新的 function，都会新建一个 fs，并指向父 fs，并对接 ls，生成自己的 f
在结束之后，将 f 的结果并入父 fs 的 f 中。


其实 fs 和 f 几乎是一个整体，总是同时行动。
区别在于，proto 作为最终返回的结果，内容最小化，不多不少
而作为中间过程中相关的 state，并不是 vm 需要关心的，所以就剔除到 fs 结构中了。


ls fs 在 gen 的过程中，都只是承担着一个中间作用，辅助作用，生成返回 f 之后，就被丢弃。








其中的 k 表，opcode，就是在 vm 模型讨论的，
关于 upval 的信息，隐藏在了 code 中。
#+INCLUDE: ../lua-5.1.5/src/lobject.h src c :lines "228-254"


- func state
#+INCLUDE: ../lua-5.1.5/src/lparser.h src c :lines "57-76"





为什么 local var 和 active local var 存储在两个部分？

因为相应的索引，在生成 code 之后，相当于信息已经存储于 code 的参数中，不需要另行存储
且 active 只记录一种状态而已，辅助生成正确的代码，在不同阶段是不同的。

因为 active 状态只能在 parse 过程分辨。
离开作用域自然不是 active 的。
而是否 active 对于 bytecode 并不重要。
active 状态用于辅助 funcstate 生成 bytecode。












#+CAPTION: lex next -> Y parser -> proto



#+CAPTION: ls fs f structure, proto and cascade proto for functions



#+CAPTION: fs f inside

fs->f->sizek 和 fs->nk 是有区别的
nk 是随着实际情况准确的在变化，而 sizek 准确的说，更像是在记录扩容的空间大小
如 length 和 capacity 的区别
当然，最终分析完成之后，会使用赋值 sizek = nk，作为最终的生成结果

f k  fs nk
f p  fs np
f code  fs pc
fs actvar  fs nactvar
f locvars  fs nlocvars

fs upvalues  f nups
f upvalues  f nups

** tools

make spy

make inspect

chunkspy 中 .local .const 的概念对应

#+begin_example
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 3 stacks
.function  0 0 2 3
.local  "a"  ; 0
.local  "b"  ; 1
.local  "c"  ; 2
[1] return     0   1      
; end of function
#+end_example

line 1
level 1 指的是第一层级
function [0] 表明是当前层级的第 1 个函数（以 0 开始索引）

line 2



** TODO expdesc
    :LOGBOOK:
    - Note taken on [2020-12-07 一 17:34] \\
      各个状态如何发生作用？
    :END:

exp desc

exp 基本运作单元

desc 描述其属性，是 ast 到 code 的纽带

#+INCLUDE: ../lua-5.1.5/src/lparser.h src c :lines "19-46"


** register
   :LOGBOOK:
   - Note taken on [2020-12-07 一 14:01] \\
   如何调度寄存器？
   :END:


how to alloc register

register is stack



parse 生成 bytecode，关于寄存器的使用，只是从表面上生成相应的索引
因为 parser 知道自己使用了哪些寄存器，还有哪些可以使用，这些信息是 运行时的 vm 所不知道的

move a b

但是并不分配寄存器的空间，只是用来调度使用哪个寄存器
因为这是编译时，而不是运行时
    


** statement
   :LOGBOOK:
   - Note taken on [2020-12-09 三 13:35] \\
     先从 stat 开始分析，将得到的经验抽象为内容。
   :END:

*** local assignment

#+begin_src bnf
localstat ::= LOCAL NAME {`,' NAME} [`=' explist]
localstat ::= LOCAL FUNCTION NAME body
#+end_src

localstat 有两种情况，func 的情况之后到 function 部分再讨论。
另一种情况是局部变量声明，分为是否赋值两种情况。

**** no assignment

#+begin_src lua
local a, b, c
#+end_src

#+begin_example
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 3 stacks
.function  0 0 2 3
.local  "a"  ; 0
.local  "b"  ; 1
.local  "c"  ; 2
[1] return     0   1      
; end of function
#+end_example

考虑如上代码，声明局部变量 a。





**** with assignment

#+begin_src lua
local a
#+end_src

将 10 存入 k 表，将 a 存入 locvars 表中（其中存储了名字 "a"）。
使用 loadk 指令，将 k 中的 10 加载入 reg 中。





如果是

```lua
a = 1
```

则直接将名字 "a" 和 1 都保存在 k 表。

需要通过 "a" 来索引全局变量。这一点和 local var 完全不同。


discharge vars 意思是解析变量，比如

```
a = 1
```

在赋值之间，要先解析 1，从 k 表中将 1 加载到栈中，
然后再设置到全局表。

解析 1 的过程就是 discharge。

生成的 bytecode 也就在 assignment 的前面。




通过 numberK 和 stringK 方法

每个 function 都有一个 k 表，而且可以去重存储。


  - var type
    - local
    - upval
    - global
  - k table



*** if

jump chain    

*** do

*** while & repeat

*** break

*** for

- blockCnt

for loop 特别开发了底层指令来处理，而 repeat 和 while 则没有相应的指令。
依然是通过 jmp 来实现的。

两种


数字迭代 fornum

#+begin_src lua
for i = 1, 10, 2 do
  local j = i * i
end
#+end_src

通用迭代 forlist

#+begin_src lua
for k, v in pairs(t) do
  print(k, v)
end
#+end_src


隐式生成的变量，用 ( 来标识，是不会与正常 lua 代码中分析得到的 NAME 冲突的
因为 lex 规则的限定

#+begin_example
.local  "(for generator)"  ; 0
.local  "(for state)"  ; 1
.local  "(for control)"  ; 2
#+end_example

*** function
    
func 有同名和匿名两种

从 ebnf 中可以看出，两者只差在 NAME

几乎全部由 body 处理

包含了参数，函数体等全部

动态类型，名称与值的绑定，所以由 body 来处理全部


  - proto list

*** ret

*** expr


**** function call

**** assignment

**** arithmetic
    
**** compare

 lua 在进行解析时，没有进行关系运算的实时解析，但是对 constant 算法运算有编译时执行

 如 `local a = 5 > 2` 和 `local a = 1 + 2` 的区别

 前者需要生成 jmp 指令，但是后者，直接是 loadk 0 0 ; 3

**** constructor

*** upvalue

- upval list
- close op

** opcode
    
*** move
     
move code 发生在 assignment 环节

在这里要进行值的迁移


luaK_storevar 生成了 move 指令

exp2reg?

对于赋值，= 后是 exp，前是存储空间

后面的 exp 要经过解析，才能向前赋值



*** table related

gettable 中，之所以使用 RK(C) 这种方法，是因为索引值未必是 constant，也可能是
一个表，一个函数，等其它值，这种值只能由 寄存器 存储

同时，加上了 k，也可以节省临时寄存器的使用

如果超出了 k 表的范围，大于 256，需要临时先加载入 寄存器


*** upval related

在 pascal 中，在 outer scope 的变量，可以通过 frame stack 去查找

但是在 lua 中，函数也是一种值，可以四处流转，说不定在什么地方调用
所以其 upvalue 不一定出现在 stack frame 上

