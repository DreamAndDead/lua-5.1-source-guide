#+SETUPFILE: setup.org

* types & values

lua 是一种动态类型语言，类型不存在于变量中，而存在于值本身。

lua 中有 8 种类型的值
- nil
- bool
- number
- string
- table
- function
- userdata
- thread

从某种角度而言，程序就是“数据”与“操作数据的方法”。
所以第一步，先来了解 lua 类型与值的实现。

** TODO review struct & union

- struct memory
- union memory
- how TString alignment? where dummy is smaller than tsv
- struct in union, gcobject hack
- union in array? 如何对齐

** tagged value

一开始就提到，类型存在于值本身。
在 lua 内部，用 TValue（tagged value）表示值的概念。

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c -n 67 :lines "67-76"

tt 表示值的类型，value 表示值的数据。
很明显，类型是值的一部分。

fig.tvalue simple

*** TODO type

在 TValue 中，类型用 int 数字来标识，可以找到所有基础类型的宏定义

#+INCLUDE: ../lua-5.1.5/src/lua.h src c :lines "69-83"

完全对应lua 中的 8 种类型。

同样地，lua 定义了相应的宏，方便类型的检测。

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c -n 78 :lines "78-91"

细心如你，一定发现多了一种 lightuserdata 类型。
userdata 类型有 light 和 non-light 两种类型定义，这一点先不做细致的解释，
先带着问题前进，之后再解释为什么。

*** data

至于值的数据，TValue 用一个 union 结构来表示，有效利用内存空间。

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c :lines "56-65"

不同类型的数据使用不同的键值来存取。

fig.value

** detail

*** nil

nil 是最简单的值，表示没有值。由于不需要数据，只需用 tt 表示类型即可。

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c :lines "363-366"

#+INCLUDE: ../lua-5.1.5/src/lobject.c src c :lines "27-28"

重要的是，nil 是一个单例值，所有使用 nil 的地方，都通过 ~luaO_nilobject~ 来引用。

fig.nil

*** bool

lua 中的 bool 值是 true 和 false。

在 tt 记录类型之后，用 int b = 1/0 表示 true/false。

fig.bool

*** TODO light userdata

light userdata 表示 c 和 lua 协同的时候，由 c 语言一方传入的数据。

相应的，lua 内部只负责引用，而不负责其生命周期管理，什么时候释放，lua 并不清楚，也不过问。

所以只用 void * p 引用即可

fig.light userdata

*** number

默认设定下，lua 中所有数字都用 double 来表示。

#+INCLUDE: ../lua-5.1.5/src/luaconf.h src c :lines "495-506"

#+INCLUDE: ../lua-5.1.5/src/lua.h src c :lines "98-100"

相应地，tt 表示数字，用 lua_Number n 来存取数字内容

fig.number

*** collectable

上面的数据表示都相对简单，其余类型的数据就相对复杂一些。
但是有一点是共通的，它们都属于可 gc 的对象。

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c :lines "189-190"

lua 内建了 gc 机制，其中关键的结构是 ~GCObject~ 。
其本身是 union 结构，内部键值表明了可存取其它类型的数据。

#+INCLUDE: ../lua-5.1.5/src/lstate.h src c :lines "133-146"

所有这些数据都有一个共同点，它们都是 struct，且头部的字段都是 CommonHeader。

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c :lines "39-52"

其中 tt 和 TValue 中的 tt 是相同的。

这样就可以利用内存结构的特性，引用 GCHeader gch 来读取 tt，再根据 tt 来引用不同的键值。

fig.gcobject

这一点在取数据的宏定义中可以清晰的看到

#+INCLUDE: ../lua-5.1.5/src/lstate.h src c :lines "148-160"

至于剩下的类型，
- string
- table
- function
- userdata
- thread

其数据管理在后续，单独分拆为独立章节来讲解。这里先略过不表。

*** TODO internal
    :LOGBOOK:
    - Note taken on [2020-12-02 三 15:42] \\
      deadkey 是什么含义？
    :END:

细心如你，一定又发现了，GCObject 中除了 gch，有 7 个键值，而不是 5 个。

事实上，在 thread 之后，新定义了 3 个类型，
- proto
- upval
- deadkey

用于内部实现使用

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c :lines "19-31"

proto 和 upval 就对应 GCObject 中多出的 2 个键值。
至于 deadkey，后续再说（现在还不清楚）。

** TODO practice
   :LOGBOOK:
   - Note taken on [2020-12-02 三 15:43] \\
     所有可关联本章内容一起阅读的代码
     
     关联性强，容易阅读
   :END:

根据不同类型，从 TValue 中取数据的宏

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c :lines "91-102"


