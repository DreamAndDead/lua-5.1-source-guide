#+SETUPFILE: setup.org

* TODO table

- num not in array part, before hash nodes part?
- how to decide array size
  - largest size where n/2 are used (use log method to iterate)

** intro

lua 没有内建多种数据结构，比如数组，dict 之类。

只有一个 table 表示两种概念。

可以说 table 可以作为 dict 也可以作为 array 来使用。

为了效率，table 内部的实现，将 array 与 dict 部分分开存储。有时也会有交叉。


TODO 为何这样设计？

核心是存取，get and set。

** hash

table 核心上来说，是一个 hash 结构。
array 可以理解为是 hash 结构，不过 key 是整数罢了。

lua 内部为了优化，将部分整数索引的值放在 array 结构里实现，这一点在下一节讲解。


table 的作用是，是 get set kv 对。

在 lua 中，k 不能是 nil。如果 v 是 nil，代表删除 k。

因为之前已经用 TValue 统一表示了所有数据类型。
所以 table 的 k v 可以是任意 lua 数据（上面的 nil 是例外）。
无论是 function 还是 string。

这是一个非常大的自由度。

*** data structure

table 的结构很简单，很不看 整数 相关的部分，

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c -n 319 :lines "319-349"

- lsizenode，指 node 桶的大小 Log2
- node，桶
- lastfree，？初始在 node array 的最后，索引 size，（不会超出数组本身吗？）
  
Node 代表一个 kv 存储
- i_val
- i_key

根据 key 的 hash 值，放到不同的桶中

TKey 中使用的技巧，保留了 TKey 的 value 的同时，添加了 next 指针，
可以在发生碰撞的时候，头插入桶。

整体实现很像 string table 中的实现。

TODO graph

这样，一些相关的宏就容易理解了

#+INCLUDE: ../lua-5.1.5/src/ltable.h src c -n 13 :lines "13-19"


*** hash method

桶的大小总是 2 的幂

前面提到，除了 nil，其它 7 种类型都可以作为 key

而决定相应的 key 放在哪个桶中，需要由 hash algo 来计算，得到桶的位置

- bool，直接取 0 1
- string，使用其自身的 hash
- num，如果是 int 类型，可直接使用 number 值
  如果不是，需要参与运算（可能是浮点）如何计算？
- 其它，将指针地址强制转换为 int 作为 hash
  其中 mod 的值，不是 size - 1 的值，地址一般是对齐的，减小碰撞的概率
  - lightudata 和 gc 各自的指针

  
#+INCLUDE: ../lua-5.1.5/src/lobject.h src c -n 352 :lines "352-361"

#+INCLUDE: ../lua-5.1.5/src/ltable.c src c -n 50 :lines "50-64"

- lmod 使用二进制的 mod，值得思考
- lsizenode 至少是 0，所以 sizenode 至少是 1

#+INCLUDE: ../lua-5.1.5/src/ltable.c src c -n 96 :lines "96-114"


*** get str

- 先根据 hash 找到桶的位置
- 在桶中对比 key 值，需要完全相同
- 没有则返回 nil，有则返回值

#+INCLUDE: ../lua-5.1.5/src/ltable.c src c -n 452 :lines "452-464"

*** get key

- 根据类型不同，进行分配
- nil，直接返回
- str，参见上面
- num，如果是整数，使用 getnum （参考下一节）
  如果不是，则需要特殊计算 hash
- 其它，计算 hash，
- 找到桶，对比 key，返回值/nil

#+INCLUDE: ../lua-5.1.5/src/ltable.c src c -n 466 :lines "466-492"
    
*** set key

set key 并非是直接设置 v，而是返回 key 代表的位置，v 的指针，直接由调用者修改

=luaH_setstr= =luaH_setnum= 底层都依赖 newkey

并不是桶的实现，因为如果出现碰撞，则找到一个 freepos，用 next 串联起来，
相当于是数组链表


=luaH_set= 进行基本的检测，如果找到位置，直接返回

#+INCLUDE: ../lua-5.1.5/src/ltable.c src c -n 494 :lines "494-506"

=newkey= 进行 key 的插入
- dummy node ?

- 先找到 key 的 mp
- 如果 mp 上已经有元素
  - 如果它已经在其位置上，则将 key 放置在 freepos
  - 如果它不在位置，则由其 mp 位置，一直 next 找到其 previous 位置
    将 key 放在 mp 位置，另外放在 freepos，并改变指针的指向

#+INCLUDE: ../lua-5.1.5/src/ltable.c src c -n 392 :lines "392-430"


和 setobj 一起用

** array

没有 array 一开始令学习 lua 的人困惑，尤其是通过 table 来表示数组
且默认索引从 1 开始

array part 只存储 正整数索引（>= 1） 表示的键值对。

数字索引的 kv 自然可以用 hash 的结构来存储，但是引入 array part 来存储，
是出于效率的原因。

在 C 语言中，直接通过数字索引到数组的元素效率是非常高的

将部分数字索引的 kv 放在 * array 中，将其索引对应起来，提高存取效率。

1 -> 0
2 -> 1

有 1 个位置偏移。


如果

#+begin_src lua
local t = {1, 2, 3, 4}
#+end_src

这样紧密的情况下，全部使用 array part 来存储，自然效率是最高的，完全看作一个数组。

如果

#+begin_src lua
local t = {1, 2, 3, 4, [1000] = 1000}
#+end_src

其中全部是整数索引，但是最大的索引是 1000，

如果这种情况下，使用 1000 大小的 TValue 来存储就不划算，中间浪费的空间太多了
没有明显设置的值，如果直接索引就是 nil 值。

lua 使用这样的方式来决定使用多大的 array 来存储整数索引的 kv。

找到一个最大的整数 n，其中 0 到 n 之前至少有 n/2 个整数是有值的。

以上面的例子，n = 8



array part 在 table 中，就是一个 TValue 数组，
- TValue * array
- int sizearray

一个记录当前 array part 的大小，一个是存储空间

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c -n 338 :lines "338-349"

*** hash num

- TODO avoid -0?

- 从字节角度，将 double 分为多个 unsigned int
- 所有 int 求和，得到 hash
- mod size node，得到 num 的 mp

*** get num

=luaH_get=

- 如果 key 是 number 和 int，使用 =luaH_getnum=
  是浮点，则正常使用 =hashnum=
- 在 =luaH_getnum= 中，在 1 - sizearray 范围内，可以直接索引
  否则，还是通过 =hashnum= ，从 hash 部分搜索


*** set num

使用 newkey 的逻辑

TODO setnum 没有特殊处理？直接使用 hashnum。何时使用 array index 添加？

可能只有在 rehash 的时候，才会将相应的 整数 key 移动到 array 部分
先计算大小，再进行迁移

** TODO next

#+INCLUDE: ../lua-5.1.5/src/ltable.c src c -n 116 :lines "116-180"

=luaH_next=

被 lapi.c lua_next 使用

应用在 baselib tablelib 的 foreach 中

TODO deadkey?

findindex 返回
- -1，是开始
- 在 sizearray 范围内，直接返回
- 计算 mp，在 next 链中寻找 key，返回 sizearray + node偏移


将 array node 并起来，从前到后，遍历所有元素

以 nil 开始

每次将 key, key+1 置为 next key, next key value，
一直到没有元素


最后和 ltablib foreach 以及 c api 结合起来，会理解的更为深刻

** TODO rehash

rehash -> resize

- 先进行 size 计算，多少用于 array，多少用于 hash
- 巧妙，使用 log pow 来统计


computesizes 中

twotoi/2 < *narray 的条件，是因为如果不符合，则 twotoi 一定不符合
因为其中所有元素小于 size 的一半，一定不符合 array size 的选择

if a == *narray break

是一个优化，如果元素出现的非常密集，在前方
继续统计也没有意义，nums[i] 都是 0，（好像不完全正确？）

累计的应该是 1 2 4 8 之类

相当于，如果 a == *narray，则 a 最大为 twotoi

a 统计的是 < 2^i 的个数 == twotoi

既然已经统计结束，则下一轮，twotoi * 2 必定大于 a 的 2 倍

不符合查找条件


** TODO metatable

tagmethod cache

机制不在这里发生作用

** TODO graph list

- data structure first
- process after
- how to namingc

** practice


