<!doctype html><html lang=zh dir=ltr><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="初次接触 lua 的人都有困惑， 多数动态语言都会内建 dict 和 array 的概念，而 lua 用 table 同时表示这两个概念。
所谓 dict 不过是 kv 存储，从某种角度来看，可以将 array 看作 k 是整数的一种特殊情况。
本章就来从源码角度认识 lua 中的 table。
structure #  338 339 340 341 342 343 344 345 346 347 348  typedef struct Table { CommonHeader; lu_byte flags; /* 1<<p means tagmethod(p) is not present */ lu_byte lsizenode; /* log2 of size of `node' array */ struct Table *metatable; TValue *array; /* array part */ Node *node; Node *lastfree; /* any free position is before this position */ GCObject *gclist; int sizearray; /* size of `array' array */ } Table;   table 的结构并不复杂，除去 CommonHeader 和 gclist，剩余的字段可分为 3 部分。"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="table"><meta property="og:description" content="初次接触 lua 的人都有困惑， 多数动态语言都会内建 dict 和 array 的概念，而 lua 用 table 同时表示这两个概念。
所谓 dict 不过是 kv 存储，从某种角度来看，可以将 array 看作 k 是整数的一种特殊情况。
本章就来从源码角度认识 lua 中的 table。
structure #  338 339 340 341 342 343 344 345 346 347 348  typedef struct Table { CommonHeader; lu_byte flags; /* 1<<p means tagmethod(p) is not present */ lu_byte lsizenode; /* log2 of size of `node' array */ struct Table *metatable; TValue *array; /* array part */ Node *node; Node *lastfree; /* any free position is before this position */ GCObject *gclist; int sizearray; /* size of `array' array */ } Table;   table 的结构并不复杂，除去 CommonHeader 和 gclist，剩余的字段可分为 3 部分。"><meta property="og:type" content="article"><meta property="og:url" content="https://dreamanddead.github.io/lua-5.1-source-guide/docs/table/"><meta property="article:published_time" content="2020-12-30T11:53:00+08:00"><meta property="article:modified_time" content="2021-02-23T13:26:02+08:00"><title>table | lua 5.1 source guide</title><link rel=manifest href=/lua-5.1-source-guide/manifest.json><link rel=icon href=/lua-5.1-source-guide/favicon.png type=image/x-icon><link rel=stylesheet href=/lua-5.1-source-guide/book.min.44110be292c9f873dbe57bd8895d52b387519bad9a89a86ed5c3705e11d6b0d5.css integrity="sha256-RBEL4pLJ+HPb5XvYiV1Ss4dRm62aiahu1cNwXhHWsNU="><script defer src=/lua-5.1-source-guide/zh.search.min.7290bfd60a7f5c526bdb44d6c18babbd3e5ba6b7b0df02ac8bda3f32a4cf6542.js integrity="sha256-cpC/1gp/XFJr20TWwYurvT5bprew3wKsi9o/MqTPZUI="></script><script defer src=/lua-5.1-source-guide/sw.min.630373637e97fa7891a03b850675656b8da4625d692de7ef0581b22b995ab946.js integrity="sha256-YwNzY36X+niRoDuFBnVla42kYl1pLefvBYGyK5lauUY="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/lua-5.1-source-guide><img src=/lua-5.1-source-guide/logo.png alt=Logo><span>lua 5.1 source guide</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/lua-5.1-source-guide/docs/overview/>overview</a></li><li>basic<ul><li><a href=/lua-5.1-source-guide/docs/object/>object</a></li><li><a href=/lua-5.1-source-guide/docs/memory/>memory</a></li><li><a href=/lua-5.1-source-guide/docs/string/>string</a></li><li><a href=/lua-5.1-source-guide/docs/table/ class=active>table</a></li></ul></li><li>compiler<ul><li><a href=/lua-5.1-source-guide/docs/lexer/>lexer</a></li><li><a href=/lua-5.1-source-guide/docs/opcode/>opcode</a></li><li><a href=/lua-5.1-source-guide/docs/parser/>parser</a></li><li><a href=/lua-5.1-source-guide/docs/generator/>generator</a></li></ul></li><li>vm<ul><li><a href=/lua-5.1-source-guide/docs/vm/>vm</a></li><li><a href=/lua-5.1-source-guide/docs/api/>c api</a></li><li><a href=/lua-5.1-source-guide/docs/stdlib/>stdlib</a></li><li><a href=/lua-5.1-source-guide/docs/gc/>gc</a></li></ul></li></ul><p><br></p><ul><li><a href=https://github.com/DreamAndDead/lua-5.1-source-guide target=_blank rel=noopener>Github</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/lua-5.1-source-guide/svg/menu.svg class=book-icon alt=Menu></label>
<strong>table</strong>
<label for=toc-control><img src=/lua-5.1-source-guide/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#structure>structure</a></li><li><a href=#dict>dict</a><ul><li><a href=#main-position>main position</a></li><li><a href=#set>set</a></li><li><a href=#get>get</a></li></ul></li><li><a href=#array>array</a><ul><li><a href=#get>get</a></li><li><a href=#set>set</a></li></ul></li><li><a href=#method>method</a><ul><li><a href=#next>next</a></li></ul></li><li><a href=#practice>practice</a></li></ul></li></ul></nav></aside></header><article class=markdown><p>初次接触 lua 的人都有困惑，
多数动态语言都会内建 dict 和 array 的概念，而 lua 用 table 同时表示这两个概念。</p><p>所谓 dict 不过是 kv 存储，从某种角度来看，可以将 array 看作 k 是整数的一种特殊情况。</p><p>本章就来从源码角度认识 lua 中的 table。</p><h2 id=structure>structure
<a class=anchor href=#structure>#</a></h2><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">338
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">339
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">340
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">341
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">342
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">343
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">344
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">345
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">346
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">347
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">348
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> Table {
  CommonHeader;
  lu_byte flags;  <span style=color:#75715e>/* 1&lt;&lt;p means tagmethod(p) is not present */</span>
  lu_byte lsizenode;  <span style=color:#75715e>/* log2 of size of `node&#39; array */</span>
  <span style=color:#66d9ef>struct</span> Table <span style=color:#f92672>*</span>metatable;
  TValue <span style=color:#f92672>*</span>array;  <span style=color:#75715e>/* array part */</span>
  Node <span style=color:#f92672>*</span>node;
  Node <span style=color:#f92672>*</span>lastfree;  <span style=color:#75715e>/* any free position is before this position */</span>
  GCObject <span style=color:#f92672>*</span>gclist;
  <span style=color:#66d9ef>int</span> sizearray;  <span style=color:#75715e>/* size of `array&#39; array */</span>
} Table;</code></pre></td></tr></table></div></div><p>table 的结构并不复杂，除去 CommonHeader 和 gclist，剩余的字段可分为 3 部分。</p><p>dict 相关</p><ul><li>Node * node ，kv 存储的数组</li><li><code>lu_byte</code> lsizenode ，数组的大小，用 log2 表示</li><li>Node * lastfree ，在数组中从尾向前，第一个空闲位置的指针</li></ul><p>array 相关</p><ul><li>TValue * array ，array 存储的数组</li><li>int sizearray ，array 的大小</li></ul><p>metatable 相关</p><ul><li>struct Table * metatable ，metatable 的指针</li><li><code>lu_byte</code> flags ，一个字节，用于缓存加速 meta method 的搜索</li></ul><p>从结构中可以发现，table 并不只是单纯的 dict 结构，为了效率，在内部也用 array 的方式进行辅助存储。</p><p>下面就 3 个部分，分别讨论</p><h2 id=dict>dict
<a class=anchor href=#dict>#</a></h2><p>在 lua 中，用 table 表示 dict 概念，有非常大的自由度。</p><p>使用 k v 存储时</p><ul><li>k 不能是 nil</li><li>若 v 是 nil，表示从 dict 中删除 k v</li><li>除此之外，k v 可以是任意值，无论是 function 还是 string</li></ul><p>本质上来看，这就是用 TValue 统一表示所有“值”所带来的好处。
这一点从 Node 结构中可以清楚的看出来。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">323
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">324
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">325
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">326
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">327
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">328
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">329
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">330
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">331
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">332
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">333
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">334
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">335
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>union</span> TKey {
  <span style=color:#66d9ef>struct</span> {
    TValuefields;
    <span style=color:#66d9ef>struct</span> Node <span style=color:#f92672>*</span>next;  <span style=color:#75715e>/* for chaining */</span>
  } nk;
  TValue tvk;
} TKey;


<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> Node {
  TValue i_val;
  TKey i_key;
} Node;</code></pre></td></tr></table></div></div><figure><img src=table-node.png alt="Figure 1: Node &amp;amp; TKey"><figcaption><p>Figure 1: Node & TKey</p></figcaption></figure><p>Node 代表一个 k v 存储，k v 分别用 <code>i_key</code> 和 <code>i_val</code> 来表示。
<code>i_val</code> 本身是 TValue， <code>i_key</code> 是 TKey。</p><p>TKey 本身是一个 union，其中用 tvk 来索引本身的值，即 TValue。
另一项 nk 则添加了 next 指针，辅助在 Node 数组中做链接。
所以本质上， <code>i_key</code> 也是 TValue。</p><p>dict 表示的是多个 kv 的集合，在 table 内部，所有 kv 经过相应的安排，存储在 Node 数组中。</p><p>比如下面的代码，在 table 内部将可能会如此表示。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> t <span style=color:#f92672>=</span> {}

t[print] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
t[<span style=color:#66d9ef>true</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
t[<span style=color:#e6db74>&#34;return&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
t[<span style=color:#e6db74>&#34;name&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;print&#34;</span>
t[<span style=color:#e6db74>&#34;tool&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;dot&#34;</span>
</code></pre></div><figure><img src=table-dict.png alt="Figure 2: kv stored in Node array"><figcaption><p>Figure 2: kv stored in Node array</p></figcaption></figure><p>至于 kv 存取的方式，在 get set 小节详细讨论。</p><p>有了上面的理解，相关的宏也就容易理解了。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define gnode(t,i)	(&amp;(t)-&gt;node[i])
</span><span style=color:#75715e>#define gkey(n)		(&amp;(n)-&gt;i_key.nk)
</span><span style=color:#75715e>#define gval(n)		(&amp;(n)-&gt;i_val)
</span><span style=color:#75715e>#define gnext(n)	((n)-&gt;i_key.nk.next)
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define key2tval(n)	(&amp;(n)-&gt;i_key.tvk)</span></code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 1</span>:
ltable.h</div><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">352
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">353
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">354
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">355
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">356
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">357
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">358
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">359
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">360
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e>** `module&#39; operation for hashing (size is always a power of 2)
</span><span style=color:#75715e>*/</span>
<span style=color:#75715e>#define lmod(s,size) \
</span><span style=color:#75715e>	(check_exp((size&amp;(size-1))==0, (cast(int, (s) &amp; ((size)-1)))))
</span><span style=color:#75715e></span>

<span style=color:#75715e>#define twoto(x)	(1&lt;&lt;(x))
</span><span style=color:#75715e>#define sizenode(t)	(twoto((t)-&gt;lsizenode))</span></code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 2</span>:
lobject.h</div><h3 id=main-position>main position
<a class=anchor href=#main-position>#</a></h3><p>table 内部使用巧妙的方式来存储 kv，其中关键的概念是 main position。</p><p>因为 k 可以是任意类型的值，在存储 kv 之前，必须先确定将其安排在什么位置，
这个位置就是 kv 的 main position。</p><p>计算的方式并不陌生，先计算 k 的 hash 值，再模除 node 数组长度，得到 main position。</p><p>前面提到，k 可以是 nil 之外任意类型的值，所以在计算 main position 的时候，
针对不同的类型有不同的计算方式。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 96
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 97
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 98
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 99
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">100
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">101
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">102
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">103
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">104
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">105
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">106
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">107
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">108
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">109
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">110
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">111
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">112
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">113
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#75715e>/*
</span><span style=color:#75715e>** returns the `main&#39; position of an element in a table (that is, the index
</span><span style=color:#75715e>** of its hash value)
</span><span style=color:#75715e>*/</span>
<span style=color:#66d9ef>static</span> Node <span style=color:#f92672>*</span><span style=color:#a6e22e>mainposition</span> (<span style=color:#66d9ef>const</span> Table <span style=color:#f92672>*</span>t, <span style=color:#66d9ef>const</span> TValue <span style=color:#f92672>*</span>key) {
  <span style=color:#66d9ef>switch</span> (ttype(key)) {
    <span style=color:#66d9ef>case</span> LUA_TNUMBER:
      <span style=color:#66d9ef>return</span> hashnum(t, nvalue(key));
    <span style=color:#66d9ef>case</span> LUA_TSTRING:
      <span style=color:#66d9ef>return</span> hashstr(t, rawtsvalue(key));
    <span style=color:#66d9ef>case</span> LUA_TBOOLEAN:
      <span style=color:#66d9ef>return</span> hashboolean(t, bvalue(key));
    <span style=color:#66d9ef>case</span> LUA_TLIGHTUSERDATA:
      <span style=color:#66d9ef>return</span> hashpointer(t, pvalue(key));
    <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
      <span style=color:#66d9ef>return</span> hashpointer(t, gcvalue(key));
  }
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 3</span>:
ltable.c</div><p>针对不同类型详细来看，</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">53
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">54
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">55
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">56
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">57
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">58
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">59
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">60
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">61
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">62
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">63
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#75715e>#define hashpow2(t,n)      (gnode(t, lmod((n), sizenode(t))))
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define hashstr(t,str)  hashpow2(t, (str)-&gt;tsv.hash)
</span><span style=color:#75715e>#define hashboolean(t,p)        hashpow2(t, p)
</span><span style=color:#75715e></span>

<span style=color:#75715e>/*
</span><span style=color:#75715e>** for some types, it is better to avoid modulus by power of 2, as
</span><span style=color:#75715e>** they tend to have many 2 factors.
</span><span style=color:#75715e>*/</span>
<span style=color:#75715e>#define hashmod(t,n)	(gnode(t, ((n) % ((sizenode(t)-1)|1))))
</span><span style=color:#75715e></span>

<span style=color:#75715e>#define hashpointer(t,p)	hashmod(t, IntPoint(p))</span></code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 4</span>:
ltable.c</div><h4 id=string>string
<a class=anchor href=#string>#</a></h4><p>string 比较简单，依旧使用自身的 hash，再模除 node size 得到 main position。</p><h4 id=bool>bool
<a class=anchor href=#bool>#</a></h4><p>bool 类型更简单，直接锁定了 main position 的 0 1 位置。</p><h4 id=light-userdata>light userdata
<a class=anchor href=#light-userdata>#</a></h4><p>对于 light userdata，强制将 pointer 地址解析为 unsigned int 作为 hash 值，
模除 node size - 1 得到 main position。</p><p>因为地址一般按照 2 的幂对齐，而且 node size 也是 2 的幂，直接模除不容易将值分散开来，
所以就使用 node size - 1。</p><p>hashmod 末尾的 <code>| 1</code> 是避免出现 mod 0 的情况。</p><h4 id=gcobject>GCObject
<a class=anchor href=#gcobject>#</a></h4><p>同 light userdata，进行指针运算。</p><h4 id=number>number
<a class=anchor href=#number>#</a></h4><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">66
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">67
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">68
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">69
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#75715e>/*
</span><span style=color:#75715e>** number of ints inside a lua_Number
</span><span style=color:#75715e>*/</span>
<span style=color:#75715e>#define numints		cast_int(sizeof(lua_Number)/sizeof(int))</span></code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 5</span>:
ltable.c</div><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">81
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">82
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">83
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">84
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">85
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">86
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">87
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">88
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">89
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">90
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">91
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">92
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#75715e>/*
</span><span style=color:#75715e>** hash for lua_Numbers
</span><span style=color:#75715e>*/</span>
<span style=color:#66d9ef>static</span> Node <span style=color:#f92672>*</span><span style=color:#a6e22e>hashnum</span> (<span style=color:#66d9ef>const</span> Table <span style=color:#f92672>*</span>t, lua_Number n) {
  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> a[numints];
  <span style=color:#66d9ef>int</span> i;
  <span style=color:#66d9ef>if</span> (luai_numeq(n, <span style=color:#ae81ff>0</span>))  <span style=color:#75715e>/* avoid problems with -0 */</span>
    <span style=color:#66d9ef>return</span> gnode(t, <span style=color:#ae81ff>0</span>);
  memcpy(a, <span style=color:#f92672>&amp;</span>n, <span style=color:#66d9ef>sizeof</span>(a));
  <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> numints; i<span style=color:#f92672>++</span>) a[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+=</span> a[i];
  <span style=color:#66d9ef>return</span> hashmod(t, a[<span style=color:#ae81ff>0</span>]);
}</code></pre></td></tr></table></div></div><figure><img src=table-number-hash.png></figure><p><code>lua_Number</code> 默认用 double 来表示，在 32 位系统中，double 通常占用 64 位。
从二进制表示层面，将 double 分拆为 2 个 unsigned int，求和后再模除 node size - 1 得到 main position。</p><p>这里要注意两个细节，</p><p>一是对 <code>+0 -0</code> 做了统一处理。
<code>+0 -0</code> 在数值角度上是相等的，但是在二进制浮点表示<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>上，
存在标志位的不同，如果依旧使用分拆 unsigned int 的方式， <code>+0 -0</code> 将计算得到不同的 main position，
这显然不是我们想要的，所以这里统一用 main position 0 来处理。</p><p>二是在模除的过程中， <code>hashmod</code> 并非使用 node size 进行模除，而是 node size - 1，原因同上。</p><h3 id=set>set
<a class=anchor href=#set>#</a></h3><p>明确 main position 之后，下一步来了解如何存储 kv。</p><p>根据代码中的注释，dict 部分的实现 use a mix of chained scatter table with brent&rsquo;s variation。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e>** Implementation of tables (aka arrays, objects, or hash tables).
</span><span style=color:#75715e>** Tables keep its elements in two parts: an array part and a hash part.
</span><span style=color:#75715e>** Non-negative integer keys are all candidates to be kept in the array
</span><span style=color:#75715e>** part. The actual size of the array is the largest `n&#39; such that at
</span><span style=color:#75715e>** least half the slots between 0 and n are in use.
</span><span style=color:#75715e>** Hash uses a mix of chained scatter table with Brent&#39;s variation.
</span><span style=color:#75715e>** A main invariant of these tables is that, if an element is not
</span><span style=color:#75715e>** in its main position (i.e. the `original&#39; position that its hash gives
</span><span style=color:#75715e>** to it), then the colliding element is in its own main position.
</span><span style=color:#75715e>** Hence even when the load factor reaches 100%, performance remains good.
</span><span style=color:#75715e>*/</span></code></pre></td></tr></table></div></div><p>有兴趣的可以研究论文<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>，这里仅从代码方面解析其实现。</p><p>table 模块中提供了 <code>luaH_set</code> 实现 kv 存储。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">494
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">495
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">496
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">497
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">498
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">499
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">500
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">501
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">502
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">503
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">504
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">505
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>TValue <span style=color:#f92672>*</span><span style=color:#a6e22e>luaH_set</span> (lua_State <span style=color:#f92672>*</span>L, Table <span style=color:#f92672>*</span>t, <span style=color:#66d9ef>const</span> TValue <span style=color:#f92672>*</span>key) {
  <span style=color:#66d9ef>const</span> TValue <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> luaH_get(t, key);
  t<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>if</span> (p <span style=color:#f92672>!=</span> luaO_nilobject)
    <span style=color:#66d9ef>return</span> cast(TValue <span style=color:#f92672>*</span>, p);
  <span style=color:#66d9ef>else</span> {
    <span style=color:#66d9ef>if</span> (ttisnil(key)) luaG_runerror(L, <span style=color:#e6db74>&#34;table index is nil&#34;</span>);
    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (ttisnumber(key) <span style=color:#f92672>&amp;&amp;</span> luai_numisnan(nvalue(key)))
      luaG_runerror(L, <span style=color:#e6db74>&#34;table index is NaN&#34;</span>);
    <span style=color:#66d9ef>return</span> newkey(L, t, key);
  }
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 6</span>:
ltable.c</div><p>可以观察到，其中只有 k 参数，而没有 v 参数。
这是因为这个方法只返回参数 k 在 table 中对应 <code>node.i_val</code> 的指针，由外部调用者自行进行 v 的赋值。</p><p><code>luaH_set</code> 很简单，如果已经存在相应的 k，则直接返回；
通过一系列错误检测之后，调用 <code>newkey</code> 方法，添加 k。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">392
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">393
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">394
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">395
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">396
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">397
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">398
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">399
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">400
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">401
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">402
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">403
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">404
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">405
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">406
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">407
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">408
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">409
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">410
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">411
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">412
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">413
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">414
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">415
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">416
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">417
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">418
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">419
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">420
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">421
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">422
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">423
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">424
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">425
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">426
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">427
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">428
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">429
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#75715e>/*
</span><span style=color:#75715e>** inserts a new key into a hash table; first, check whether key&#39;s main
</span><span style=color:#75715e>** position is free. If not, check whether colliding node is in its main
</span><span style=color:#75715e>** position or not: if it is not, move colliding node to an empty place and
</span><span style=color:#75715e>** put new key in its main position; otherwise (colliding node is in its main
</span><span style=color:#75715e>** position), new key goes to an empty position.
</span><span style=color:#75715e>*/</span>
<span style=color:#66d9ef>static</span> TValue <span style=color:#f92672>*</span><span style=color:#a6e22e>newkey</span> (lua_State <span style=color:#f92672>*</span>L, Table <span style=color:#f92672>*</span>t, <span style=color:#66d9ef>const</span> TValue <span style=color:#f92672>*</span>key) {
  Node <span style=color:#f92672>*</span>mp <span style=color:#f92672>=</span> mainposition(t, key);
  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ttisnil(gval(mp)) <span style=color:#f92672>||</span> mp <span style=color:#f92672>==</span> dummynode) {
    Node <span style=color:#f92672>*</span>othern;
    Node <span style=color:#f92672>*</span>n <span style=color:#f92672>=</span> getfreepos(t);  <span style=color:#75715e>/* get a free place */</span>
    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> NULL) {  <span style=color:#75715e>/* cannot find a free place? */</span>
      rehash(L, t, key);  <span style=color:#75715e>/* grow table */</span>
      <span style=color:#66d9ef>return</span> luaH_set(L, t, key);  <span style=color:#75715e>/* re-insert key into grown table */</span>
    }
    lua_assert(n <span style=color:#f92672>!=</span> dummynode);
    othern <span style=color:#f92672>=</span> mainposition(t, key2tval(mp));
    <span style=color:#66d9ef>if</span> (othern <span style=color:#f92672>!=</span> mp) {  <span style=color:#75715e>/* is colliding node out of its main position? */</span>
      <span style=color:#75715e>/* yes; move colliding node into free position */</span>
      <span style=color:#66d9ef>while</span> (gnext(othern) <span style=color:#f92672>!=</span> mp) othern <span style=color:#f92672>=</span> gnext(othern);  <span style=color:#75715e>/* find previous */</span>
      gnext(othern) <span style=color:#f92672>=</span> n;  <span style=color:#75715e>/* redo the chain with `n&#39; in place of `mp&#39; */</span>
      <span style=color:#f92672>*</span>n <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>mp;  <span style=color:#75715e>/* copy colliding node into free pos. (mp-&gt;next also goes) */</span>
      gnext(mp) <span style=color:#f92672>=</span> NULL;  <span style=color:#75715e>/* now `mp&#39; is free */</span>
      setnilvalue(gval(mp));
    }
    <span style=color:#66d9ef>else</span> {  <span style=color:#75715e>/* colliding node is in its own main position */</span>
      <span style=color:#75715e>/* new node will go into free position */</span>
      gnext(n) <span style=color:#f92672>=</span> gnext(mp);  <span style=color:#75715e>/* chain new position */</span>
      gnext(mp) <span style=color:#f92672>=</span> n;
      mp <span style=color:#f92672>=</span> n;
    }
  }
  gkey(mp)<span style=color:#f92672>-&gt;</span>value <span style=color:#f92672>=</span> key<span style=color:#f92672>-&gt;</span>value; gkey(mp)<span style=color:#f92672>-&gt;</span>tt <span style=color:#f92672>=</span> key<span style=color:#f92672>-&gt;</span>tt;
  luaC_barriert(L, t, key);
  lua_assert(ttisnil(gval(mp)));
  <span style=color:#66d9ef>return</span> gval(mp);
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 7</span>:
ltable.c</div><p><code>newkey</code> 是理解内部结构的关键。
调用时可能遇到 3 种情况，下面一一讨论。</p><h4 id=mp-free>mp free
<a class=anchor href=#mp-free>#</a></h4><p>k 的 main position 是空闲的，即相应的 <code>node.i_val</code> 是 nil 值。</p><figure><img src=table-no-collision-before.png></figure><p>这种情况下，mp 的位置就是要插入的位置，说明 line 401 为 false，直接执行 line 425 。</p><figure><img src=table-no-collision-after.png></figure><h4 id=colliding-node-in-own-mp>colliding node in own mp
<a class=anchor href=#colliding-node-in-own-mp>#</a></h4><p>如果 k 的 main position（mp）已经被占用，说明出现了冲突，
占用 mp 的结点称为 colliding node。</p><p>colliding node 根据 <code>i_key</code> 也可以计算出自身的 main position（othern）。</p><p>如果 othern 和 mp 是相同的，说明两者确实发生了 hash 冲突，都应该使用这个位置。</p><figure><img src=table-collision-eq-before.png></figure><p>但是位置只有一个，只能从当前空闲的结点借用一个位置（n），
然后使用头插法，用 <code>i_key.next</code> 将其链接起来。</p><p>可以发现，这个链条的起点从 main position 开始，链接的全部是 main position 相同（即 hash 冲突）的结点。</p><figure><img src=table-collision-eq-after.png></figure><h4 id=colliding-node-not-in-own-mp>colliding node not in own mp
<a class=anchor href=#colliding-node-not-in-own-mp>#</a></h4><p>如果 othern 和 mp 不相同，说明 colliding node 是在之前冲突时，借用了此结点的位置。</p><p>之前是空闲的，可以借用，但是现在，明确拥有 mp 的 k 要来拿回属于自己的位置，colliding node 只能让出来。</p><figure><img src=table-collision-ne-before.png></figure><p>让出的方法很简单，再另外找到一个空闲位置，放置 colliding node，原来的位置就还回去。</p><p>为了将新位置链接回去，同时从 othern 一路向下，查找到 colliding node 的上一个结点，并链接新的结点。</p><figure><img src=table-collision-ne-after.png></figure><h3 id=get>get
<a class=anchor href=#get>#</a></h3><p>在 set 小节明确了 node 内部组织的方法之后，get 方法就很容易理解了。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">466
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">467
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">468
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">469
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">470
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">471
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">472
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">473
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">474
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">475
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">476
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">477
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">478
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">479
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">480
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">481
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">482
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">483
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">484
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">485
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">486
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">487
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">488
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">489
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">490
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">491
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e>** main search function
</span><span style=color:#75715e>*/</span>
<span style=color:#66d9ef>const</span> TValue <span style=color:#f92672>*</span><span style=color:#a6e22e>luaH_get</span> (Table <span style=color:#f92672>*</span>t, <span style=color:#66d9ef>const</span> TValue <span style=color:#f92672>*</span>key) {
  <span style=color:#66d9ef>switch</span> (ttype(key)) {
    <span style=color:#66d9ef>case</span> LUA_TNIL: <span style=color:#66d9ef>return</span> luaO_nilobject;
    <span style=color:#66d9ef>case</span> LUA_TSTRING: <span style=color:#66d9ef>return</span> luaH_getstr(t, rawtsvalue(key));
    <span style=color:#66d9ef>case</span> LUA_TNUMBER: {
      <span style=color:#66d9ef>int</span> k;
      lua_Number n <span style=color:#f92672>=</span> nvalue(key);
      lua_number2int(k, n);
      <span style=color:#66d9ef>if</span> (luai_numeq(cast_num(k), nvalue(key))) <span style=color:#75715e>/* index is int? */</span>
	<span style=color:#66d9ef>return</span> luaH_getnum(t, k);  <span style=color:#75715e>/* use specialized version */</span>
      <span style=color:#75715e>/* else go through */</span>
    }
    <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span> {
      Node <span style=color:#f92672>*</span>n <span style=color:#f92672>=</span> mainposition(t, key);
      <span style=color:#66d9ef>do</span> {  <span style=color:#75715e>/* check whether `key&#39; is somewhere in the chain */</span>
	<span style=color:#66d9ef>if</span> (luaO_rawequalObj(key2tval(n), key))
	  <span style=color:#66d9ef>return</span> gval(n);  <span style=color:#75715e>/* that&#39;s it */</span>
	<span style=color:#66d9ef>else</span> n <span style=color:#f92672>=</span> gnext(n);
      } <span style=color:#66d9ef>while</span> (n);
      <span style=color:#66d9ef>return</span> luaO_nilobject;
    }
  }
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 8</span>:
ltable.c</div><p>核心就是先计算得到 main position，再一路通过 next 向下查找，
如果 k 匹配，就返回相应的 v；否则返回 nil。</p><h2 id=array>array
<a class=anchor href=#array>#</a></h2><p>前面提到，为了效率，table 内部有特定的区域用于存储 array 相关的数据（k 为正整数）。</p><p>考虑如下代码，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> t <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>}
</code></pre></div><p>如果内部使用 <code>TValue[]</code> 来存储，效率自然是最高的。</p><ul><li>空间上，Node 结构大小至少为 2 * TValue，若直接用数组表示，只需要 1 * TValue 的空间；</li><li>时间上，若直接使用数组，可以直接索引元素，速度非常快，而 Node 需要在整个链条中使用 next 遍历。</li></ul><p>但是，假如出现这种情况，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> t <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, [<span style=color:#ae81ff>1000</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>}
</code></pre></div><p>索引都为正整数，但是中间并不连续，从 4 到 1000 出现了巨大的空隙。</p><p>假如依旧使用 <code>TValue[]</code> 来存储就不划算了，大小必须为 1000，中间浪费的空间太多。</p><p>综合考虑，lua 使用一种权衡的方式来安排正整数索引的数据。</p><p>具体而言，就是找到一个最大的整数 n，其中 0 到 n 之间至少有 n/2 个整数索引，
这样可以保持至少 50% 的利用率。</p><p>剩余在 n 范围之外的索引，依旧使用 kv 方式来存储。</p><figure><img src=table-num-array-dict.png></figure><p>需要注意的细节是，table 表示 array 的时候，默认索引从 1 开始。</p><p>相应的，table 中的 TValue *array 只存储正整数索引（>= 1）对应的值。
由于 C 语言数组的索引从 0 开始，所以存储时，有 1 个位置偏移。</p><h3 id=get>get
<a class=anchor href=#get>#</a></h3><p>在讲解 get 之前，需要明确一点，并且所有数字索引的 kv 都会存储在内部的 array 中。</p><p>对于类型是 number 的 k，需要其</p><ul><li>不是浮点值，是整数值</li><li>是 <code>>= 1</code> 的正整数</li><li>范围在 <code>1 - sizearray</code> 之间</li></ul><p>不在这个范围内的 kv，依旧按照 dict 来处理，从代码中可以明确看到这一点。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">466
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">467
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">468
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">469
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">470
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">471
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">472
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">473
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">474
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">475
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">476
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">477
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">478
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">479
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">480
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">481
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">482
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">483
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">484
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">485
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">486
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">487
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">488
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">489
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">490
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">491
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e>** main search function
</span><span style=color:#75715e>*/</span>
<span style=color:#66d9ef>const</span> TValue <span style=color:#f92672>*</span><span style=color:#a6e22e>luaH_get</span> (Table <span style=color:#f92672>*</span>t, <span style=color:#66d9ef>const</span> TValue <span style=color:#f92672>*</span>key) {
  <span style=color:#66d9ef>switch</span> (ttype(key)) {
    <span style=color:#66d9ef>case</span> LUA_TNIL: <span style=color:#66d9ef>return</span> luaO_nilobject;
    <span style=color:#66d9ef>case</span> LUA_TSTRING: <span style=color:#66d9ef>return</span> luaH_getstr(t, rawtsvalue(key));
    <span style=color:#66d9ef>case</span> LUA_TNUMBER: {
      <span style=color:#66d9ef>int</span> k;
      lua_Number n <span style=color:#f92672>=</span> nvalue(key);
      lua_number2int(k, n);
      <span style=color:#66d9ef>if</span> (luai_numeq(cast_num(k), nvalue(key))) <span style=color:#75715e>/* index is int? */</span>
	<span style=color:#66d9ef>return</span> luaH_getnum(t, k);  <span style=color:#75715e>/* use specialized version */</span>
      <span style=color:#75715e>/* else go through */</span>
    }
    <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span> {
      Node <span style=color:#f92672>*</span>n <span style=color:#f92672>=</span> mainposition(t, key);
      <span style=color:#66d9ef>do</span> {  <span style=color:#75715e>/* check whether `key&#39; is somewhere in the chain */</span>
	<span style=color:#66d9ef>if</span> (luaO_rawequalObj(key2tval(n), key))
	  <span style=color:#66d9ef>return</span> gval(n);  <span style=color:#75715e>/* that&#39;s it */</span>
	<span style=color:#66d9ef>else</span> n <span style=color:#f92672>=</span> gnext(n);
      } <span style=color:#66d9ef>while</span> (n);
      <span style=color:#66d9ef>return</span> luaO_nilobject;
    }
  }
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 9</span>:
ltable.c</div><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">432
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">433
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">434
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">435
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">436
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">437
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">438
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">439
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">440
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">441
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">442
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">443
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">444
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">445
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">446
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">447
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">448
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">449
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e>** search function for integers
</span><span style=color:#75715e>*/</span>
<span style=color:#66d9ef>const</span> TValue <span style=color:#f92672>*</span><span style=color:#a6e22e>luaH_getnum</span> (Table <span style=color:#f92672>*</span>t, <span style=color:#66d9ef>int</span> key) {
  <span style=color:#75715e>/* (1 &lt;= key &amp;&amp; key &lt;= t-&gt;sizearray) */</span>
  <span style=color:#66d9ef>if</span> (cast(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>, key<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>&lt;</span> cast(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>, t<span style=color:#f92672>-&gt;</span>sizearray))
    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span>t<span style=color:#f92672>-&gt;</span>array[key<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
  <span style=color:#66d9ef>else</span> {
    lua_Number nk <span style=color:#f92672>=</span> cast_num(key);
    Node <span style=color:#f92672>*</span>n <span style=color:#f92672>=</span> hashnum(t, nk);
    <span style=color:#66d9ef>do</span> {  <span style=color:#75715e>/* check whether `key&#39; is somewhere in the chain */</span>
      <span style=color:#66d9ef>if</span> (ttisnumber(gkey(n)) <span style=color:#f92672>&amp;&amp;</span> luai_numeq(nvalue(gkey(n)), nk))
	<span style=color:#66d9ef>return</span> gval(n);  <span style=color:#75715e>/* that&#39;s it */</span>
      <span style=color:#66d9ef>else</span> n <span style=color:#f92672>=</span> gnext(n);
    } <span style=color:#66d9ef>while</span> (n);
    <span style=color:#66d9ef>return</span> luaO_nilobject;
  }
}</code></pre></td></tr></table></div></div><h3 id=set>set
<a class=anchor href=#set>#</a></h3><p>set 的逻辑也很简单，不过其中有一点需要注意。</p><p>回忆之前 dict 部分的 set 方法，返回的是存储 v 的指针，而如果 kv 安排在 array 部分，
则不需要 newkey 过程，直接返回相应的 array 位置即可。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">494
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">495
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">496
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">497
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">498
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">499
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">500
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">501
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">502
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">503
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">504
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">505
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">506
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">507
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">508
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">509
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">510
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">511
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">512
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">513
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">514
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">515
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">516
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">517
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>TValue <span style=color:#f92672>*</span><span style=color:#a6e22e>luaH_set</span> (lua_State <span style=color:#f92672>*</span>L, Table <span style=color:#f92672>*</span>t, <span style=color:#66d9ef>const</span> TValue <span style=color:#f92672>*</span>key) {
  <span style=color:#66d9ef>const</span> TValue <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> luaH_get(t, key);
  t<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>if</span> (p <span style=color:#f92672>!=</span> luaO_nilobject)
    <span style=color:#66d9ef>return</span> cast(TValue <span style=color:#f92672>*</span>, p);
  <span style=color:#66d9ef>else</span> {
    <span style=color:#66d9ef>if</span> (ttisnil(key)) luaG_runerror(L, <span style=color:#e6db74>&#34;table index is nil&#34;</span>);
    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (ttisnumber(key) <span style=color:#f92672>&amp;&amp;</span> luai_numisnan(nvalue(key)))
      luaG_runerror(L, <span style=color:#e6db74>&#34;table index is NaN&#34;</span>);
    <span style=color:#66d9ef>return</span> newkey(L, t, key);
  }
}


TValue <span style=color:#f92672>*</span><span style=color:#a6e22e>luaH_setnum</span> (lua_State <span style=color:#f92672>*</span>L, Table <span style=color:#f92672>*</span>t, <span style=color:#66d9ef>int</span> key) {
  <span style=color:#66d9ef>const</span> TValue <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> luaH_getnum(t, key);
  <span style=color:#66d9ef>if</span> (p <span style=color:#f92672>!=</span> luaO_nilobject)
    <span style=color:#66d9ef>return</span> cast(TValue <span style=color:#f92672>*</span>, p);
  <span style=color:#66d9ef>else</span> {
    TValue k;
    setnvalue(<span style=color:#f92672>&amp;</span>k, cast_num(key));
    <span style=color:#66d9ef>return</span> newkey(L, t, <span style=color:#f92672>&amp;</span>k);
  }
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 10</span>:
ltable.c</div><p>先调用 get 方法，得到结果 p， <code>if (p != luaO_nilobject)</code> 非常关键。</p><p>回忆 get 方法，
如果相应 kv 存储在 array 中，直接返回 array 中相应的地址，地址必定不是 <code>luaO_nilobject</code> ；
而如果存储在 Node 中，如果找不到相应的 k，才会返回 <code>luaO_nilobject</code> 。</p><p>这一点细节，和之前的逻辑完美统一起来。</p><h2 id=method>method
<a class=anchor href=#method>#</a></h2><p>除了 table 内部组织数据的方式，部分方法也值得关注。</p><h3 id=next>next
<a class=anchor href=#next>#</a></h3><p>在 lua 语言中，我们可以使用 next 方法来遍历 table。
next 接收两个参考，一个是 table，一个是 k。</p><p>next 的行为也很容易理解，</p><ul><li>如果 k 是 nil，则返回 table 的第一项；</li><li>如果 table 中没有相应的 k，则出错；</li><li>如果存在相应的 k，则返回存储在 k 之后的 k 和 v；</li><li>如果 k 是最后一项，则返回 nil nil</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> t <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, [<span style=color:#e6db74>&#34;name&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;t&#34;</span>, [<span style=color:#e6db74>&#34;section&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;table&#34;</span> }
t[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>nil</span>

<span style=color:#66d9ef>local</span> k <span style=color:#f92672>=</span> <span style=color:#66d9ef>nil</span>
<span style=color:#66d9ef>local</span> v

<span style=color:#66d9ef>repeat</span>
   k, v <span style=color:#f92672>=</span> next(t, k)
   print(k, v)
<span style=color:#66d9ef>until</span> k <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>1	1
2	2
4	4
name	t
section	table
nil	nil
</code></pre></div><p>上面的示例代码，k 以 nil 为开始，不断输入 next，最终遍历整个 table。</p><figure><img src=table-next-example.png></figure><p>这里要思考的问题是，next 的顺序是如何决定的。
上面的示例代码，无论运行多少次，输出结果都是一样的。说明内部有明显的顺序安排，而不是随机的。</p><p>观察代码不难发现，顺序正是依次遍历 array 数组和 node 数组来决定的。</p><figure><img src=table-next-detail.png></figure><p>语言中使用的 next 是在 api 层面定义的，而底层使用的方法正是 <code>luaH_next</code> 。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">132
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">133
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">134
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">135
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">136
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">137
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">138
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">139
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">140
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">141
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">142
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">143
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">144
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">145
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">146
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">147
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">148
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">149
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">150
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">151
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">152
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">153
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">154
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">155
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">156
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">157
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">158
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">159
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">160
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">161
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">162
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">163
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">164
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">165
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">166
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">167
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">168
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">169
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">170
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">171
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">172
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">173
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">174
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">175
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">176
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">177
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">178
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">179
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e>** returns the index of a `key&#39; for table traversals. First goes all
</span><span style=color:#75715e>** elements in the array part, then elements in the hash part. The
</span><span style=color:#75715e>** beginning of a traversal is signalled by -1.
</span><span style=color:#75715e>*/</span>
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>findindex</span> (lua_State <span style=color:#f92672>*</span>L, Table <span style=color:#f92672>*</span>t, StkId key) {
  <span style=color:#66d9ef>int</span> i;
  <span style=color:#66d9ef>if</span> (ttisnil(key)) <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;  <span style=color:#75715e>/* first iteration */</span>
  i <span style=color:#f92672>=</span> arrayindex(key);
  <span style=color:#66d9ef>if</span> (<span style=color:#ae81ff>0</span> <span style=color:#f92672>&lt;</span> i <span style=color:#f92672>&amp;&amp;</span> i <span style=color:#f92672>&lt;=</span> t<span style=color:#f92672>-&gt;</span>sizearray)  <span style=color:#75715e>/* is `key&#39; inside array part? */</span>
    <span style=color:#66d9ef>return</span> i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;  <span style=color:#75715e>/* yes; that&#39;s the index (corrected to C) */</span>
  <span style=color:#66d9ef>else</span> {
    Node <span style=color:#f92672>*</span>n <span style=color:#f92672>=</span> mainposition(t, key);
    <span style=color:#66d9ef>do</span> {  <span style=color:#75715e>/* check whether `key&#39; is somewhere in the chain */</span>
      <span style=color:#75715e>/* key may be dead already, but it is ok to use it in `next&#39; */</span>
      <span style=color:#66d9ef>if</span> (luaO_rawequalObj(key2tval(n), key) <span style=color:#f92672>||</span>
	    (ttype(gkey(n)) <span style=color:#f92672>==</span> LUA_TDEADKEY <span style=color:#f92672>&amp;&amp;</span> iscollectable(key) <span style=color:#f92672>&amp;&amp;</span>
	     gcvalue(gkey(n)) <span style=color:#f92672>==</span> gcvalue(key))) {
	i <span style=color:#f92672>=</span> cast_int(n <span style=color:#f92672>-</span> gnode(t, <span style=color:#ae81ff>0</span>));  <span style=color:#75715e>/* key index in hash table */</span>
	<span style=color:#75715e>/* hash elements are numbered after array ones */</span>
	<span style=color:#66d9ef>return</span> i <span style=color:#f92672>+</span> t<span style=color:#f92672>-&gt;</span>sizearray;
      }
      <span style=color:#66d9ef>else</span> n <span style=color:#f92672>=</span> gnext(n);
    } <span style=color:#66d9ef>while</span> (n);
    luaG_runerror(L, <span style=color:#e6db74>&#34;invalid key to &#34;</span> LUA_QL(<span style=color:#e6db74>&#34;next&#34;</span>));  <span style=color:#75715e>/* key not found */</span>
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>/* to avoid warnings */</span>
  }
}


<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>luaH_next</span> (lua_State <span style=color:#f92672>*</span>L, Table <span style=color:#f92672>*</span>t, StkId key) {
  <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> findindex(L, t, key);  <span style=color:#75715e>/* find original element */</span>
  <span style=color:#66d9ef>for</span> (i<span style=color:#f92672>++</span>; i <span style=color:#f92672>&lt;</span> t<span style=color:#f92672>-&gt;</span>sizearray; i<span style=color:#f92672>++</span>) {  <span style=color:#75715e>/* try first array part */</span>
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ttisnil(<span style=color:#f92672>&amp;</span>t<span style=color:#f92672>-&gt;</span>array[i])) {  <span style=color:#75715e>/* a non-nil value? */</span>
      setnvalue(key, cast_num(i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>));
      setobj2s(L, key<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>&amp;</span>t<span style=color:#f92672>-&gt;</span>array[i]);
      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
    }
  }
  <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>-=</span> t<span style=color:#f92672>-&gt;</span>sizearray; i <span style=color:#f92672>&lt;</span> sizenode(t); i<span style=color:#f92672>++</span>) {  <span style=color:#75715e>/* then hash part */</span>
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ttisnil(gval(gnode(t, i)))) {  <span style=color:#75715e>/* a non-nil value? */</span>
      setobj2s(L, key, key2tval(gnode(t, i)));
      setobj2s(L, key<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, gval(gnode(t, i)));
      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
    }
  }
  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>/* no more elements */</span>
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 11</span>:
ltable.c</div><p><code>luaH_next</code> 输入的是 k，</p><ul><li>首先，通过 findindex 找到 k 在 array/node 数组中的索引，</li><li>然后，将索引 i 自增， Line 164 <code>for (i++, ...)</code></li><li>先遍历 array 部分，再遍历 node 部分，跳过所有 v 为 nil 的项</li><li>直到 array 和 node 遍历结束</li></ul><p>值得注意的是， <code>luaH_next</code> 返回 0/1 说明是否已经遍历结束，方法内部将 k v 存储在栈上。</p><p>关于栈和 api 的具体分析，见之后的章节。</p><h2 id=practice>practice
<a class=anchor href=#practice>#</a></h2><p>table 模块中还有部分方法没有涉及到，如 <code>rehash, getn</code> 等，但并非重点内容，
感兴趣的读者可自行阅读。</p><p>在明确内部存储结构的基础上，其它方法并不难理解。</p><table><thead><tr><th>文件</th><th>建议</th></tr></thead><tbody><tr><td>ltable.h</td><td>仔细阅读</td></tr><tr><td>ltable.c</td><td>浏览阅读，关注核心方法</td></tr></tbody></table><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>: <a href=https://en.wikipedia.org/wiki/Double-precision%5Ffloating-point%5Fformat>https://en.wikipedia.org/wiki/Double-precision%5Ffloating-point%5Fformat</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>: <a href=https://maths-people.anu.edu.au/~brent/pub/pub013.html>https://maths-people.anu.edu.au/~brent/pub/pub013.html</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/DreamAndDead/lua-5.1-source-guide/commit/8c359ebae66c3a96c4a0c7ed6ba49ad52483055a title="最后修改者 DreamAndDead | February 23, 2021" target=_blank rel=noopener><img src=/lua-5.1-source-guide/svg/calendar.svg class=book-icon alt=Calendar>
<span>February 23, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/DreamAndDead/lua-5.1-source-guide/edit/master/site/content/docs/table/index.md target=_blank rel=noopener><img src=/lua-5.1-source-guide/svg/edit.svg class=book-icon alt=Edit>
<span>编辑本页</span></a></div></div></footer><div class=book-comments><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"lua-book"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#structure>structure</a></li><li><a href=#dict>dict</a><ul><li><a href=#main-position>main position</a></li><li><a href=#set>set</a></li><li><a href=#get>get</a></li></ul></li><li><a href=#array>array</a><ul><li><a href=#get>get</a></li><li><a href=#set>set</a></li></ul></li><li><a href=#method>method</a><ul><li><a href=#next>next</a></li></ul></li><li><a href=#practice>practice</a></li></ul></li></ul></nav></div></aside></main></body></html>