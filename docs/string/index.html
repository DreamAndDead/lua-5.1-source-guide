<!doctype html><html lang=zh dir=ltr><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="string 是多数编程语言内建的类型，lua 也不例外。
lua 代码中使用字符串是非常方便的，呼之即来，使用后也可以不闻不问。 因为 string 在底层自动新建，并由 gc 自动回收，极大方便了上层使用者。
更重要的是，string 同时也在 lua 的底层实现发挥着重要的作用。
本章就来讲解 lua 中的 string。
structure #  在 object 章节中已经提到，string 类型在 GCObject 中用 TString ts 表示。
196 197 198 199 200 201 202 203 204 205 206 207  /* ** String headers for string table */ typedef union TString { L_Umaxalign dummy; /* ensures maximum alignment for strings */ struct { CommonHeader; lu_byte reserved; unsigned int hash; size_t len; } tsv; } TString;   Code Snippet 1: lobject."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="string"><meta property="og:description" content="string 是多数编程语言内建的类型，lua 也不例外。
lua 代码中使用字符串是非常方便的，呼之即来，使用后也可以不闻不问。 因为 string 在底层自动新建，并由 gc 自动回收，极大方便了上层使用者。
更重要的是，string 同时也在 lua 的底层实现发挥着重要的作用。
本章就来讲解 lua 中的 string。
structure #  在 object 章节中已经提到，string 类型在 GCObject 中用 TString ts 表示。
196 197 198 199 200 201 202 203 204 205 206 207  /* ** String headers for string table */ typedef union TString { L_Umaxalign dummy; /* ensures maximum alignment for strings */ struct { CommonHeader; lu_byte reserved; unsigned int hash; size_t len; } tsv; } TString;   Code Snippet 1: lobject."><meta property="og:type" content="article"><meta property="og:url" content="https://dreamanddead.github.io/lua-5.1-source-guide/docs/string/"><meta property="article:published_time" content="2020-12-29T11:57:00+08:00"><meta property="article:modified_time" content="2021-02-23T13:26:02+08:00"><title>string | lua 5.1 source guide</title><link rel=manifest href=/lua-5.1-source-guide/manifest.json><link rel=icon href=/lua-5.1-source-guide/favicon.png type=image/x-icon><link rel=stylesheet href=/lua-5.1-source-guide/book.min.dfc677a7972fb0d86dd6eaf657edfad83e2c433246dffdf64911ee91450f0378.css integrity="sha256-38Z3p5cvsNht1ur2V+362D4sQzJG3/32SRHukUUPA3g="><script defer src=/lua-5.1-source-guide/zh.search.min.63a734a12cfe0fd29995becea70dc8f315c1540f9981491da7d955afee3cf62e.js integrity="sha256-Y6c0oSz+D9KZlb7Opw3I8xXBVA+ZgUkdp9lVr+489i4="></script><script defer src=/lua-5.1-source-guide/sw.min.630373637e97fa7891a03b850675656b8da4625d692de7ef0581b22b995ab946.js integrity="sha256-YwNzY36X+niRoDuFBnVla42kYl1pLefvBYGyK5lauUY="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/lua-5.1-source-guide><img src=/lua-5.1-source-guide/logo.png alt=Logo><span>lua 5.1 source guide</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/lua-5.1-source-guide/docs/overview/>overview</a></li><li>basic<ul><li><a href=/lua-5.1-source-guide/docs/object/>object</a></li><li><a href=/lua-5.1-source-guide/docs/memory/>memory</a></li><li><a href=/lua-5.1-source-guide/docs/string/ class=active>string</a></li><li><a href=/lua-5.1-source-guide/docs/table/>table</a></li></ul></li><li>compiler<ul><li><a href=/lua-5.1-source-guide/docs/lexer/>lexer</a></li><li><a href=/lua-5.1-source-guide/docs/opcode/>opcode</a></li><li><a href=/lua-5.1-source-guide/docs/parser/>parser</a></li><li><a href=/lua-5.1-source-guide/docs/generator/>generator</a></li></ul></li><li>vm<ul><li><a href=/lua-5.1-source-guide/docs/vm/>vm</a></li><li><a href=/lua-5.1-source-guide/docs/api/>c api</a></li><li><a href=/lua-5.1-source-guide/docs/stdlib/>stdlib</a></li><li><a href=/lua-5.1-source-guide/docs/gc/>gc</a></li></ul></li></ul><p><br></p><ul><li><a href=https://github.com/DreamAndDead/lua-5.1-source-guide target=_blank rel=noopener>Github</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/lua-5.1-source-guide/svg/menu.svg class=book-icon alt=Menu></label>
<strong>string</strong>
<label for=toc-control><img src=/lua-5.1-source-guide/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#structure>structure</a></li><li><a href=#new>new</a><ul><li><a href=#immutable>immutable</a></li><li><a href=#string-table>string table</a></li><li><a href=#method>method</a></li></ul></li><li><a href=#resize>resize</a></li><li><a href=#practice>practice</a></li></ul></li></ul></nav></aside></header><article class=markdown><p>string 是多数编程语言内建的类型，lua 也不例外。</p><p>lua 代码中使用字符串是非常方便的，呼之即来，使用后也可以不闻不问。
因为 string 在底层自动新建，并由 gc 自动回收，极大方便了上层使用者。</p><p>更重要的是，string 同时也在 lua 的底层实现发挥着重要的作用。</p><p>本章就来讲解 lua 中的 string。</p><h2 id=structure>structure
<a class=anchor href=#structure>#</a></h2><p>在
<a href=/lua-5.1-source-guide/docs/object/>object</a> 章节中已经提到，string 类型在 GCObject 中用 TString ts 表示。</p><div class=highlight><div style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">196
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">197
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">198
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">199
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">200
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">201
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">202
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">203
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">204
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">205
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">206
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">207
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#228b22>/*
</span><span style=color:#228b22>** String headers for string table
</span><span style=color:#228b22>*/</span>
<span style=color:#8b008b;font-weight:700>typedef</span> <span style=color:#8b008b;font-weight:700>union</span> TString {
  L_Umaxalign dummy;  <span style=color:#228b22>/* ensures maximum alignment for strings */</span>
  <span style=color:#8b008b;font-weight:700>struct</span> {
    CommonHeader;
    lu_byte reserved;
    <span style=color:#00688b;font-weight:700>unsigned</span> <span style=color:#00688b;font-weight:700>int</span> hash;
    size_t len;
  } tsv;
} TString;</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 1</span>:
lobject.h</div><p>TString 看上去是 union 结构，但是 dummy 只用来做对齐，并不用作实际用途，
所以考虑这一点，TString 本质还是一个 struct 结构。</p><p>除去 CommonHeader 部分，新增了 3 个字段，存储 string 的元数据，
而实际的数据部分，紧紧跟在 TString 的后面，而没有使用如 next 之类的指针来引用，是一种巧妙的方法。</p><figure><img src=string-tstring.png></figure><p>data 部分是通用的 char[]。</p><p>meta 部分，用新增的 3 个字段来记录，</p><ul><li>reserved，用于关键字（如 if，end 等），到 lex 章节再详细解释</li><li>hash，由 data 计算得到的 hash 值，在 new 小节详细解释</li><li>len，data 长度，不包含最后的 &lsquo;\0&rsquo;</li></ul><p>明确了这种结构之后，相关的宏就很容易理解。</p><div class=highlight><div style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">210
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#1e889b>#define getstr(ts)	cast(const char *, (ts) + 1)</span></code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 2</span>:
lobject.h</div><p>使用 ts + 1 来索引到 data 的位置，并取到 data 数据。</p><div class=highlight><div style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#1e889b>#define sizestring(s)	(sizeof(union TString)+((s)-&gt;len+1)*sizeof(char))</span></code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 3</span>:
lstring.h</div><p>TString 的空间大小就是 meta + data 的大小，+1 是因为要计入末尾的 &lsquo;\0&rsquo;。</p><h2 id=new>new
<a class=anchor href=#new>#</a></h2><h3 id=immutable>immutable
<a class=anchor href=#immutable>#</a></h3><p>多数 lua 用户不知道的是，lua 中所有的 string 都是不可变的，且只有一份留存在内存中。</p><p>比如如下示例代码，</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#8b008b;font-weight:700>local</span> a = <span style=color:#cd5555>&#34;pre&#34;</span>
<span style=color:#8b008b;font-weight:700>local</span> b = <span style=color:#cd5555>&#34;post&#34;</span>
<span style=color:#8b008b;font-weight:700>local</span> c = a .. b
<span style=color:#8b008b;font-weight:700>local</span> d = <span style=color:#cd5555>&#34;pre&#34;</span>
</code></pre></div><p>变量 a d 指向同一个 string 类型的 TValue（还记得吗？）</p><p><code>a .. b</code> 连接的过程没有修改 <code>"pre"</code> 或者 <code>"post"</code> ，而是新建了 <code>"prepost"</code> ，新变量 c 指向它。</p><figure><img src=string-immutable.png></figure><h3 id=string-table>string table
<a class=anchor href=#string-table>#</a></h3><p>前面提到的 immutable 的特性，正是对底层实现的一种表面呈现。</p><p>实际上，所有新建的 TString 都集合存储在 <code>global_State</code> 中的 stringtable。</p><div class=highlight><div style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">65
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">66
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">67
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">68
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">69
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#228b22>/*
</span><span style=color:#228b22>** `global state&#39;, shared by all threads of this state
</span><span style=color:#228b22>*/</span>
<span style=color:#8b008b;font-weight:700>typedef</span> <span style=color:#8b008b;font-weight:700>struct</span> global_State {
  stringtable strt;  <span style=color:#228b22>/* hash table for strings */</span></code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 4</span>:
lstate.h</div><div class=highlight><div style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#8b008b;font-weight:700>typedef</span> <span style=color:#8b008b;font-weight:700>struct</span> stringtable {
  GCObject **hash;
  lu_int32 nuse;  <span style=color:#228b22>/* number of elements */</span>
  <span style=color:#00688b;font-weight:700>int</span> size;
} stringtable;</code></pre></td></tr></table></div></div><p>stringtable 就是教科书式的 hash table 实现。</p><ul><li>hash，元素为 <code>GCObject *</code> 的桶数组</li><li>nuse，已存储 TString 的数量</li><li>size，桶数组的长度</li></ul><figure><img src=string-hashtable.png></figure><h3 id=method>method
<a class=anchor href=#method>#</a></h3><figure><img src=string-call.png></figure><p>string 模块中提供的方法非常少，新建 TString 的核心过程实现在 <code>luaS_newlstr</code> 和 <code>newlstr</code> 中。</p><div class=highlight><div style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">75
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">76
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">77
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">78
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">79
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">80
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">81
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">82
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">83
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">84
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">85
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">86
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">87
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">88
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">89
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">90
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">91
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">92
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">93
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C>TString *<span style=color:#008b45>luaS_newlstr</span> (lua_State *L, <span style=color:#8b008b;font-weight:700>const</span> <span style=color:#00688b;font-weight:700>char</span> *str, size_t l) {
  GCObject *o;
  <span style=color:#00688b;font-weight:700>unsigned</span> <span style=color:#00688b;font-weight:700>int</span> h = cast(<span style=color:#00688b;font-weight:700>unsigned</span> <span style=color:#00688b;font-weight:700>int</span>, l);  <span style=color:#228b22>/* seed */</span>
  size_t step = (l&gt;&gt;<span style=color:#b452cd>5</span>)+<span style=color:#b452cd>1</span>;  <span style=color:#228b22>/* if string is too long, don&#39;t hash all its chars */</span>
  size_t l1;
  <span style=color:#8b008b;font-weight:700>for</span> (l1=l; l1&gt;=step; l1-=step)  <span style=color:#228b22>/* compute hash */</span>
    h = h ^ ((h&lt;&lt;<span style=color:#b452cd>5</span>)+(h&gt;&gt;<span style=color:#b452cd>2</span>)+cast(<span style=color:#00688b;font-weight:700>unsigned</span> <span style=color:#00688b;font-weight:700>char</span>, str[l1-<span style=color:#b452cd>1</span>]));
  <span style=color:#8b008b;font-weight:700>for</span> (o = G(L)-&gt;strt.hash[lmod(h, G(L)-&gt;strt.size)];
       o != <span style=color:#658b00>NULL</span>;
       o = o-&gt;gch.next) {
    TString *ts = rawgco2ts(o);
    <span style=color:#8b008b;font-weight:700>if</span> (ts-&gt;tsv.len == l &amp;&amp; (memcmp(str, getstr(ts), l) == <span style=color:#b452cd>0</span>)) {
      <span style=color:#228b22>/* string may be dead */</span>
      <span style=color:#8b008b;font-weight:700>if</span> (isdead(G(L), o)) changewhite(o);
      <span style=color:#8b008b;font-weight:700>return</span> ts;
    }
  }
  <span style=color:#8b008b;font-weight:700>return</span> newlstr(L, str, l, h);  <span style=color:#228b22>/* not found */</span>
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 5</span>:
lstring.c</div><p>从公有方法 <code>luaS_newlstr</code> 开始</p><ol><li>先计算 字符串 hash</li><li>用 模除 方式找到相应的 bucket</li><li>如果桶中有元素，一路向下查找</li><li>如果有相同 <code>char *</code> 内容的元素存在，返回相应元素</li><li>直到这时，才新建 TString</li></ol><div class=highlight><div style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">53
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">54
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">55
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">56
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">57
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">58
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">59
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">60
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">61
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">62
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">63
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">64
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">65
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">66
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">67
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">68
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">69
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">70
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">71
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">72
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#8b008b;font-weight:700>static</span> TString *<span style=color:#008b45>newlstr</span> (lua_State *L, <span style=color:#8b008b;font-weight:700>const</span> <span style=color:#00688b;font-weight:700>char</span> *str, size_t l,
				       <span style=color:#00688b;font-weight:700>unsigned</span> <span style=color:#00688b;font-weight:700>int</span> h) {
  TString *ts;
  stringtable *tb;
  <span style=color:#8b008b;font-weight:700>if</span> (l+<span style=color:#b452cd>1</span> &gt; (MAX_SIZET - <span style=color:#8b008b;font-weight:700>sizeof</span>(TString))/<span style=color:#8b008b;font-weight:700>sizeof</span>(<span style=color:#00688b;font-weight:700>char</span>))
    luaM_toobig(L);
  ts = cast(TString *, luaM_malloc(L, (l+<span style=color:#b452cd>1</span>)*<span style=color:#8b008b;font-weight:700>sizeof</span>(<span style=color:#00688b;font-weight:700>char</span>)+<span style=color:#8b008b;font-weight:700>sizeof</span>(TString)));
  ts-&gt;tsv.len = l;
  ts-&gt;tsv.hash = h;
  ts-&gt;tsv.marked = luaC_white(G(L));
  ts-&gt;tsv.tt = LUA_TSTRING;
  ts-&gt;tsv.reserved = <span style=color:#b452cd>0</span>;
  memcpy(ts+<span style=color:#b452cd>1</span>, str, l*<span style=color:#8b008b;font-weight:700>sizeof</span>(<span style=color:#00688b;font-weight:700>char</span>));
  ((<span style=color:#00688b;font-weight:700>char</span> *)(ts+<span style=color:#b452cd>1</span>))[l] = <span style=color:#cd5555>&#39;\0&#39;</span>;  <span style=color:#228b22>/* ending 0 */</span>
  tb = &amp;G(L)-&gt;strt;
  h = lmod(h, tb-&gt;size);
  ts-&gt;tsv.next = tb-&gt;hash[h];  <span style=color:#228b22>/* chain new entry */</span>
  tb-&gt;hash[h] = obj2gco(ts);
  tb-&gt;nuse++;
  <span style=color:#8b008b;font-weight:700>if</span> (tb-&gt;nuse &gt; cast(lu_int32, tb-&gt;size) &amp;&amp; tb-&gt;size &lt;= MAX_INT/<span style=color:#b452cd>2</span>)
    luaS_resize(L, tb-&gt;size*<span style=color:#b452cd>2</span>);  <span style=color:#228b22>/* too crowded */</span>
  <span style=color:#8b008b;font-weight:700>return</span> ts;
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 6</span>:
lstring.c</div><p>私有方法 <code>newlstr</code> 调用的前提是，桶数组中没有相同 <code>char *</code> 内容的 TString 存在</p><ol><li>检测是否超出长度限制，在右侧减运算防止溢出</li><li>分配内存，l+1 是为了补足最后的 &lsquo;\0&rsquo;</li><li>添加后置 &lsquo;\0&rsquo;</li><li>头插法，插入到 string table 中，这样就不用判断桶中是否有元素，
使用隐藏在 CommonHeader 中的 next 将元素链接起来。</li><li>按需进行 resize</li></ol><p>理解了上述方法，余下的两个宏自然也容易理解</p><div class=highlight><div style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#1e889b>#define luaS_new(L, s)	(luaS_newlstr(L, s, strlen(s)))
</span><span style=color:#1e889b>#define luaS_newliteral(L, s)	(luaS_newlstr(L, &#34;&#34; s, \
</span><span style=color:#1e889b>				 (sizeof(s)/sizeof(char))-1))</span></code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 7</span>:
lstring.h</div><p>两者的区别在于 <code>luaS_literal</code> 只能接受字面量参数。
因为如果 <code>sizeof(s)</code> 中的 s 是 <code>char *</code> ，得到的是指针类型的长度，而不是字符串的长度。</p><h2 id=resize>resize
<a class=anchor href=#resize>#</a></h2><p>resize 方法的作用是用于动态调整 hash table 中桶的数量，</p><ul><li>如果桶个数过少，容易出现冲突</li><li>如果桶个数过多，空间利用率不高</li></ul><p>在不考虑极值的情况下</p><ul><li>当元素数量超过桶的个数，则 2 倍拓展</li><li>当元素数量小于 1/4 桶的个数，则 2 倍收缩</li></ul><div class=highlight><div style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">69
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">70
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#8b008b;font-weight:700>if</span> (tb-&gt;nuse &gt; cast(lu_int32, tb-&gt;size) &amp;&amp; tb-&gt;size &lt;= MAX_INT/<span style=color:#b452cd>2</span>)
  luaS_resize(L, tb-&gt;size*<span style=color:#b452cd>2</span>);  <span style=color:#228b22>/* too crowded */</span></code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 8</span>:
lstring.c</div><div class=highlight><div style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">433
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">434
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">435
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">436
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#228b22>/* check size of string hash */</span>
<span style=color:#8b008b;font-weight:700>if</span> (g-&gt;strt.nuse &lt; cast(lu_int32, g-&gt;strt.size/<span style=color:#b452cd>4</span>) &amp;&amp;
    g-&gt;strt.size &gt; MINSTRTABSIZE*<span style=color:#b452cd>2</span>)
  luaS_resize(L, g-&gt;strt.size/<span style=color:#b452cd>2</span>);  <span style=color:#228b22>/* table is too big */</span></code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 9</span>:
lgc.c</div><h2 id=practice>practice
<a class=anchor href=#practice>#</a></h2><ol><li><code>luaS_resize</code> 留待读者自行阅读，教科书式的实现</li><li>因为 userdata 的新建方法和 string 非常相似，在源码中也就一并放在一起，关注<ul><li><code>sizeudata</code></li><li><code>luaS_newudata</code></li></ul></li></ol><table><thead><tr><th>文件</th><th>建议</th></tr></thead><tbody><tr><td>lstring.h</td><td>仔细阅读</td></tr><tr><td>lstring.c</td><td>仔细阅读</td></tr></tbody></table></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/DreamAndDead/lua-5.1-source-guide/commit/8c359ebae66c3a96c4a0c7ed6ba49ad52483055a title="最后修改者 DreamAndDead | February 23, 2021" target=_blank rel=noopener><img src=/lua-5.1-source-guide/svg/calendar.svg class=book-icon alt=Calendar>
<span>February 23, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/DreamAndDead/lua-5.1-source-guide/edit/master/site/content/docs/string/index.md target=_blank rel=noopener><img src=/lua-5.1-source-guide/svg/edit.svg class=book-icon alt=Edit>
<span>编辑本页</span></a></div></div></footer><div class=book-comments><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"lua-book"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#structure>structure</a></li><li><a href=#new>new</a><ul><li><a href=#immutable>immutable</a></li><li><a href=#string-table>string table</a></li><li><a href=#method>method</a></li></ul></li><li><a href=#resize>resize</a></li><li><a href=#practice>practice</a></li></ul></li></ul></nav></div></aside></main></body></html>