<!doctype html><html lang=zh dir=ltr><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="string 是多数编程语言内建的类型，lua 也不例外。
lua 代码中使用字符串是非常方便的，呼之即来，使用后也可以不闻不问。 因为 string 在底层自动新建，并由 gc 自动回收，极大方便了上层使用者。
更重要的是，string 同时也在 lua 的底层实现发挥着重要的作用。
本章就来讲解 lua 中的 string。
structure #  在 object 章节中已经提到，string 类型在 GCObject 中用 TString ts 表示。
196 197 198 199 200 201 202 203 204 205 206 207  /* ** String headers for string table */ typedef union TString { L_Umaxalign dummy; /* ensures maximum alignment for strings */ struct { CommonHeader; lu_byte reserved; unsigned int hash; size_t len; } tsv; } TString;   Code Snippet 1: lobject."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="string"><meta property="og:description" content="string 是多数编程语言内建的类型，lua 也不例外。
lua 代码中使用字符串是非常方便的，呼之即来，使用后也可以不闻不问。 因为 string 在底层自动新建，并由 gc 自动回收，极大方便了上层使用者。
更重要的是，string 同时也在 lua 的底层实现发挥着重要的作用。
本章就来讲解 lua 中的 string。
structure #  在 object 章节中已经提到，string 类型在 GCObject 中用 TString ts 表示。
196 197 198 199 200 201 202 203 204 205 206 207  /* ** String headers for string table */ typedef union TString { L_Umaxalign dummy; /* ensures maximum alignment for strings */ struct { CommonHeader; lu_byte reserved; unsigned int hash; size_t len; } tsv; } TString;   Code Snippet 1: lobject."><meta property="og:type" content="article"><meta property="og:url" content="https://dreamanddead.github.io/lua-5.1-source-guide/docs/string/"><meta property="article:published_time" content="2020-12-29T11:57:00+08:00"><meta property="article:modified_time" content="2021-02-23T13:26:02+08:00"><title>string | lua 5.1 source guide</title><link rel=manifest href=/lua-5.1-source-guide/manifest.json><link rel=icon href=/lua-5.1-source-guide/favicon.png type=image/x-icon><link rel=stylesheet href=/lua-5.1-source-guide/book.min.44110be292c9f873dbe57bd8895d52b387519bad9a89a86ed5c3705e11d6b0d5.css integrity="sha256-RBEL4pLJ+HPb5XvYiV1Ss4dRm62aiahu1cNwXhHWsNU="><script defer src=/lua-5.1-source-guide/zh.search.min.7290bfd60a7f5c526bdb44d6c18babbd3e5ba6b7b0df02ac8bda3f32a4cf6542.js integrity="sha256-cpC/1gp/XFJr20TWwYurvT5bprew3wKsi9o/MqTPZUI="></script><script defer src=/lua-5.1-source-guide/sw.min.630373637e97fa7891a03b850675656b8da4625d692de7ef0581b22b995ab946.js integrity="sha256-YwNzY36X+niRoDuFBnVla42kYl1pLefvBYGyK5lauUY="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/lua-5.1-source-guide><img src=/lua-5.1-source-guide/logo.png alt=Logo><span>lua 5.1 source guide</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/lua-5.1-source-guide/docs/overview/>overview</a></li><li>basic<ul><li><a href=/lua-5.1-source-guide/docs/object/>object</a></li><li><a href=/lua-5.1-source-guide/docs/memory/>memory</a></li><li><a href=/lua-5.1-source-guide/docs/string/ class=active>string</a></li><li><a href=/lua-5.1-source-guide/docs/table/>table</a></li></ul></li><li>compiler<ul><li><a href=/lua-5.1-source-guide/docs/lexer/>lexer</a></li><li><a href=/lua-5.1-source-guide/docs/opcode/>opcode</a></li><li><a href=/lua-5.1-source-guide/docs/parser/>parser</a></li><li><a href=/lua-5.1-source-guide/docs/generator/>generator</a></li></ul></li><li>vm<ul><li><a href=/lua-5.1-source-guide/docs/vm/>vm</a></li><li><a href=/lua-5.1-source-guide/docs/api/>c api</a></li><li><a href=/lua-5.1-source-guide/docs/stdlib/>stdlib</a></li><li><a href=/lua-5.1-source-guide/docs/gc/>gc</a></li></ul></li></ul><p><br></p><ul><li><a href=https://github.com/DreamAndDead/lua-5.1-source-guide target=_blank rel=noopener>Github</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/lua-5.1-source-guide/svg/menu.svg class=book-icon alt=Menu></label>
<strong>string</strong>
<label for=toc-control><img src=/lua-5.1-source-guide/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#structure>structure</a></li><li><a href=#new>new</a><ul><li><a href=#immutable>immutable</a></li><li><a href=#string-table>string table</a></li><li><a href=#method>method</a></li></ul></li><li><a href=#resize>resize</a></li><li><a href=#practice>practice</a></li></ul></li></ul></nav></aside></header><article class=markdown><p>string 是多数编程语言内建的类型，lua 也不例外。</p><p>lua 代码中使用字符串是非常方便的，呼之即来，使用后也可以不闻不问。
因为 string 在底层自动新建，并由 gc 自动回收，极大方便了上层使用者。</p><p>更重要的是，string 同时也在 lua 的底层实现发挥着重要的作用。</p><p>本章就来讲解 lua 中的 string。</p><h2 id=structure>structure
<a class=anchor href=#structure>#</a></h2><p>在
<a href=/lua-5.1-source-guide/docs/object/>object</a> 章节中已经提到，string 类型在 GCObject 中用 TString ts 表示。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">196
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">197
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">198
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">199
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">200
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">201
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">202
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">203
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">204
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">205
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">206
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">207
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e>** String headers for string table
</span><span style=color:#75715e>*/</span>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>union</span> TString {
  L_Umaxalign dummy;  <span style=color:#75715e>/* ensures maximum alignment for strings */</span>
  <span style=color:#66d9ef>struct</span> {
    CommonHeader;
    lu_byte reserved;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> hash;
    size_t len;
  } tsv;
} TString;</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 1</span>:
lobject.h</div><p>TString 看上去是 union 结构，但是 dummy 只用来做对齐，并不用作实际用途，
所以考虑这一点，TString 本质还是一个 struct 结构。</p><p>除去 CommonHeader 部分，新增了 3 个字段，存储 string 的元数据，
而实际的数据部分，紧紧跟在 TString 的后面，而没有使用如 next 之类的指针来引用，是一种巧妙的方法。</p><figure><img src=string-tstring.png></figure><p>data 部分是通用的 char[]。</p><p>meta 部分，用新增的 3 个字段来记录，</p><ul><li>reserved，用于关键字（如 if，end 等），到 lex 章节再详细解释</li><li>hash，由 data 计算得到的 hash 值，在 new 小节详细解释</li><li>len，data 长度，不包含最后的 &lsquo;\0&rsquo;</li></ul><p>明确了这种结构之后，相关的宏就很容易理解。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">210
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define getstr(ts)	cast(const char *, (ts) + 1)</span></code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 2</span>:
lobject.h</div><p>使用 ts + 1 来索引到 data 的位置，并取到 data 数据。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define sizestring(s)	(sizeof(union TString)+((s)-&gt;len+1)*sizeof(char))</span></code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 3</span>:
lstring.h</div><p>TString 的空间大小就是 meta + data 的大小，+1 是因为要计入末尾的 &lsquo;\0&rsquo;。</p><h2 id=new>new
<a class=anchor href=#new>#</a></h2><h3 id=immutable>immutable
<a class=anchor href=#immutable>#</a></h3><p>多数 lua 用户不知道的是，lua 中所有的 string 都是不可变的，且只有一份留存在内存中。</p><p>比如如下示例代码，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> a <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;pre&#34;</span>
<span style=color:#66d9ef>local</span> b <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;post&#34;</span>
<span style=color:#66d9ef>local</span> c <span style=color:#f92672>=</span> a <span style=color:#f92672>..</span> b
<span style=color:#66d9ef>local</span> d <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;pre&#34;</span>
</code></pre></div><p>变量 a d 指向同一个 string 类型的 TValue（还记得吗？）</p><p><code>a .. b</code> 连接的过程没有修改 <code>"pre"</code> 或者 <code>"post"</code> ，而是新建了 <code>"prepost"</code> ，新变量 c 指向它。</p><figure><img src=string-immutable.png></figure><h3 id=string-table>string table
<a class=anchor href=#string-table>#</a></h3><p>前面提到的 immutable 的特性，正是对底层实现的一种表面呈现。</p><p>实际上，所有新建的 TString 都集合存储在 <code>global_State</code> 中的 stringtable。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">65
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">66
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">67
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">68
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">69
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e>** `global state&#39;, shared by all threads of this state
</span><span style=color:#75715e>*/</span>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> global_State {
  stringtable strt;  <span style=color:#75715e>/* hash table for strings */</span></code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 4</span>:
lstate.h</div><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> stringtable {
  GCObject <span style=color:#f92672>**</span>hash;
  lu_int32 nuse;  <span style=color:#75715e>/* number of elements */</span>
  <span style=color:#66d9ef>int</span> size;
} stringtable;</code></pre></td></tr></table></div></div><p>stringtable 就是教科书式的 hash table 实现。</p><ul><li>hash，元素为 <code>GCObject *</code> 的桶数组</li><li>nuse，已存储 TString 的数量</li><li>size，桶数组的长度</li></ul><figure><img src=string-hashtable.png></figure><h3 id=method>method
<a class=anchor href=#method>#</a></h3><figure><img src=string-call.png></figure><p>string 模块中提供的方法非常少，新建 TString 的核心过程实现在 <code>luaS_newlstr</code> 和 <code>newlstr</code> 中。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">75
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">76
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">77
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">78
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">79
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">80
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">81
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">82
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">83
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">84
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">85
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">86
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">87
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">88
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">89
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">90
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">91
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">92
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">93
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C>TString <span style=color:#f92672>*</span><span style=color:#a6e22e>luaS_newlstr</span> (lua_State <span style=color:#f92672>*</span>L, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>str, size_t l) {
  GCObject <span style=color:#f92672>*</span>o;
  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> h <span style=color:#f92672>=</span> cast(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>, l);  <span style=color:#75715e>/* seed */</span>
  size_t step <span style=color:#f92672>=</span> (l<span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>5</span>)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;  <span style=color:#75715e>/* if string is too long, don&#39;t hash all its chars */</span>
  size_t l1;
  <span style=color:#66d9ef>for</span> (l1<span style=color:#f92672>=</span>l; l1<span style=color:#f92672>&gt;=</span>step; l1<span style=color:#f92672>-=</span>step)  <span style=color:#75715e>/* compute hash */</span>
    h <span style=color:#f92672>=</span> h <span style=color:#f92672>^</span> ((h<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>5</span>)<span style=color:#f92672>+</span>(h<span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>2</span>)<span style=color:#f92672>+</span>cast(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span>, str[l1<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]));
  <span style=color:#66d9ef>for</span> (o <span style=color:#f92672>=</span> G(L)<span style=color:#f92672>-&gt;</span>strt.hash[lmod(h, G(L)<span style=color:#f92672>-&gt;</span>strt.size)];
       o <span style=color:#f92672>!=</span> NULL;
       o <span style=color:#f92672>=</span> o<span style=color:#f92672>-&gt;</span>gch.next) {
    TString <span style=color:#f92672>*</span>ts <span style=color:#f92672>=</span> rawgco2ts(o);
    <span style=color:#66d9ef>if</span> (ts<span style=color:#f92672>-&gt;</span>tsv.len <span style=color:#f92672>==</span> l <span style=color:#f92672>&amp;&amp;</span> (memcmp(str, getstr(ts), l) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)) {
      <span style=color:#75715e>/* string may be dead */</span>
      <span style=color:#66d9ef>if</span> (isdead(G(L), o)) changewhite(o);
      <span style=color:#66d9ef>return</span> ts;
    }
  }
  <span style=color:#66d9ef>return</span> newlstr(L, str, l, h);  <span style=color:#75715e>/* not found */</span>
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 5</span>:
lstring.c</div><p>从公有方法 <code>luaS_newlstr</code> 开始</p><ol><li>先计算 字符串 hash</li><li>用 模除 方式找到相应的 bucket</li><li>如果桶中有元素，一路向下查找</li><li>如果有相同 <code>char *</code> 内容的元素存在，返回相应元素</li><li>直到这时，才新建 TString</li></ol><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">53
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">54
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">55
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">56
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">57
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">58
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">59
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">60
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">61
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">62
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">63
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">64
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">65
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">66
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">67
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">68
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">69
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">70
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">71
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">72
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>static</span> TString <span style=color:#f92672>*</span><span style=color:#a6e22e>newlstr</span> (lua_State <span style=color:#f92672>*</span>L, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>str, size_t l,
				       <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> h) {
  TString <span style=color:#f92672>*</span>ts;
  stringtable <span style=color:#f92672>*</span>tb;
  <span style=color:#66d9ef>if</span> (l<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;</span> (MAX_SIZET <span style=color:#f92672>-</span> <span style=color:#66d9ef>sizeof</span>(TString))<span style=color:#f92672>/</span><span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>char</span>))
    luaM_toobig(L);
  ts <span style=color:#f92672>=</span> cast(TString <span style=color:#f92672>*</span>, luaM_malloc(L, (l<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>*</span><span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>char</span>)<span style=color:#f92672>+</span><span style=color:#66d9ef>sizeof</span>(TString)));
  ts<span style=color:#f92672>-&gt;</span>tsv.len <span style=color:#f92672>=</span> l;
  ts<span style=color:#f92672>-&gt;</span>tsv.hash <span style=color:#f92672>=</span> h;
  ts<span style=color:#f92672>-&gt;</span>tsv.marked <span style=color:#f92672>=</span> luaC_white(G(L));
  ts<span style=color:#f92672>-&gt;</span>tsv.tt <span style=color:#f92672>=</span> LUA_TSTRING;
  ts<span style=color:#f92672>-&gt;</span>tsv.reserved <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  memcpy(ts<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, str, l<span style=color:#f92672>*</span><span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>char</span>));
  ((<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)(ts<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>))[l] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;  <span style=color:#75715e>/* ending 0 */</span>
  tb <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>G(L)<span style=color:#f92672>-&gt;</span>strt;
  h <span style=color:#f92672>=</span> lmod(h, tb<span style=color:#f92672>-&gt;</span>size);
  ts<span style=color:#f92672>-&gt;</span>tsv.next <span style=color:#f92672>=</span> tb<span style=color:#f92672>-&gt;</span>hash[h];  <span style=color:#75715e>/* chain new entry */</span>
  tb<span style=color:#f92672>-&gt;</span>hash[h] <span style=color:#f92672>=</span> obj2gco(ts);
  tb<span style=color:#f92672>-&gt;</span>nuse<span style=color:#f92672>++</span>;
  <span style=color:#66d9ef>if</span> (tb<span style=color:#f92672>-&gt;</span>nuse <span style=color:#f92672>&gt;</span> cast(lu_int32, tb<span style=color:#f92672>-&gt;</span>size) <span style=color:#f92672>&amp;&amp;</span> tb<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>&lt;=</span> MAX_INT<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>)
    luaS_resize(L, tb<span style=color:#f92672>-&gt;</span>size<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>);  <span style=color:#75715e>/* too crowded */</span>
  <span style=color:#66d9ef>return</span> ts;
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 6</span>:
lstring.c</div><p>私有方法 <code>newlstr</code> 调用的前提是，桶数组中没有相同 <code>char *</code> 内容的 TString 存在</p><ol><li>检测是否超出长度限制，在右侧减运算防止溢出</li><li>分配内存，l+1 是为了补足最后的 &lsquo;\0&rsquo;</li><li>添加后置 &lsquo;\0&rsquo;</li><li>头插法，插入到 string table 中，这样就不用判断桶中是否有元素，
使用隐藏在 CommonHeader 中的 next 将元素链接起来。</li><li>按需进行 resize</li></ol><p>理解了上述方法，余下的两个宏自然也容易理解</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define luaS_new(L, s)	(luaS_newlstr(L, s, strlen(s)))
</span><span style=color:#75715e>#define luaS_newliteral(L, s)	(luaS_newlstr(L, &#34;&#34; s, \
</span><span style=color:#75715e>				 (sizeof(s)/sizeof(char))-1))</span></code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 7</span>:
lstring.h</div><p>两者的区别在于 <code>luaS_literal</code> 只能接受字面量参数。
因为如果 <code>sizeof(s)</code> 中的 s 是 <code>char *</code> ，得到的是指针类型的长度，而不是字符串的长度。</p><h2 id=resize>resize
<a class=anchor href=#resize>#</a></h2><p>resize 方法的作用是用于动态调整 hash table 中桶的数量，</p><ul><li>如果桶个数过少，容易出现冲突</li><li>如果桶个数过多，空间利用率不高</li></ul><p>在不考虑极值的情况下</p><ul><li>当元素数量超过桶的个数，则 2 倍拓展</li><li>当元素数量小于 1/4 桶的个数，则 2 倍收缩</li></ul><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">69
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">70
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>if</span> (tb<span style=color:#f92672>-&gt;</span>nuse <span style=color:#f92672>&gt;</span> cast(lu_int32, tb<span style=color:#f92672>-&gt;</span>size) <span style=color:#f92672>&amp;&amp;</span> tb<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>&lt;=</span> MAX_INT<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>)
  luaS_resize(L, tb<span style=color:#f92672>-&gt;</span>size<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>);  <span style=color:#75715e>/* too crowded */</span></code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 8</span>:
lstring.c</div><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">433
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">434
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">435
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">436
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/* check size of string hash */</span>
<span style=color:#66d9ef>if</span> (g<span style=color:#f92672>-&gt;</span>strt.nuse <span style=color:#f92672>&lt;</span> cast(lu_int32, g<span style=color:#f92672>-&gt;</span>strt.size<span style=color:#f92672>/</span><span style=color:#ae81ff>4</span>) <span style=color:#f92672>&amp;&amp;</span>
    g<span style=color:#f92672>-&gt;</span>strt.size <span style=color:#f92672>&gt;</span> MINSTRTABSIZE<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>)
  luaS_resize(L, g<span style=color:#f92672>-&gt;</span>strt.size<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>);  <span style=color:#75715e>/* table is too big */</span></code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 9</span>:
lgc.c</div><h2 id=practice>practice
<a class=anchor href=#practice>#</a></h2><ol><li><code>luaS_resize</code> 留待读者自行阅读，教科书式的实现</li><li>因为 userdata 的新建方法和 string 非常相似，在源码中也就一并放在一起，关注<ul><li><code>sizeudata</code></li><li><code>luaS_newudata</code></li></ul></li></ol><table><thead><tr><th>文件</th><th>建议</th></tr></thead><tbody><tr><td>lstring.h</td><td>仔细阅读</td></tr><tr><td>lstring.c</td><td>仔细阅读</td></tr></tbody></table></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/DreamAndDead/lua-5.1-source-guide/commit/8c359ebae66c3a96c4a0c7ed6ba49ad52483055a title="最后修改者 DreamAndDead | February 23, 2021" target=_blank rel=noopener><img src=/lua-5.1-source-guide/svg/calendar.svg class=book-icon alt=Calendar>
<span>February 23, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/DreamAndDead/lua-5.1-source-guide/edit/master/site/content/docs/string/index.md target=_blank rel=noopener><img src=/lua-5.1-source-guide/svg/edit.svg class=book-icon alt=Edit>
<span>编辑本页</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#structure>structure</a></li><li><a href=#new>new</a><ul><li><a href=#immutable>immutable</a></li><li><a href=#string-table>string table</a></li><li><a href=#method>method</a></li></ul></li><li><a href=#resize>resize</a></li><li><a href=#practice>practice</a></li></ul></li></ul></nav></div></aside></main></body></html>