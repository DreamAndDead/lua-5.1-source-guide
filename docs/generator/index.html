<!doctype html><html lang=zh dir=ltr><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="上一章尝试单独解析语法分析过程，本章关注具体的代码生成过程。
  function vs proto vs closure #  在具体深入代码生成之前，先来区分三个概念，function proto 和 closure。
function，是 lua 语言中定义的概念，是 8 种基础类型之一，表示函数， 具体在 lua 代码中用关键字 function 来定义。
如同 string 概念在底层由 TString 结构来实现一样， function 在底层用 Proto 结构来实现，是 function 整体编译之后得到的同语义结构。
编译得到的 Proto 是静态的，在实际运行的时候，需要封装为 Closure 结构，交由 vm 来执行。 Closure 为 upvalue 分配了空间，并统一表示了 c function 和 lua function。
这也是为什么在 object 章节，提到基础类型对应的实现结构时，用 Closure 而不是用 Proto 来表示 function。
所以在编译时期，我们关注 Proto，而在运行时期，才关注 Closure。
chunk #  lua 内部使用了一种巧妙的实现，在编译时，将整个文件当做一个匿名 function 来对待。 相当于文件头加了 function () ，文件尾加了 end 。"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="generator"><meta property="og:description" content="上一章尝试单独解析语法分析过程，本章关注具体的代码生成过程。
  function vs proto vs closure #  在具体深入代码生成之前，先来区分三个概念，function proto 和 closure。
function，是 lua 语言中定义的概念，是 8 种基础类型之一，表示函数， 具体在 lua 代码中用关键字 function 来定义。
如同 string 概念在底层由 TString 结构来实现一样， function 在底层用 Proto 结构来实现，是 function 整体编译之后得到的同语义结构。
编译得到的 Proto 是静态的，在实际运行的时候，需要封装为 Closure 结构，交由 vm 来执行。 Closure 为 upvalue 分配了空间，并统一表示了 c function 和 lua function。
这也是为什么在 object 章节，提到基础类型对应的实现结构时，用 Closure 而不是用 Proto 来表示 function。
所以在编译时期，我们关注 Proto，而在运行时期，才关注 Closure。
chunk #  lua 内部使用了一种巧妙的实现，在编译时，将整个文件当做一个匿名 function 来对待。 相当于文件头加了 function () ，文件尾加了 end 。"><meta property="og:type" content="article"><meta property="og:url" content="https://dreamanddead.github.io/lua-5.1-source-guide/docs/generator/"><meta property="og:image" content="https://dreamanddead.github.io/lua-5.1-source-guide/docs/generator/generator-feature.png"><meta property="article:published_time" content="2021-01-08T11:34:00+08:00"><meta property="article:modified_time" content="2021-02-23T13:26:02+08:00"><title>generator | lua 5.1 source guide</title><link rel=manifest href=/lua-5.1-source-guide/manifest.json><link rel=icon href=/lua-5.1-source-guide/favicon.png type=image/x-icon><link rel=stylesheet href=/lua-5.1-source-guide/book.min.44110be292c9f873dbe57bd8895d52b387519bad9a89a86ed5c3705e11d6b0d5.css integrity="sha256-RBEL4pLJ+HPb5XvYiV1Ss4dRm62aiahu1cNwXhHWsNU="><script defer src=/lua-5.1-source-guide/zh.search.min.7290bfd60a7f5c526bdb44d6c18babbd3e5ba6b7b0df02ac8bda3f32a4cf6542.js integrity="sha256-cpC/1gp/XFJr20TWwYurvT5bprew3wKsi9o/MqTPZUI="></script><script defer src=/lua-5.1-source-guide/sw.min.630373637e97fa7891a03b850675656b8da4625d692de7ef0581b22b995ab946.js integrity="sha256-YwNzY36X+niRoDuFBnVla42kYl1pLefvBYGyK5lauUY="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/lua-5.1-source-guide><img src=/lua-5.1-source-guide/logo.png alt=Logo><span>lua 5.1 source guide</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/lua-5.1-source-guide/docs/overview/>overview</a></li><li>basic<ul><li><a href=/lua-5.1-source-guide/docs/object/>object</a></li><li><a href=/lua-5.1-source-guide/docs/memory/>memory</a></li><li><a href=/lua-5.1-source-guide/docs/string/>string</a></li><li><a href=/lua-5.1-source-guide/docs/table/>table</a></li></ul></li><li>compiler<ul><li><a href=/lua-5.1-source-guide/docs/lexer/>lexer</a></li><li><a href=/lua-5.1-source-guide/docs/opcode/>opcode</a></li><li><a href=/lua-5.1-source-guide/docs/parser/>parser</a></li><li><a href=/lua-5.1-source-guide/docs/generator/ class=active>generator</a></li></ul></li><li>vm<ul><li><a href=/lua-5.1-source-guide/docs/vm/>vm</a></li><li><a href=/lua-5.1-source-guide/docs/api/>c api</a></li><li><a href=/lua-5.1-source-guide/docs/stdlib/>stdlib</a></li><li><a href=/lua-5.1-source-guide/docs/gc/>gc</a></li></ul></li></ul><p><br></p><ul><li><a href=https://github.com/DreamAndDead/lua-5.1-source-guide target=_blank rel=noopener>Github</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/lua-5.1-source-guide/svg/menu.svg class=book-icon alt=Menu></label>
<strong>generator</strong>
<label for=toc-control><img src=/lua-5.1-source-guide/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#function-vs-proto-vs-closure>function vs proto vs closure</a><ul><li><a href=#chunk>chunk</a></li><li><a href=#embeded>embeded</a></li><li><a href=#funcstate>FuncState</a></li><li><a href=#big-picture>big picture</a></li><li><a href=#funcstate-vs-proto>FuncState vs Proto</a></li></ul></li><li><a href=#generate>generate</a></li><li><a href=#key-concept>key concept</a><ul><li><a href=#variable>variable</a></li><li><a href=#register>register</a></li></ul></li><li><a href=#statement>statement</a><ul><li><a href=#tool>tool</a></li><li><a href=#local>local</a></li><li><a href=#expdesc>expdesc</a></li><li><a href=#assign>assign</a></li><li><a href=#function>function</a></li><li><a href=#do>do</a></li><li><a href=#if>if</a></li><li><a href=#while>while</a></li><li><a href=#for>for</a></li><li><a href=#ret>ret</a></li><li><a href=#function-call>function call</a></li></ul></li><li><a href=#practice>practice</a></li></ul></li></ul></nav></aside></header><article class=markdown><p>上一章尝试单独解析语法分析过程，本章关注具体的代码生成过程。</p><figure><img src=generator-feature.png></figure><h2 id=function-vs-proto-vs-closure>function vs proto vs closure
<a class=anchor href=#function-vs-proto-vs-closure>#</a></h2><p>在具体深入代码生成之前，先来区分三个概念，function proto 和 closure。</p><p>function，是 lua 语言中定义的概念，是 8 种基础类型之一，表示函数，
具体在 lua 代码中用关键字 <code>function</code> 来定义。</p><p>如同 string 概念在底层由 TString 结构来实现一样，
function 在底层用 Proto 结构来实现，是 function 整体编译之后得到的同语义结构。</p><p>编译得到的 Proto 是静态的，在实际运行的时候，需要封装为 Closure 结构，交由 vm 来执行。
Closure 为 upvalue 分配了空间，并统一表示了 c function 和 lua function。</p><p>这也是为什么在 object 章节，提到基础类型对应的实现结构时，用 Closure 而不是用 Proto 来表示 function。</p><p>所以在编译时期，我们关注 Proto，而在运行时期，才关注 Closure。</p><h3 id=chunk>chunk
<a class=anchor href=#chunk>#</a></h3><p>lua 内部使用了一种巧妙的实现，在编译时，将整个文件当做一个匿名 function 来对待。
相当于文件头加了 <code>function ()</code> ，文件尾加了 <code>end</code> 。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">383
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">384
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">385
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">386
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">387
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">388
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">389
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">390
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">391
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">392
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">393
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">394
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">395
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">396
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">397
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">398
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>Proto <span style=color:#f92672>*</span><span style=color:#a6e22e>luaY_parser</span> (lua_State <span style=color:#f92672>*</span>L, ZIO <span style=color:#f92672>*</span>z, Mbuffer <span style=color:#f92672>*</span>buff, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name) {
  <span style=color:#66d9ef>struct</span> LexState lexstate;
  <span style=color:#66d9ef>struct</span> FuncState funcstate;
  lexstate.buff <span style=color:#f92672>=</span> buff;
  luaX_setinput(L, <span style=color:#f92672>&amp;</span>lexstate, z, luaS_new(L, name));
  open_func(<span style=color:#f92672>&amp;</span>lexstate, <span style=color:#f92672>&amp;</span>funcstate);
  funcstate.f<span style=color:#f92672>-&gt;</span>is_vararg <span style=color:#f92672>=</span> VARARG_ISVARARG;  <span style=color:#75715e>/* main func. is always vararg */</span>
  luaX_next(<span style=color:#f92672>&amp;</span>lexstate);  <span style=color:#75715e>/* read first token */</span>
  chunk(<span style=color:#f92672>&amp;</span>lexstate);
  check(<span style=color:#f92672>&amp;</span>lexstate, TK_EOS);
  close_func(<span style=color:#f92672>&amp;</span>lexstate);
  lua_assert(funcstate.prev <span style=color:#f92672>==</span> NULL);
  lua_assert(funcstate.f<span style=color:#f92672>-&gt;</span>nups <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>);
  lua_assert(lexstate.fs <span style=color:#f92672>==</span> NULL);
  <span style=color:#66d9ef>return</span> funcstate.f;
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 1</span>:
lparser.c</div><p>可以看到， <code>luaY_parser</code> 读取文件，最终生成并返回 <code>Proto *</code> 。</p><p>因为整体分析的入口是 chunk，lua 又将文件当做匿名函数来对待，
这也是很多 lua 书籍中提到 chunk 的原因，表示文件编译得到的结果。</p><h3 id=embeded>embeded
<a class=anchor href=#embeded>#</a></h3><p>如果按照 function 和 Proto 一一对应的关系，会出现函数层级的问题。</p><p>比如下面的示例代码，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>a</span>()
   <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>b</span>()
   <span style=color:#66d9ef>end</span>
<span style=color:#66d9ef>end</span>

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>c</span>()
   <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>d</span>()
   <span style=color:#66d9ef>end</span>

   <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>e</span>()
   <span style=color:#66d9ef>end</span>
<span style=color:#66d9ef>end</span>
</code></pre></div><p>如果将 lua 代码文件看作 Proto chunk，代码中定义的 a b c d 同样是 function 且编译为 Proto。
但是 function a b c d e 是 lua 代码的一部分，所以其 Proto 也应该被包含在 Proto chunk 中。</p><p>lua 内部根据 function 定义的位置，来记录这种包含关系。</p><figure><img src=generator-function-level.png></figure><p>function a c 直接定义在代码文件（顶层匿名函数）中，
b d e 则直接定义在 a 和 c 中。</p><figure><img src=generator-proto-level.png></figure><p>Proto 结构中使用 struct Proto * 数组 p（Line 235）来记录其直接包含的 Proto。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">228
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">229
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">230
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">231
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">232
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">233
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">234
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">235
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">236
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">237
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">238
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">239
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">240
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">241
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">242
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">243
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">244
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">245
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">246
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">247
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">248
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">249
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">250
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">251
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">252
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">253
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#75715e>/*
</span><span style=color:#75715e>** Function Prototypes
</span><span style=color:#75715e>*/</span>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> Proto {
  CommonHeader;
  TValue <span style=color:#f92672>*</span>k;  <span style=color:#75715e>/* constants used by the function */</span>
  Instruction <span style=color:#f92672>*</span>code;
  <span style=color:#66d9ef>struct</span> Proto <span style=color:#f92672>**</span>p;  <span style=color:#75715e>/* functions defined inside the function */</span>
  <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>lineinfo;  <span style=color:#75715e>/* map from opcodes to source lines */</span>
  <span style=color:#66d9ef>struct</span> LocVar <span style=color:#f92672>*</span>locvars;  <span style=color:#75715e>/* information about local variables */</span>
  TString <span style=color:#f92672>**</span>upvalues;  <span style=color:#75715e>/* upvalue names */</span>
  TString  <span style=color:#f92672>*</span>source;
  <span style=color:#66d9ef>int</span> sizeupvalues;
  <span style=color:#66d9ef>int</span> sizek;  <span style=color:#75715e>/* size of `k&#39; */</span>
  <span style=color:#66d9ef>int</span> sizecode;
  <span style=color:#66d9ef>int</span> sizelineinfo;
  <span style=color:#66d9ef>int</span> sizep;  <span style=color:#75715e>/* size of `p&#39; */</span>
  <span style=color:#66d9ef>int</span> sizelocvars;
  <span style=color:#66d9ef>int</span> linedefined;
  <span style=color:#66d9ef>int</span> lastlinedefined;
  GCObject <span style=color:#f92672>*</span>gclist;
  lu_byte nups;  <span style=color:#75715e>/* number of upvalues */</span>
  lu_byte numparams;
  lu_byte is_vararg;
  lu_byte maxstacksize;
} Proto;</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 2</span>:
lobject.h</div><h3 id=funcstate>FuncState
<a class=anchor href=#funcstate>#</a></h3><p>在 lua 的语法分析中，function 解析是一个重要的部分。</p><p>EBNF 和 regex 的区别在于，EBNF 可以描述一种递归过程，而 regex 则不能。</p><p>chunk 作为解析 function 的入口，得到 Proto，这个过程在遇到 function 定义时，不断的递归调用，生成 Proto，
并按照层级链接起来。</p><p>在了解这个过程之前，要先介绍另一个重要的结构 FuncState 。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">57
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">58
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">59
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">60
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">61
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">62
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">63
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">64
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">65
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">66
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">67
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">68
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">69
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">70
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">71
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">72
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">73
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">74
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">75
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/* state needed to generate code for a given function */</span>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> FuncState {
  Proto <span style=color:#f92672>*</span>f;  <span style=color:#75715e>/* current function header */</span>
  Table <span style=color:#f92672>*</span>h;  <span style=color:#75715e>/* table to find (and reuse) elements in `k&#39; */</span>
  <span style=color:#66d9ef>struct</span> FuncState <span style=color:#f92672>*</span>prev;  <span style=color:#75715e>/* enclosing function */</span>
  <span style=color:#66d9ef>struct</span> LexState <span style=color:#f92672>*</span>ls;  <span style=color:#75715e>/* lexical state */</span>
  <span style=color:#66d9ef>struct</span> lua_State <span style=color:#f92672>*</span>L;  <span style=color:#75715e>/* copy of the Lua state */</span>
  <span style=color:#66d9ef>struct</span> BlockCnt <span style=color:#f92672>*</span>bl;  <span style=color:#75715e>/* chain of current blocks */</span>
  <span style=color:#66d9ef>int</span> pc;  <span style=color:#75715e>/* next position to code (equivalent to `ncode&#39;) */</span>
  <span style=color:#66d9ef>int</span> lasttarget;   <span style=color:#75715e>/* `pc&#39; of last `jump target&#39; */</span>
  <span style=color:#66d9ef>int</span> jpc;  <span style=color:#75715e>/* list of pending jumps to `pc&#39; */</span>
  <span style=color:#66d9ef>int</span> freereg;  <span style=color:#75715e>/* first free register */</span>
  <span style=color:#66d9ef>int</span> nk;  <span style=color:#75715e>/* number of elements in `k&#39; */</span>
  <span style=color:#66d9ef>int</span> np;  <span style=color:#75715e>/* number of elements in `p&#39; */</span>
  <span style=color:#66d9ef>short</span> nlocvars;  <span style=color:#75715e>/* number of elements in `locvars&#39; */</span>
  lu_byte nactvar;  <span style=color:#75715e>/* number of active local variables */</span>
  upvaldesc upvalues[LUAI_MAXUPVALUES];  <span style=color:#75715e>/* upvalues */</span>
  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> actvar[LUAI_MAXVARS];  <span style=color:#75715e>/* declared-variable stack */</span>
} FuncState;</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 3</span>:
lparser.h</div><p>从名称可以看出，和 LexState 相似，也用于记录中间状态。
FuncState 用于记录 function 分析过程中的状态，和 function 定义一一对应，
每遇到一个 function 定义时，lua 都会新建一个 FuncState，记录当下解析 function 的中间状态。</p><h3 id=big-picture>big picture
<a class=anchor href=#big-picture>#</a></h3><p>LexState FuncState Proto 这三者在分析过程中协同生成最终的 Proto。</p><p>比如解析如下示例代码，</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>a</span>()
   <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>b</span>()
   <span style=color:#66d9ef>end</span>
<span style=color:#66d9ef>end</span></code></pre></td></tr></table></div></div><p>在整体文件分析开始之前，parser 已经准备好 FuncState，通过 LexState.ls 索引，
FuncState.f 指向相应要生成的 Proto。</p><figure><img src=generator-big-picture-0.png></figure><p>解析第 1 行之后，需要函数定义 a，parser 生成新的 FuncState，并更新 ls.fs 的指向。
同时，fs a 通过 prev 指向 fs chunk，表示层级关系。</p><figure><img src=generator-big-picture-1.png></figure><p>第 2 行，遇到函数 b 定义，同样的，生成 FuncState 并更新 ls.fs 的指向。</p><figure><img src=generator-big-picture-2.png></figure><p>第 3 行，函数 b 定义结束，此时 ls.fs 指向 fs b 的 prev，回到上个函数定义层级。
并将函数 b 生成的 Proto 链接到上层函数 a 的 Proto。</p><p>此时，fs b 已经结束其作用。</p><figure><img src=generator-big-picture-3.png></figure><figure><img src=generator-big-picture-4.png></figure><p>第 4 行，函数 a 定义结束，同上，更新 ls.fs 指向，并链接 Proto a 到 Proto chunk。</p><figure><img src=generator-big-picture-5.png></figure><p>最终返回 Proto chunk，ls 和 fs 都已经结束其使命，毕竟它们的作用只用于记录中间状态</p><p>在 parser 内部，上面描述的过程发生在 <code>open_func() close_func()</code> 中，读者可仔细体会其细节。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">328
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">329
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">330
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">331
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">332
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">333
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">334
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">335
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">336
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">337
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">338
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">339
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">340
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">341
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">342
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">343
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">344
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">345
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">346
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">347
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">348
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">349
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">350
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">351
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">352
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">353
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">354
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">355
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">356
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">357
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">358
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">359
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">360
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">361
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">362
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">363
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">364
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">365
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">366
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">367
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">368
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">369
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">370
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">371
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">372
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">373
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">374
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">375
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">376
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">377
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">378
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">379
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">380
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>open_func</span> (LexState <span style=color:#f92672>*</span>ls, FuncState <span style=color:#f92672>*</span>fs) {
  lua_State <span style=color:#f92672>*</span>L <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>L;
  Proto <span style=color:#f92672>*</span>f <span style=color:#f92672>=</span> luaF_newproto(L);
  fs<span style=color:#f92672>-&gt;</span>f <span style=color:#f92672>=</span> f;
  fs<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>fs;  <span style=color:#75715e>/* linked list of funcstates */</span>
  fs<span style=color:#f92672>-&gt;</span>ls <span style=color:#f92672>=</span> ls;
  fs<span style=color:#f92672>-&gt;</span>L <span style=color:#f92672>=</span> L;
  ls<span style=color:#f92672>-&gt;</span>fs <span style=color:#f92672>=</span> fs;
  fs<span style=color:#f92672>-&gt;</span>pc <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  fs<span style=color:#f92672>-&gt;</span>lasttarget <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
  fs<span style=color:#f92672>-&gt;</span>jpc <span style=color:#f92672>=</span> NO_JUMP;
  fs<span style=color:#f92672>-&gt;</span>freereg <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  fs<span style=color:#f92672>-&gt;</span>nk <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  fs<span style=color:#f92672>-&gt;</span>np <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  fs<span style=color:#f92672>-&gt;</span>nlocvars <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  fs<span style=color:#f92672>-&gt;</span>nactvar <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  fs<span style=color:#f92672>-&gt;</span>bl <span style=color:#f92672>=</span> NULL;
  f<span style=color:#f92672>-&gt;</span>source <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>source;
  f<span style=color:#f92672>-&gt;</span>maxstacksize <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;  <span style=color:#75715e>/* registers 0/1 are always valid */</span>
  fs<span style=color:#f92672>-&gt;</span>h <span style=color:#f92672>=</span> luaH_new(L, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
  <span style=color:#75715e>/* anchor table of constants and prototype (to avoid being collected) */</span>
  sethvalue2s(L, L<span style=color:#f92672>-&gt;</span>top, fs<span style=color:#f92672>-&gt;</span>h);
  incr_top(L);
  setptvalue2s(L, L<span style=color:#f92672>-&gt;</span>top, f);
  incr_top(L);
}


<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>close_func</span> (LexState <span style=color:#f92672>*</span>ls) {
  lua_State <span style=color:#f92672>*</span>L <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>L;
  FuncState <span style=color:#f92672>*</span>fs <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>fs;
  Proto <span style=color:#f92672>*</span>f <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>f;
  removevars(ls, <span style=color:#ae81ff>0</span>);
  luaK_ret(fs, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);  <span style=color:#75715e>/* final return */</span>
  luaM_reallocvector(L, f<span style=color:#f92672>-&gt;</span>code, f<span style=color:#f92672>-&gt;</span>sizecode, fs<span style=color:#f92672>-&gt;</span>pc, Instruction);
  f<span style=color:#f92672>-&gt;</span>sizecode <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>pc;
  luaM_reallocvector(L, f<span style=color:#f92672>-&gt;</span>lineinfo, f<span style=color:#f92672>-&gt;</span>sizelineinfo, fs<span style=color:#f92672>-&gt;</span>pc, <span style=color:#66d9ef>int</span>);
  f<span style=color:#f92672>-&gt;</span>sizelineinfo <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>pc;
  luaM_reallocvector(L, f<span style=color:#f92672>-&gt;</span>k, f<span style=color:#f92672>-&gt;</span>sizek, fs<span style=color:#f92672>-&gt;</span>nk, TValue);
  f<span style=color:#f92672>-&gt;</span>sizek <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>nk;
  luaM_reallocvector(L, f<span style=color:#f92672>-&gt;</span>p, f<span style=color:#f92672>-&gt;</span>sizep, fs<span style=color:#f92672>-&gt;</span>np, Proto <span style=color:#f92672>*</span>);
  f<span style=color:#f92672>-&gt;</span>sizep <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>np;
  luaM_reallocvector(L, f<span style=color:#f92672>-&gt;</span>locvars, f<span style=color:#f92672>-&gt;</span>sizelocvars, fs<span style=color:#f92672>-&gt;</span>nlocvars, LocVar);
  f<span style=color:#f92672>-&gt;</span>sizelocvars <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>nlocvars;
  luaM_reallocvector(L, f<span style=color:#f92672>-&gt;</span>upvalues, f<span style=color:#f92672>-&gt;</span>sizeupvalues, f<span style=color:#f92672>-&gt;</span>nups, TString <span style=color:#f92672>*</span>);
  f<span style=color:#f92672>-&gt;</span>sizeupvalues <span style=color:#f92672>=</span> f<span style=color:#f92672>-&gt;</span>nups;
  lua_assert(luaG_checkcode(f));
  lua_assert(fs<span style=color:#f92672>-&gt;</span>bl <span style=color:#f92672>==</span> NULL);
  ls<span style=color:#f92672>-&gt;</span>fs <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>prev;
  <span style=color:#75715e>/* last token read was anchored in defunct function; must reanchor it */</span>
  <span style=color:#66d9ef>if</span> (fs) anchor_token(ls);
  L<span style=color:#f92672>-&gt;</span>top <span style=color:#f92672>-=</span> <span style=color:#ae81ff>2</span>;  <span style=color:#75715e>/* remove table and prototype from the stack */</span>
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 4</span>:
lparser.c</div><h3 id=funcstate-vs-proto>FuncState vs Proto
<a class=anchor href=#funcstate-vs-proto>#</a></h3><p>FuncState 和 Proto 作为分析过程中两个最重要的结构，值得详细做一番了解。</p><p>仔细观察两个结构内部的字段，会发现两者之间有紧密的联系，界限很模糊，
都些许记录了分析过程的结果。
关键的差异在于，Proto 只保留最终结果，而 FuncState 记录中间状态。</p><p>对应这个原则，来详细探究下两个结构的内部。</p><p>先来看 Proto。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">228
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">229
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">230
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">231
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">232
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">233
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">234
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">235
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">236
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">237
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">238
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">239
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">240
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">241
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">242
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">243
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">244
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">245
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">246
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">247
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">248
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">249
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">250
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">251
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">252
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">253
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#75715e>/*
</span><span style=color:#75715e>** Function Prototypes
</span><span style=color:#75715e>*/</span>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> Proto {
  CommonHeader;
  TValue <span style=color:#f92672>*</span>k;  <span style=color:#75715e>/* constants used by the function */</span>
  Instruction <span style=color:#f92672>*</span>code;
  <span style=color:#66d9ef>struct</span> Proto <span style=color:#f92672>**</span>p;  <span style=color:#75715e>/* functions defined inside the function */</span>
  <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>lineinfo;  <span style=color:#75715e>/* map from opcodes to source lines */</span>
  <span style=color:#66d9ef>struct</span> LocVar <span style=color:#f92672>*</span>locvars;  <span style=color:#75715e>/* information about local variables */</span>
  TString <span style=color:#f92672>**</span>upvalues;  <span style=color:#75715e>/* upvalue names */</span>
  TString  <span style=color:#f92672>*</span>source;
  <span style=color:#66d9ef>int</span> sizeupvalues;
  <span style=color:#66d9ef>int</span> sizek;  <span style=color:#75715e>/* size of `k&#39; */</span>
  <span style=color:#66d9ef>int</span> sizecode;
  <span style=color:#66d9ef>int</span> sizelineinfo;
  <span style=color:#66d9ef>int</span> sizep;  <span style=color:#75715e>/* size of `p&#39; */</span>
  <span style=color:#66d9ef>int</span> sizelocvars;
  <span style=color:#66d9ef>int</span> linedefined;
  <span style=color:#66d9ef>int</span> lastlinedefined;
  GCObject <span style=color:#f92672>*</span>gclist;
  lu_byte nups;  <span style=color:#75715e>/* number of upvalues */</span>
  lu_byte numparams;
  lu_byte is_vararg;
  lu_byte maxstacksize;
} Proto;</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 5</span>:
lobject.h</div><p>其中字段分为 3 部分来看</p><p>暂不讨论</p><ul><li><code>int *lineinfo</code></li><li><code>TString *source</code></li><li><code>int linedefined</code></li><li><code>int lastlinedefined</code></li><li><code>GCObject *gclist</code></li></ul><p>元信息</p><ul><li><code>lu_byte numparams</code> ，函数的固定参数个数</li><li><code>lu_byte is_vararg</code> ，函数的可变参数</li><li><code>lu_byte maxstacksize</code> ，函数运行时，最大使用的栈空间</li></ul><p>数组结果</p><ul><li><code>TValue *k</code> ，常量表</li><li><code>Instruction *code</code> ，字节码</li><li><code>struct Proto **p</code> ，内部其它函数定义</li><li><code>struct LocVar *locvars</code> ，局部变量信息</li><li><code>TString **upvalues</code> ，upvalue 信息</li><li>与 len size 相关的字段</li></ul><p>对照之前对 vm 执行模型的讨论，code 和 k 就与之对应。</p><p>这里一个有意思的区别，在于 size 和 n。</p><p>上面提到的 5 个数组，都对应一个 size 字段，用于记录数组的大小。
同时，也对应一个 n 字段，用于记录当前数组已使用的大小（下一个空闲的位置）。</p><p>在分析的过程中，数组 size 值记录空间总长度，当空间不足时，会继续扩大分配。
而数组 n 值用于时刻标识下一个空闲索引，记录分析结果并自增，它的值比 size 小。</p><p>当最终分析结束时，将 n 值赋值给相应的 size 值，省略多余不用的空间，此时两者才会相同。</p><p>如此看来，n 值应该存放在 FuncState 中，但是存在例外的是 <code>lu_byte nups</code> 。</p><figure><img src=generator-fcode.png></figure><figure><img src=generator-fk.png></figure><figure><img src=generator-fp.png></figure><figure><img src=generator-fupval.png></figure><figure><img src=generator-flocvars.png></figure><p>相同的视角，来观察 FuncState。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">57
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">58
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">59
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">60
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">61
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">62
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">63
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">64
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">65
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">66
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">67
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">68
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">69
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">70
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">71
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">72
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">73
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">74
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">75
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/* state needed to generate code for a given function */</span>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> FuncState {
  Proto <span style=color:#f92672>*</span>f;  <span style=color:#75715e>/* current function header */</span>
  Table <span style=color:#f92672>*</span>h;  <span style=color:#75715e>/* table to find (and reuse) elements in `k&#39; */</span>
  <span style=color:#66d9ef>struct</span> FuncState <span style=color:#f92672>*</span>prev;  <span style=color:#75715e>/* enclosing function */</span>
  <span style=color:#66d9ef>struct</span> LexState <span style=color:#f92672>*</span>ls;  <span style=color:#75715e>/* lexical state */</span>
  <span style=color:#66d9ef>struct</span> lua_State <span style=color:#f92672>*</span>L;  <span style=color:#75715e>/* copy of the Lua state */</span>
  <span style=color:#66d9ef>struct</span> BlockCnt <span style=color:#f92672>*</span>bl;  <span style=color:#75715e>/* chain of current blocks */</span>
  <span style=color:#66d9ef>int</span> pc;  <span style=color:#75715e>/* next position to code (equivalent to `ncode&#39;) */</span>
  <span style=color:#66d9ef>int</span> lasttarget;   <span style=color:#75715e>/* `pc&#39; of last `jump target&#39; */</span>
  <span style=color:#66d9ef>int</span> jpc;  <span style=color:#75715e>/* list of pending jumps to `pc&#39; */</span>
  <span style=color:#66d9ef>int</span> freereg;  <span style=color:#75715e>/* first free register */</span>
  <span style=color:#66d9ef>int</span> nk;  <span style=color:#75715e>/* number of elements in `k&#39; */</span>
  <span style=color:#66d9ef>int</span> np;  <span style=color:#75715e>/* number of elements in `p&#39; */</span>
  <span style=color:#66d9ef>short</span> nlocvars;  <span style=color:#75715e>/* number of elements in `locvars&#39; */</span>
  lu_byte nactvar;  <span style=color:#75715e>/* number of active local variables */</span>
  upvaldesc upvalues[LUAI_MAXUPVALUES];  <span style=color:#75715e>/* upvalues */</span>
  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> actvar[LUAI_MAXVARS];  <span style=color:#75715e>/* declared-variable stack */</span>
} FuncState;</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 6</span>:
lparser.h</div><p>暂不讨论</p><ul><li><code>Proto *f</code></li><li><code>struct FuncState *prev</code></li><li><code>struct LexState *ls</code></li><li><code>struct lua_State *L</code></li></ul><p>后续讨论</p><ul><li><code>struct BlockCnt *bl</code></li><li><code>int lasttarget</code></li><li><code>int jpc</code></li><li><code>int freereg</code></li></ul><p>中间结果</p><ul><li><code>upvaldesc upvalues[LUAI_MAXUPVALUES]</code></li><li><code>unsigned short actvar[LUAI_MAXVARS]</code></li><li>其它 n 字段</li></ul><p>两个数组是定长的，即 size 是固定的， <code>f->nups</code> <code>fs->nactvar</code> 用于对应其 n 字段。</p><figure><img src=generator-fsupval.png></figure><figure><img src=generator-fsactvar.png></figure><p>在编译过程中，所得到的结果会不断的存储入上述数组及其它字段中。</p><h2 id=generate>generate
<a class=anchor href=#generate>#</a></h2><p>从某种角度看，编译过程就是规则间的同义转换过程。</p><p>代码生成，最终将符合语法规则的 lua 代码，生成为 vm 可执行的同义字节码，
这个过程是隐藏在语法分析下的艺术。</p><p>两个规则间可以进行同义转换的连接点，在于对 vm 的共识，
正因为编译器"懂得" vm，知晓字节码的格式与功能，知晓运行时的栈结构，
知晓 k 表 Gbl 表的读取方式，才能生成 vm 可执行的同义字节码。</p><p>这种共识贯穿在整个代码生成的过程中。</p><p>但是无论编译器如何了解 vm，编译时和运行时还是存在区别的。
代码生成时，只是想象存在一个假想的 vm，它在执行生成的所有结果。</p><p>所以代码生成这个过程是最为繁杂的，到 vm 真正运行时反而轻松了，只需要读指令，执行指令就可以了。</p><p>阅读代码生成相关的代码，笔者还没有精确地把握住其中的原理，只能提供几个原则给读者参考，</p><ul><li>总体是语法制导翻译的过程</li><li>使用后缀方式的生成顺序，比如 a + b 按照 a b + 的顺序来转换生成</li><li>精确模拟 vm 的运行方式，包括栈运算，Gbl 表及其它</li></ul><p>章节结束之后，读者可以多使用调试器分析示例代码，探索其中的奥妙。</p><h2 id=key-concept>key concept
<a class=anchor href=#key-concept>#</a></h2><p>在仔细探索代码生成之前，先明确几个在生成过程中的重点。</p><h3 id=variable>variable
<a class=anchor href=#variable>#</a></h3><p>从作用域来看，lua 中的变量有 3 类，分别为 <code>local upvalue global</code> ，
三者在底层的实现方式各不相同。</p><h4 id=local>local
<a class=anchor href=#local>#</a></h4><p>local 变量的活动范围（active），开始于在作用域中出现的那一刻，一直到作用域结束，
而作用域是有明显的栈特性的，新开辟作用域时入栈，离开作用域时出栈。</p><p>在一个作用域内，local 变量按照声明顺序入栈，离开作用域时全部出栈，变为 inactive 状态。</p><p>利用这个特性，lua 在编译时，在 fs 中用 actvar 和 nactvar 时刻记录着当前 active local 变量的状态。</p><p>比如如下示例代码，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> a

<span style=color:#66d9ef>do</span>
   <span style=color:#66d9ef>local</span> b
   <span style=color:#66d9ef>do</span>
      <span style=color:#66d9ef>local</span> c
   <span style=color:#66d9ef>end</span>
<span style=color:#66d9ef>end</span>

<span style=color:#66d9ef>do</span>
   <span style=color:#66d9ef>local</span> d
   <span style=color:#66d9ef>do</span>
      <span style=color:#66d9ef>local</span> e
   <span style=color:#66d9ef>end</span>
<span style=color:#66d9ef>end</span>
</code></pre></div><p>在代码分析的不同时刻， <code>fs->actvar</code> 记录的栈状态是这样的，</p><figure><img src=generator-active-local-scope.png></figure><p>上面只是粗略描述了 active local 变量的栈状态，而实际在 parser 内部，是通过两个数组来存储的。</p><figure><img src=generator-actvar-locvars.png></figure><p>数组 <code>fs->actvar</code> 的元素是 <code>unsigned short</code> 类型，只用来记录变量的索引。
索引数组 <code>f->locvars</code> 中的元素，其中元素类型为 <code>struct LocVar *</code> 。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">262
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">263
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">264
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">265
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">266
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> LocVar {
  TString <span style=color:#f92672>*</span>varname;
  <span style=color:#66d9ef>int</span> startpc;  <span style=color:#75715e>/* first point where variable is active */</span>
  <span style=color:#66d9ef>int</span> endpc;    <span style=color:#75715e>/* first point where variable is dead */</span>
} LocVar;</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 7</span>:
lobject.h</div><p>LocVar 主要记录变量的名字， <code>startpc endpc</code> 在字节码层面记录其活动范围。</p><p>宏 getlocvar 精确描述了图示过程。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define getlocvar(fs, i)	((fs)-&gt;f-&gt;locvars[(fs)-&gt;actvar[i]])</span></code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 8</span>:
lparser.c</div><h4 id=upvalue>upvalue
<a class=anchor href=#upvalue>#</a></h4><p>upvalue 在本文翻译为上值，它即非 local，又不是 global。
直观从代码上看，即引用作用域之外的变量。</p><p>lua 将 function 作为基础类型之一，可以作为普通变量，参数，返回值，赋值，而四处流转。
又因为 local 变量的作用域限定于词法，这便是 upvalue 机制发挥作用的地方。</p><p>如下示例代码，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>outer</span>()
   <span style=color:#66d9ef>local</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>

   <span style=color:#66d9ef>local</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>inner</span>()
      a <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
      print(a)
   <span style=color:#66d9ef>end</span>

   inner()

   <span style=color:#66d9ef>return</span> inner
<span style=color:#66d9ef>end</span>

<span style=color:#66d9ef>local</span> f <span style=color:#f92672>=</span> outer()

f()
f()
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>1
2
3
</code></pre></div><p>内部第 1 次调用 inner() 时，输出 1 。
当调用 outer()，将 inner 赋值与 f，调用两次 f() 得到 2 3 。</p><p>第 1 次调用 inner() 时，依然在 a 的作用域内，输出 1 是符合直觉的。</p><p>问题在于调用 f() 时，因为 a 只作用在 outer 的作用域，而 f 在 outer 作用域外部，
已经离开了 a 的作用域，这种情况下为何还可以访问 a ？</p><p>这便是闭包机制的由来，a 对于 inner 而言是 upvalue 类型。
这也是 lua 中为何 function 不是 function 而是 closure 的原因，function 及 upvalue 组成了 closure，
所有 func 在运行时都封装为 closure 来运行，其中重要的原因就在于单独分配 upvalue 空间并管理。</p><p>详细的说，第 1 次调用 inner() 时，local a 依然存活，称 upvalue a 为 open 状态。
当离开 outer() 作用域，upvalue a 为 close 状态。</p><h4 id=global>global
<a class=anchor href=#global>#</a></h4><p>如果依然说，global 变量是除 local 变量和 upvalue 变量的变量，读者肯定不信服。</p><p>之所以存在 upvalue 和 global，隐含的一点是，在 lua 中外层变量对于内层是可见的，
既然是可见的，对于外层变量引用自然有一个查找的过程，变量类型正是在查找的过程中确定的。</p><ul><li>在当前作用域中可以找到的，为 local 类型</li><li>在当前作用域之外的作用域可以找到的，为 upvalue 类型</li><li>所有作用域都无法找到的，为 global 类型</li></ul><p>按照这个逻辑，顶层的 chunk 是没有 upvalue 的，在当前作用域中查找不到的变量，
只能是 global 类型。</p><p>setfenv 影响的就是函数的 global 环境，
设定不同的 global 表，可以影响内部对 global 的引用，
实现不同的运行效果，类似于封装成一个小沙盒，</p><p>比如如下代码，变量 a 对 outer inner 都是全局变量，所以全部修改都影响到 global a 的值。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>outer</span>()
  a <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>

  <span style=color:#66d9ef>local</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>inner</span>()
    a <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
    <span style=color:#66d9ef>return</span> a
  <span style=color:#66d9ef>end</span>

  <span style=color:#66d9ef>return</span> inner
<span style=color:#66d9ef>end</span>

<span style=color:#66d9ef>local</span> f <span style=color:#f92672>=</span> outer()

print(f(), a)
print(f(), a)
print(f(), a)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>11	11
12	12
13	13
</code></pre></div><h3 id=register>register
<a class=anchor href=#register>#</a></h3><p>寄存器的主要作用是，存取 local 变量和存取中间结果。</p><p>寄存器在编译时是一个抽象的概念，没有具体的分配空间，编译器只知晓存在这块区域，
并且按照自己的需要来使用和调试。</p><p>而在实际运行时，寄存器存储在 vm 的栈中。</p><h2 id=statement>statement
<a class=anchor href=#statement>#</a></h2><p>本节开始从实例具体分析代码生成的过程，和实例一起来探求其中的生成模式。</p><p>因为语法元素的递归性，其中的组合是无限的，所以本节只挑选讲解部分重要的“原子性”的部分，
至于各种组合的变数读者可自由探索。</p><h3 id=tool>tool
<a class=anchor href=#tool>#</a></h3><p>在开始以实例为基础的探索之前，先详细介绍相应工具的使用。</p><p>以交互式启动 chunkspy，用于临时检验一些想法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>$ make spy
</code></pre></div><p>分析特定 lua 文件，输出相应的编译结果。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>$ make -s inspect source=lua_file_path
</code></pre></div><p>比如分析如下代码，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</code></pre></div><p>会输出如下结果，</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  &#34;a&#34;  ; 0
.const  1  ; 0
[1] loadk      0   0        ; 1
[2] return     0   1
; end of function</code></pre></td></tr></table></div></div><p>逐行来看，</p><p>line 1</p><p>level 1 指的是第一层级，即 chunk；
function [0] 表明是当前层级的第 1 个函数（以 0 开始索引）</p><p>line 2</p><p>函数有 0 个 upvalue，0 个参数，按 <code>0b010</code> 模式接收可变参数，需要分配栈容量 2。</p><p>line 3</p><p>意义和 line 2 相同，line 2 是 line 3 的注释</p><p>line 4 5</p><p>.local 列出所有局部变量的名称及索引，即 f->locvars 的内容
.const 列出 k 表的内容及索引</p><p>line 6 7</p><p>详细打印 f->code 指令，最终一行总是默认生成一条 return 指令</p><p>line 8</p><p>注释，表明 function 结束</p><p>读者结合 opcode 章节对各个指令功能的理解，不难理解 lua 代码和字节码的同义关系。</p><h3 id=local>local
<a class=anchor href=#local>#</a></h3><p>先来观察 local 语句。</p><p>语法描述如下，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bnf data-lang=bnf>stat      <span style=color:#f92672>::=</span> localstat
localstat <span style=color:#f92672>::=</span> LOCAL NAME {`,&#39; NAME} [`=&#39; explist]
localstat <span style=color:#f92672>::=</span> LOCAL FUNCTION NAME body
</code></pre></div><p>localstat 可用于定义局部变量和局部函数。</p><p>函数部分到后面小节再讨论，对于局部变量，根据是否赋值可分为两种情况。</p><h4 id=no-assignment>no assignment
<a class=anchor href=#no-assignment>#</a></h4><p>如下简单的代码示例，定义局部变量，无赋值，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> a, b, c
</code></pre></div><p>分析得到如下结果，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 3 stacks
.function  0 0 2 3
.local  &#34;a&#34;  ; 0
.local  &#34;b&#34;  ; 1
.local  &#34;c&#34;  ; 2
[1] return     0   1
; end of function
</code></pre></div><p>示例代码只是单纯进行了局部变量的声明，最终没有生成任何字节码。</p><p>分析的过程，就是递归向下的函数过程， <code>chunk -> stat -> localstat</code> 。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1179
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1180
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1181
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1182
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1183
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1184
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1185
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1186
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1187
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1188
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1189
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1190
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1191
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1192
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1193
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1194
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1195
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>localstat</span> (LexState <span style=color:#f92672>*</span>ls) {
  <span style=color:#75715e>/* stat -&gt; LOCAL NAME {`,&#39; NAME} [`=&#39; explist1] */</span>
  <span style=color:#66d9ef>int</span> nvars <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>int</span> nexps;
  expdesc e;
  <span style=color:#66d9ef>do</span> {
    new_localvar(ls, str_checkname(ls), nvars<span style=color:#f92672>++</span>);
  } <span style=color:#66d9ef>while</span> (testnext(ls, <span style=color:#e6db74>&#39;,&#39;</span>));
  <span style=color:#66d9ef>if</span> (testnext(ls, <span style=color:#e6db74>&#39;=&#39;</span>))
    nexps <span style=color:#f92672>=</span> explist1(ls, <span style=color:#f92672>&amp;</span>e);
  <span style=color:#66d9ef>else</span> {
    e.k <span style=color:#f92672>=</span> VVOID;
    nexps <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  }
  adjust_assign(ls, nvars, nexps, <span style=color:#f92672>&amp;</span>e);
  adjustlocalvars(ls, nvars);
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 9</span>:
lparser.c</div><p>关键在于 new_localvar 函数，在循环中读入 a b c，并进行变量分析。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">160
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">161
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">162
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">163
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">164
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>new_localvar</span> (LexState <span style=color:#f92672>*</span>ls, TString <span style=color:#f92672>*</span>name, <span style=color:#66d9ef>int</span> n) {
  FuncState <span style=color:#f92672>*</span>fs <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>fs;
  luaY_checklimit(fs, fs<span style=color:#f92672>-&gt;</span>nactvar<span style=color:#f92672>+</span>n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, LUAI_MAXVARS, <span style=color:#e6db74>&#34;local variables&#34;</span>);
  fs<span style=color:#f92672>-&gt;</span>actvar[fs<span style=color:#f92672>-&gt;</span>nactvar<span style=color:#f92672>+</span>n] <span style=color:#f92672>=</span> cast(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span>, registerlocalvar(ls, name));
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 10</span>:
lparser.c</div><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">143
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">144
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">145
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">146
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">147
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">148
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">149
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">150
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">151
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">152
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">153
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>registerlocalvar</span> (LexState <span style=color:#f92672>*</span>ls, TString <span style=color:#f92672>*</span>varname) {
  FuncState <span style=color:#f92672>*</span>fs <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>fs;
  Proto <span style=color:#f92672>*</span>f <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>f;
  <span style=color:#66d9ef>int</span> oldsize <span style=color:#f92672>=</span> f<span style=color:#f92672>-&gt;</span>sizelocvars;
  luaM_growvector(ls<span style=color:#f92672>-&gt;</span>L, f<span style=color:#f92672>-&gt;</span>locvars, fs<span style=color:#f92672>-&gt;</span>nlocvars, f<span style=color:#f92672>-&gt;</span>sizelocvars,
		  LocVar, SHRT_MAX, <span style=color:#e6db74>&#34;too many local variables&#34;</span>);
  <span style=color:#66d9ef>while</span> (oldsize <span style=color:#f92672>&lt;</span> f<span style=color:#f92672>-&gt;</span>sizelocvars) f<span style=color:#f92672>-&gt;</span>locvars[oldsize<span style=color:#f92672>++</span>].varname <span style=color:#f92672>=</span> NULL;
  f<span style=color:#f92672>-&gt;</span>locvars[fs<span style=color:#f92672>-&gt;</span>nlocvars].varname <span style=color:#f92672>=</span> varname;
  luaC_objbarrier(ls<span style=color:#f92672>-&gt;</span>L, f, varname);
  <span style=color:#66d9ef>return</span> fs<span style=color:#f92672>-&gt;</span>nlocvars<span style=color:#f92672>++</span>;
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 11</span>:
lparser.c</div><p>其中根据变量出现的顺序，依次使用 registerlocalvar 得到变量索引，再记录到 <code>fs->actvar</code> 中。</p><p>这就是前面讨论过的，局部变量的存储方式，使用 <code>fs->actvar</code> 记录索引， <code>f->locvars</code> 记录变量名称。</p><figure><img src=generator-local-no-assign.png></figure><p>new_locvar 完成的就是这个过程。</p><p>这也对应了 chunkspy 分析结果中的 .local 部分。</p><h4 id=with-assignment>with assignment
<a class=anchor href=#with-assignment>#</a></h4><p>再来看 local 变量赋值的情况。</p><p>分析示例代码，得到如下结果，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> a, b, c, d, e <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>, <span style=color:#e6db74>&#34;second&#34;</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>false</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 5 stacks
.function  0 0 2 5
.local  &#34;a&#34;  ; 0
.local  &#34;b&#34;  ; 1
.local  &#34;c&#34;  ; 2
.local  &#34;d&#34;  ; 3
.local  &#34;e&#34;  ; 4
.const  10  ; 0
.const  &#34;second&#34;  ; 1
[1] loadk      0   0        ; 10
[2] loadk      1   1        ; &#34;second&#34;
[3] loadnil    2   2
[4] loadbool   3   1   0    ; true
[5] loadbool   4   0   0    ; false
[6] return     0   1
; end of function
</code></pre></div><p>除了 .local 条目变多了，也增加了 .const 部分，意味着 k 表多出了 2 项记录。</p><p>依旧从 localstat 来分析，</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1179
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1180
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1181
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1182
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1183
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1184
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1185
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1186
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1187
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1188
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1189
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1190
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1191
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1192
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1193
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1194
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1195
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>localstat</span> (LexState <span style=color:#f92672>*</span>ls) {
  <span style=color:#75715e>/* stat -&gt; LOCAL NAME {`,&#39; NAME} [`=&#39; explist1] */</span>
  <span style=color:#66d9ef>int</span> nvars <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>int</span> nexps;
  expdesc e;
  <span style=color:#66d9ef>do</span> {
    new_localvar(ls, str_checkname(ls), nvars<span style=color:#f92672>++</span>);
  } <span style=color:#66d9ef>while</span> (testnext(ls, <span style=color:#e6db74>&#39;,&#39;</span>));
  <span style=color:#66d9ef>if</span> (testnext(ls, <span style=color:#e6db74>&#39;=&#39;</span>))
    nexps <span style=color:#f92672>=</span> explist1(ls, <span style=color:#f92672>&amp;</span>e);
  <span style=color:#66d9ef>else</span> {
    e.k <span style=color:#f92672>=</span> VVOID;
    nexps <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  }
  adjust_assign(ls, nvars, nexps, <span style=color:#f92672>&amp;</span>e);
  adjustlocalvars(ls, nvars);
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 12</span>:
lparser.c</div><p>在记录变量信息之后，遇到 <code>=</code> ，开始分析 <code>=</code> 后的 表达式列表 ，作为变量的赋值内容。</p><p>后面的表达式都是简单表达式，最终会调用 simpleexp 进行解析。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bnf data-lang=bnf>explist      <span style=color:#f92672>::=</span> expr {`,&#39; expr}
expr         <span style=color:#f92672>::=</span> subexpr
subexpr      <span style=color:#f92672>::=</span> (simpleexp | unop subexpr) {binop subexpr}

simpleexp    <span style=color:#f92672>::=</span> NUMBER | STRING | NIL | TRUE | FALSE | DOTS |
		 constructor | FUNCTION body | primaryexp
</code></pre></div><p>下面有趣的地方来了，字节码和 k 表中的元素是何时生成的？
这就和代码生成的方式紧密相关了。</p><p>parser 模块中代码生成的强大在于，它是流式生成的。
意思即一边读入 token，分析状态，就直接生成代码！</p><p>从代码具体来看，</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">596
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">597
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">598
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">599
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">600
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">601
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">602
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">603
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">604
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">605
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">606
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>explist1</span> (LexState <span style=color:#f92672>*</span>ls, expdesc <span style=color:#f92672>*</span>v) {
  <span style=color:#75715e>/* explist1 -&gt; expr { `,&#39; expr } */</span>
  <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>/* at least one expression */</span>
  expr(ls, v);
  <span style=color:#66d9ef>while</span> (testnext(ls, <span style=color:#e6db74>&#39;,&#39;</span>)) {
    luaK_exp2nextreg(ls<span style=color:#f92672>-&gt;</span>fs, v);
    expr(ls, v);
    n<span style=color:#f92672>++</span>;
  }
  <span style=color:#66d9ef>return</span> n;
}</code></pre></td></tr></table></div></div><p>在第 1 次分析表达式 时，读入并分析了 10，并在 第 2 次分析表达式 &ldquo;second&rdquo; 之前，已经生成代码并更新了 k 表。</p><p>先来看 expr()，由于分析的是简单表达式，最终会调用 simpleexp 进行分析，</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">727
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">728
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">729
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">730
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">731
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">732
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">733
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">734
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">735
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">736
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">737
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">738
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">739
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">740
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">741
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">742
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">743
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">744
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">745
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">746
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">747
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">748
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">749
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">750
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">751
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">752
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">753
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">754
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">755
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">756
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">757
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">758
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">759
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">760
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">761
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">762
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">763
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">764
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">765
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">766
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">767
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">768
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">769
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">770
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">771
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">772
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">773
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">774
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">775
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>simpleexp</span> (LexState <span style=color:#f92672>*</span>ls, expdesc <span style=color:#f92672>*</span>v) {
  <span style=color:#75715e>/* simpleexp -&gt; NUMBER | STRING | NIL | true | false | ... |
</span><span style=color:#75715e>		  constructor | FUNCTION body | primaryexp */</span>
  <span style=color:#66d9ef>switch</span> (ls<span style=color:#f92672>-&gt;</span>t.token) {
    <span style=color:#66d9ef>case</span> TK_NUMBER: {
      init_exp(v, VKNUM, <span style=color:#ae81ff>0</span>);
      v<span style=color:#f92672>-&gt;</span>u.nval <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>t.seminfo.r;
      <span style=color:#66d9ef>break</span>;
    }
    <span style=color:#66d9ef>case</span> TK_STRING: {
      codestring(ls, v, ls<span style=color:#f92672>-&gt;</span>t.seminfo.ts);
      <span style=color:#66d9ef>break</span>;
    }
    <span style=color:#66d9ef>case</span> TK_NIL: {
      init_exp(v, VNIL, <span style=color:#ae81ff>0</span>);
      <span style=color:#66d9ef>break</span>;
    }
    <span style=color:#66d9ef>case</span> TK_TRUE: {
      init_exp(v, VTRUE, <span style=color:#ae81ff>0</span>);
      <span style=color:#66d9ef>break</span>;
    }
    <span style=color:#66d9ef>case</span> TK_FALSE: {
      init_exp(v, VFALSE, <span style=color:#ae81ff>0</span>);
      <span style=color:#66d9ef>break</span>;
    }
    <span style=color:#66d9ef>case</span> TK_DOTS: {  <span style=color:#75715e>/* vararg */</span>
      FuncState <span style=color:#f92672>*</span>fs <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>fs;
      check_condition(ls, fs<span style=color:#f92672>-&gt;</span>f<span style=color:#f92672>-&gt;</span>is_vararg,
		      <span style=color:#e6db74>&#34;cannot use &#34;</span> LUA_QL(<span style=color:#e6db74>&#34;...&#34;</span>) <span style=color:#e6db74>&#34; outside a vararg function&#34;</span>);
      fs<span style=color:#f92672>-&gt;</span>f<span style=color:#f92672>-&gt;</span>is_vararg <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>VARARG_NEEDSARG;  <span style=color:#75715e>/* don&#39;t need &#39;arg&#39; */</span>
      init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>));
      <span style=color:#66d9ef>break</span>;
    }
    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;{&#39;</span><span style=color:#f92672>:</span> {  <span style=color:#75715e>/* constructor */</span>
      constructor(ls, v);
      <span style=color:#66d9ef>return</span>;
    }
    <span style=color:#66d9ef>case</span> TK_FUNCTION: {
      luaX_next(ls);
      body(ls, v, <span style=color:#ae81ff>0</span>, ls<span style=color:#f92672>-&gt;</span>linenumber);
      <span style=color:#66d9ef>return</span>;
    }
    <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span> {
      primaryexp(ls, v);
      <span style=color:#66d9ef>return</span>;
    }
  }
  luaX_next(ls);
}</code></pre></td></tr></table></div></div><p>第 1 次分析 10 时，token 类型是 <code>TK_NUMBER</code> ，直接填充 expdesc 即可，
然后调用 luaK_exp2nextreg 生成代码。</p><p>luaK_exp2nextreg 是一个综合过程，由更基础的几个函数组成。</p><p>深入分析之前，先来补充之前 FuncState 未描述的一个字段，freereg。</p><p>字节码被 vm 运行时，vm 维持一个栈，来存放寄存器和中间结果。
编译器只知晓这个栈的存在，但是在编译时，这个栈并没有真实存在，
只能凭借想象去操作它。</p><p>freereg 就是用来记录栈顶的变量。</p><p>当存储新的寄存器值时，freereg 就会自增，为寄存器开出空间；</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">209
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">210
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">211
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">212
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>luaK_reserveregs</span> (FuncState <span style=color:#f92672>*</span>fs, <span style=color:#66d9ef>int</span> n) {
  luaK_checkstack(fs, n);
  fs<span style=color:#f92672>-&gt;</span>freereg <span style=color:#f92672>+=</span> n;
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 13</span>:
lcode.c</div><p>相应的，如果寄存器不再使用，freereg 会自减，回收相应的空间。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">215
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">216
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">217
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">218
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">219
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">220
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>freereg</span> (FuncState <span style=color:#f92672>*</span>fs, <span style=color:#66d9ef>int</span> reg) {
  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ISK(reg) <span style=color:#f92672>&amp;&amp;</span> reg <span style=color:#f92672>&gt;=</span> fs<span style=color:#f92672>-&gt;</span>nactvar) {
    fs<span style=color:#f92672>-&gt;</span>freereg<span style=color:#f92672>--</span>;
    lua_assert(reg <span style=color:#f92672>==</span> fs<span style=color:#f92672>-&gt;</span>freereg);
  }
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 14</span>:
lcode.c</div><p>从中可以看出，freereg 将栈分为两部分，在栈底为 local 变量保留空间（reg >= fs->nactvar），
上层用于计算中间结果。</p><figure><img src=generator-freereg-stack.png></figure><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">414
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">415
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">416
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">417
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">418
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">419
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>luaK_exp2nextreg</span> (FuncState <span style=color:#f92672>*</span>fs, expdesc <span style=color:#f92672>*</span>e) {
  luaK_dischargevars(fs, e);
  freeexp(fs, e);
  luaK_reserveregs(fs, <span style=color:#ae81ff>1</span>);
  exp2reg(fs, e, fs<span style=color:#f92672>-&gt;</span>freereg <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 15</span>:
lcode.c</div><p>在 luaK_exp2nextreg 中，先找出下一个可用的栈/寄存器空间，然后将表达式的值解析到寄存器中，
即生成字节码。</p><p>最终在 discharge2reg 函数生成相应指令 loadk。</p><p>这里出现了第二个重点，对 k 表的操作。</p><p>因为其类型为数字，所以调用的是 luaK_numberK。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">229
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">230
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">231
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">232
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">233
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">234
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">235
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">236
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">237
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">238
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">239
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">240
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">241
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">242
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">243
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">244
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">245
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">246
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">247
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">248
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">249
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">250
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">251
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">252
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">253
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">254
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">255
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">256
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">257
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">258
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">259
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">260
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">261
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">262
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">263
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">264
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">265
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">266
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">267
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">268
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">269
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">270
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">271
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">272
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">273
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">274
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">275
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">276
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">277
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>addk</span> (FuncState <span style=color:#f92672>*</span>fs, TValue <span style=color:#f92672>*</span>k, TValue <span style=color:#f92672>*</span>v) {
  lua_State <span style=color:#f92672>*</span>L <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>L;
  TValue <span style=color:#f92672>*</span>idx <span style=color:#f92672>=</span> luaH_set(L, fs<span style=color:#f92672>-&gt;</span>h, k);
  Proto <span style=color:#f92672>*</span>f <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>f;
  <span style=color:#66d9ef>int</span> oldsize <span style=color:#f92672>=</span> f<span style=color:#f92672>-&gt;</span>sizek;
  <span style=color:#66d9ef>if</span> (ttisnumber(idx)) {
    lua_assert(luaO_rawequalObj(<span style=color:#f92672>&amp;</span>fs<span style=color:#f92672>-&gt;</span>f<span style=color:#f92672>-&gt;</span>k[cast_int(nvalue(idx))], v));
    <span style=color:#66d9ef>return</span> cast_int(nvalue(idx));
  }
  <span style=color:#66d9ef>else</span> {  <span style=color:#75715e>/* constant not found; create a new entry */</span>
    setnvalue(idx, cast_num(fs<span style=color:#f92672>-&gt;</span>nk));
    luaM_growvector(L, f<span style=color:#f92672>-&gt;</span>k, fs<span style=color:#f92672>-&gt;</span>nk, f<span style=color:#f92672>-&gt;</span>sizek, TValue,
		    MAXARG_Bx, <span style=color:#e6db74>&#34;constant table overflow&#34;</span>);
    <span style=color:#66d9ef>while</span> (oldsize <span style=color:#f92672>&lt;</span> f<span style=color:#f92672>-&gt;</span>sizek) setnilvalue(<span style=color:#f92672>&amp;</span>f<span style=color:#f92672>-&gt;</span>k[oldsize<span style=color:#f92672>++</span>]);
    setobj(L, <span style=color:#f92672>&amp;</span>f<span style=color:#f92672>-&gt;</span>k[fs<span style=color:#f92672>-&gt;</span>nk], v);
    luaC_barrier(L, f, v);
    <span style=color:#66d9ef>return</span> fs<span style=color:#f92672>-&gt;</span>nk<span style=color:#f92672>++</span>;
  }
}


<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>luaK_stringK</span> (FuncState <span style=color:#f92672>*</span>fs, TString <span style=color:#f92672>*</span>s) {
  TValue o;
  setsvalue(fs<span style=color:#f92672>-&gt;</span>L, <span style=color:#f92672>&amp;</span>o, s);
  <span style=color:#66d9ef>return</span> addk(fs, <span style=color:#f92672>&amp;</span>o, <span style=color:#f92672>&amp;</span>o);
}


<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>luaK_numberK</span> (FuncState <span style=color:#f92672>*</span>fs, lua_Number r) {
  TValue o;
  setnvalue(<span style=color:#f92672>&amp;</span>o, r);
  <span style=color:#66d9ef>return</span> addk(fs, <span style=color:#f92672>&amp;</span>o, <span style=color:#f92672>&amp;</span>o);
}


<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>boolK</span> (FuncState <span style=color:#f92672>*</span>fs, <span style=color:#66d9ef>int</span> b) {
  TValue o;
  setbvalue(<span style=color:#f92672>&amp;</span>o, b);
  <span style=color:#66d9ef>return</span> addk(fs, <span style=color:#f92672>&amp;</span>o, <span style=color:#f92672>&amp;</span>o);
}


<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>nilK</span> (FuncState <span style=color:#f92672>*</span>fs) {
  TValue k, v;
  setnilvalue(<span style=color:#f92672>&amp;</span>v);
  <span style=color:#75715e>/* cannot use nil as key; instead use table itself to represent nil */</span>
  sethvalue(fs<span style=color:#f92672>-&gt;</span>L, <span style=color:#f92672>&amp;</span>k, fs<span style=color:#f92672>-&gt;</span>h);
  <span style=color:#66d9ef>return</span> addk(fs, <span style=color:#f92672>&amp;</span>k, <span style=color:#f92672>&amp;</span>v);
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 16</span>:
lcode.c</div><p>所有操作 k 表的方法，最终都使用 addk 操作，其作用也很简单，
在 k 表中搜索，如果存在，则直接返回相应索引，其中使用 table fs->h 做 k 表元素的反向索引，加快搜索过程；
若不存在，则自增，并返回相应的索引。</p><figure><img src=generator-numberk-10.png></figure><p>将数字 10 存储入 k 表之后，生成 loadk 指令，将 freereg 和 k 索引作为其操作数。</p><p>至此，parser 只读入了 token 10，便已经完成了操作 k 表，记录常数，并生成对应的指令，令人惊奇。</p><p>对于第 2 个表达式 &ldquo;second&rdquo;，在 simpleexp 时，提前调用 codestring 加入了 k 表，
将其作为 VK 类型来对待。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">133
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">134
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">135
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>codestring</span> (LexState <span style=color:#f92672>*</span>ls, expdesc <span style=color:#f92672>*</span>e, TString <span style=color:#f92672>*</span>s) {
  init_exp(e, VK, luaK_stringK(ls<span style=color:#f92672>-&gt;</span>fs, s));
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 17</span>:
lparser.c</div><figure><img src=generator-stringk-second.png></figure><p>同样的生成 loadk 指令。</p><p>回到 localstat()，前面对变量和表达式进行解析之后，记录了 <code>=</code> 两边的数量 nvars nexps，
<code>adjust_assign()</code> 进行左右数量的调整，多余的 var 空间置为 nil，多余的 exp 则省略。</p><p>最终调用 <code>adjustlocalvars()</code> 调整 fs->nactvar 的值。</p><h3 id=expdesc>expdesc
<a class=anchor href=#expdesc>#</a></h3><p>从 localstat 的示例中，已经看到代码生成的逻辑是别具一格的。</p><p>结合递归下降，语法制导，后缀顺序，vm opcode 语义，得以以线性顺序生成字节码。</p><p>其中 expdesc 的作用是非常重要的，将一些属性附加到文法符号上，辅助代码生成过程。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e>** Expression descriptor
</span><span style=color:#75715e>*/</span>

<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> {
  VVOID,	<span style=color:#75715e>/* no value */</span>
  VNIL,
  VTRUE,
  VFALSE,
  VK,		<span style=color:#75715e>/* info = index of constant in `k&#39; */</span>
  VKNUM,	<span style=color:#75715e>/* nval = numerical value */</span>
  VLOCAL,	<span style=color:#75715e>/* info = local register */</span>
  VUPVAL,       <span style=color:#75715e>/* info = index of upvalue in `upvalues&#39; */</span>
  VGLOBAL,	<span style=color:#75715e>/* info = index of table; aux = index of global name in `k&#39; */</span>
  VINDEXED,	<span style=color:#75715e>/* info = table register; aux = index register (or `k&#39;) */</span>
  VJMP,		<span style=color:#75715e>/* info = instruction pc */</span>
  VRELOCABLE,	<span style=color:#75715e>/* info = instruction pc */</span>
  VNONRELOC,	<span style=color:#75715e>/* info = result register */</span>
  VCALL,	<span style=color:#75715e>/* info = instruction pc */</span>
  VVARARG	<span style=color:#75715e>/* info = instruction pc */</span>
} expkind;

<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> expdesc {
  expkind k;
  <span style=color:#66d9ef>union</span> {
    <span style=color:#66d9ef>struct</span> { <span style=color:#66d9ef>int</span> info, aux; } s;
    lua_Number nval;
  } u;
  <span style=color:#66d9ef>int</span> t;  <span style=color:#75715e>/* patch list of `exit when true&#39; */</span>
  <span style=color:#66d9ef>int</span> f;  <span style=color:#75715e>/* patch list of `exit when false&#39; */</span>
} expdesc;
</code></pre></div><div class=src-block-caption><span class=src-block-number>Code Snippet 18</span>:
lparser.h</div><p>expdesc 用于记录 exp 表达式的相关信息。</p><p>和 token 类型类似，expdesc 内部有字段记录类型，其它字段记录附加信息。</p><p>所有类型用 enum expkind 表示，相应类型后的注释描述了对应其它字段需要记录的信息。</p><p>其中重点的函数是 discharge2reg 和 dischargevars，用于解析相应的 expdesc，生成代码并更新状态。</p><table><thead><tr><th>expkind</th><th>u</th><th>discharge</th></tr></thead><tbody><tr><td>VVOID</td><td></td><td></td></tr><tr><td>VNIL</td><td></td><td>生成指令 loadnil，重置为 VNONRELOC</td></tr><tr><td>VTRUE</td><td></td><td>生成指令 loadbool，重置为 VNONRELOC</td></tr><tr><td>VFALSE</td><td></td><td>生成指令 loadbool，重置为 VNONRELOC</td></tr><tr><td>VK</td><td>info 记录 k 表索引</td><td>生成指令 loadk，重置为 VNONRELOC</td></tr><tr><td>VKNUM</td><td>nval 记录数值</td><td>生成指令 loadk，重置为 VNONRELOC</td></tr><tr><td>VLOCAL</td><td>info 记录寄存器索引</td><td>重置为 VNONRELOC</td></tr><tr><td>VUPVAL</td><td>info 记录 upvalues 数组中的索引</td><td>生成指令 GETUPVAL, 重置为 VRELOCABLE，info 记录指令索引</td></tr><tr><td>VGLOBAL</td><td>info 全局表的索引，aux 全局名称的 k 表索引</td><td>生成指令 GETGLOBAL, 重置为 VRELOCABLE，info 记录指令索引</td></tr><tr><td>VINDEXED</td><td>info table 所在寄存器的索引，aux 索引值的 RK 值</td><td>生成指令 GETTABLE, 重置为 VRELOCABLE，info 记录指令索引</td></tr><tr><td>VJMP</td><td>info 当前指令索引</td><td></td></tr><tr><td>VRELOCABLE</td><td>info 当前指令索引</td><td>定位到指令位置，修改 A 参数为 reg</td></tr><tr><td>VNONRELOC</td><td>info 最终解析得到的寄存器位置</td><td>如果当前寄存器位置与目标位置不同，则生成 move 指令；相同则什么都不做</td></tr><tr><td>VCALL</td><td>info 当前指令索引</td><td>重置为 VNONRELOC，info 记录指令的 A 参数</td></tr><tr><td>VVARARG</td><td>info 当前指令索引</td><td>重置为 VRELOCABLE</td></tr></tbody></table><p>具体如此设计的原因及作用，还需要读者在不同情况下再尝试领会。</p><h3 id=assign>assign
<a class=anchor href=#assign>#</a></h3><p>本节来探讨赋值语句</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bnf data-lang=bnf>stat         <span style=color:#f92672>::=</span> exprstat
exprstat     <span style=color:#f92672>::=</span> assignstat

assignstat   <span style=color:#f92672>::=</span> (prefixexp | primaryexp (`.&#39; NAME | `[&#39; expr `]&#39;)) assignment
assignment   <span style=color:#f92672>::=</span> `,&#39; assignstat | `=&#39; explist

primaryexp   <span style=color:#f92672>::=</span> prefixexp {`.&#39; NAME | `[&#39; expr `]&#39; | `:&#39; NAME funcargs | funcargs}
prefixexp    <span style=color:#f92672>::=</span> NAME | `(&#39; expr `)&#39;
</code></pre></div><p>赋值语句根据变量的类型不同，分为 global upvalue local indexed 几种情况，
对应 expdesc 中的 VGLOBAL VUPVAL VLOCAL VINDEXED。</p><h4 id=global>global
<a class=anchor href=#global>#</a></h4><p>先来看 global 的赋值情况。</p><p>分析如下代码，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua>a, b, c <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>30</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 3 stacks
.function  0 0 2 3
.const  &#34;a&#34;  ; 0
.const  &#34;b&#34;  ; 1
.const  &#34;c&#34;  ; 2
.const  10  ; 3
.const  20  ; 4
.const  30  ; 5
[1] loadk      0   3        ; 10
[2] loadk      1   4        ; 20
[3] loadk      2   5        ; 30
[4] setglobal  2   2        ; c
[5] setglobal  1   1        ; b
[6] setglobal  0   0        ; a
[7] return     0   1
; end of function
</code></pre></div><p>从 chunk 递归向下，最终到达 assignment 函数。</p><p>从 ebnf 描述中可以看出，assignment 是一个递归的过程。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">931
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">932
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">933
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">934
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">935
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">936
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">937
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">938
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">939
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">940
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">941
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">942
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">943
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">944
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">945
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">946
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">947
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">948
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">949
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">950
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">951
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">952
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">953
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">954
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">955
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">956
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">957
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">958
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">959
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">960
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">961
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">962
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>assignment</span> (LexState <span style=color:#f92672>*</span>ls, <span style=color:#66d9ef>struct</span> LHS_assign <span style=color:#f92672>*</span>lh, <span style=color:#66d9ef>int</span> nvars) {
  expdesc e;
  check_condition(ls, VLOCAL <span style=color:#f92672>&lt;=</span> lh<span style=color:#f92672>-&gt;</span>v.k <span style=color:#f92672>&amp;&amp;</span> lh<span style=color:#f92672>-&gt;</span>v.k <span style=color:#f92672>&lt;=</span> VINDEXED,
		      <span style=color:#e6db74>&#34;syntax error&#34;</span>);
  <span style=color:#66d9ef>if</span> (testnext(ls, <span style=color:#e6db74>&#39;,&#39;</span>)) {  <span style=color:#75715e>/* assignment -&gt; `,&#39; primaryexp assignment */</span>
    <span style=color:#66d9ef>struct</span> LHS_assign nv;
    nv.prev <span style=color:#f92672>=</span> lh;
    primaryexp(ls, <span style=color:#f92672>&amp;</span>nv.v);
    <span style=color:#66d9ef>if</span> (nv.v.k <span style=color:#f92672>==</span> VLOCAL)
      check_conflict(ls, lh, <span style=color:#f92672>&amp;</span>nv.v);
    luaY_checklimit(ls<span style=color:#f92672>-&gt;</span>fs, nvars, LUAI_MAXCCALLS <span style=color:#f92672>-</span> ls<span style=color:#f92672>-&gt;</span>L<span style=color:#f92672>-&gt;</span>nCcalls,
		    <span style=color:#e6db74>&#34;variables in assignment&#34;</span>);
    assignment(ls, <span style=color:#f92672>&amp;</span>nv, nvars<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>);
  }
  <span style=color:#66d9ef>else</span> {  <span style=color:#75715e>/* assignment -&gt; `=&#39; explist1 */</span>
    <span style=color:#66d9ef>int</span> nexps;
    checknext(ls, <span style=color:#e6db74>&#39;=&#39;</span>);
    nexps <span style=color:#f92672>=</span> explist1(ls, <span style=color:#f92672>&amp;</span>e);
    <span style=color:#66d9ef>if</span> (nexps <span style=color:#f92672>!=</span> nvars) {
      adjust_assign(ls, nvars, nexps, <span style=color:#f92672>&amp;</span>e);
      <span style=color:#66d9ef>if</span> (nexps <span style=color:#f92672>&gt;</span> nvars)
	ls<span style=color:#f92672>-&gt;</span>fs<span style=color:#f92672>-&gt;</span>freereg <span style=color:#f92672>-=</span> nexps <span style=color:#f92672>-</span> nvars;  <span style=color:#75715e>/* remove extra values */</span>
    }
    <span style=color:#66d9ef>else</span> {
      luaK_setoneret(ls<span style=color:#f92672>-&gt;</span>fs, <span style=color:#f92672>&amp;</span>e);  <span style=color:#75715e>/* close last expression */</span>
      luaK_storevar(ls<span style=color:#f92672>-&gt;</span>fs, <span style=color:#f92672>&amp;</span>lh<span style=color:#f92672>-&gt;</span>v, <span style=color:#f92672>&amp;</span>e);
      <span style=color:#66d9ef>return</span>;  <span style=color:#75715e>/* avoid default */</span>
    }
  }
  init_exp(<span style=color:#f92672>&amp;</span>e, VNONRELOC, ls<span style=color:#f92672>-&gt;</span>fs<span style=color:#f92672>-&gt;</span>freereg<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);  <span style=color:#75715e>/* default assignment */</span>
  luaK_storevar(ls<span style=color:#f92672>-&gt;</span>fs, <span style=color:#f92672>&amp;</span>lh<span style=color:#f92672>-&gt;</span>v, <span style=color:#f92672>&amp;</span>e);
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 19</span>:
lparser.c</div><p>在遇到 <code>=</code> 之前，执行 if 语句块，递归调用 primaryexp 分析变量；
遇到 <code>=</code> 之后，执行 else 语句块，分析表达式。
在递归的终点，将表达式得到的值赋值给变量。</p><p>因为示例代码中变量都很简单，primaryexp 主要调用 prefixexp 进行分析。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">667
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">668
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">669
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">670
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">671
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">672
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">673
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">674
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">675
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">676
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">677
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">678
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">679
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">680
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">681
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">682
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">683
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">684
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">685
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">686
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">687
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>prefixexp</span> (LexState <span style=color:#f92672>*</span>ls, expdesc <span style=color:#f92672>*</span>v) {
  <span style=color:#75715e>/* prefixexp -&gt; NAME | &#39;(&#39; expr &#39;)&#39; */</span>
  <span style=color:#66d9ef>switch</span> (ls<span style=color:#f92672>-&gt;</span>t.token) {
    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;(&#39;</span><span style=color:#f92672>:</span> {
      <span style=color:#66d9ef>int</span> line <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>linenumber;
      luaX_next(ls);
      expr(ls, v);
      check_match(ls, <span style=color:#e6db74>&#39;)&#39;</span>, <span style=color:#e6db74>&#39;(&#39;</span>, line);
      luaK_dischargevars(ls<span style=color:#f92672>-&gt;</span>fs, v);
      <span style=color:#66d9ef>return</span>;
    }
    <span style=color:#66d9ef>case</span> TK_NAME: {
      singlevar(ls, v);
      <span style=color:#66d9ef>return</span>;
    }
    <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span> {
      luaX_syntaxerror(ls, <span style=color:#e6db74>&#34;unexpected symbol&#34;</span>);
      <span style=color:#66d9ef>return</span>;
    }
  }
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 20</span>:
lparser.c</div><p>对应其中的 <code>TK_NAME</code> 类型，调用 singlevar 确定变量的类型，内容调用 singlevaraux 来实现。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">224
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">225
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">226
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">227
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">228
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">229
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">230
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">231
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">232
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">233
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">234
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">235
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">236
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">237
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">238
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">239
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">240
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">241
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">242
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">243
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">244
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">245
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">246
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">247
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">248
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">249
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">250
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">251
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">252
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">253
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>singlevaraux</span> (FuncState <span style=color:#f92672>*</span>fs, TString <span style=color:#f92672>*</span>n, expdesc <span style=color:#f92672>*</span>var, <span style=color:#66d9ef>int</span> base) {
  <span style=color:#66d9ef>if</span> (fs <span style=color:#f92672>==</span> NULL) {  <span style=color:#75715e>/* no more levels? */</span>
    init_exp(var, VGLOBAL, NO_REG);  <span style=color:#75715e>/* default is global variable */</span>
    <span style=color:#66d9ef>return</span> VGLOBAL;
  }
  <span style=color:#66d9ef>else</span> {
    <span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> searchvar(fs, n);  <span style=color:#75715e>/* look up at current level */</span>
    <span style=color:#66d9ef>if</span> (v <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) {
      init_exp(var, VLOCAL, v);
      <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>base)
	markupval(fs, v);  <span style=color:#75715e>/* local will be used as an upval */</span>
      <span style=color:#66d9ef>return</span> VLOCAL;
    }
    <span style=color:#66d9ef>else</span> {  <span style=color:#75715e>/* not found at current level; try upper one */</span>
      <span style=color:#66d9ef>if</span> (singlevaraux(fs<span style=color:#f92672>-&gt;</span>prev, n, var, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>==</span> VGLOBAL)
	<span style=color:#66d9ef>return</span> VGLOBAL;
      var<span style=color:#f92672>-&gt;</span>u.s.info <span style=color:#f92672>=</span> indexupvalue(fs, n, var);  <span style=color:#75715e>/* else was LOCAL or UPVAL */</span>
      var<span style=color:#f92672>-&gt;</span>k <span style=color:#f92672>=</span> VUPVAL;  <span style=color:#75715e>/* upvalue in this level */</span>
      <span style=color:#66d9ef>return</span> VUPVAL;
    }
  }
}


<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>singlevar</span> (LexState <span style=color:#f92672>*</span>ls, expdesc <span style=color:#f92672>*</span>var) {
  TString <span style=color:#f92672>*</span>varname <span style=color:#f92672>=</span> str_checkname(ls);
  FuncState <span style=color:#f92672>*</span>fs <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>fs;
  <span style=color:#66d9ef>if</span> (singlevaraux(fs, varname, var, <span style=color:#ae81ff>1</span>) <span style=color:#f92672>==</span> VGLOBAL)
    var<span style=color:#f92672>-&gt;</span>u.s.info <span style=color:#f92672>=</span> luaK_stringK(fs, varname);  <span style=color:#75715e>/* info points to global name */</span>
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 21</span>:
lparser.c</div><p>singlevaraux 是非常关键的过程，回忆之前在分析过程中，关于嵌套的 function 定义和 fs->prev 的链条，
singlevaraux 就顺着 fs->prev 不断向上层作用域寻找变量。</p><p>如果 <code>fs == NULL</code> ，说明已经到顶层，变量只能为 global 类型；
如果在当前作用域可找到，说明是 local 变量；其它为 upval 变量。</p><p>示例中 a b c 都为全局变量，所以 singlevaraux 返回 VGLOBAL，
将相应 expdesc 类型赋值为 VGLOBAL，且 info 存储了变量名对应的 k 表索引。</p><p>表达式分析阶段，将 10 20 30 加入 k 表，同时载入寄存器。</p><p>最终赋值阶段，在每个递归层次，用 luaK_storevar 来存储。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">472
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">473
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">474
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">475
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">476
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">477
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">478
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">479
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">480
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">481
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">482
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">483
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">484
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">485
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">486
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">487
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">488
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">489
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">490
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">491
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">492
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">493
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">494
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">495
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">496
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">497
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">498
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">499
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">500
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>luaK_storevar</span> (FuncState <span style=color:#f92672>*</span>fs, expdesc <span style=color:#f92672>*</span>var, expdesc <span style=color:#f92672>*</span>ex) {
  <span style=color:#66d9ef>switch</span> (var<span style=color:#f92672>-&gt;</span>k) {
    <span style=color:#66d9ef>case</span> VLOCAL: {
      freeexp(fs, ex);
      exp2reg(fs, ex, var<span style=color:#f92672>-&gt;</span>u.s.info);
      <span style=color:#66d9ef>return</span>;
    }
    <span style=color:#66d9ef>case</span> VUPVAL: {
      <span style=color:#66d9ef>int</span> e <span style=color:#f92672>=</span> luaK_exp2anyreg(fs, ex);
      luaK_codeABC(fs, OP_SETUPVAL, e, var<span style=color:#f92672>-&gt;</span>u.s.info, <span style=color:#ae81ff>0</span>);
      <span style=color:#66d9ef>break</span>;
    }
    <span style=color:#66d9ef>case</span> VGLOBAL: {
      <span style=color:#66d9ef>int</span> e <span style=color:#f92672>=</span> luaK_exp2anyreg(fs, ex);
      luaK_codeABx(fs, OP_SETGLOBAL, e, var<span style=color:#f92672>-&gt;</span>u.s.info);
      <span style=color:#66d9ef>break</span>;
    }
    <span style=color:#66d9ef>case</span> VINDEXED: {
      <span style=color:#66d9ef>int</span> e <span style=color:#f92672>=</span> luaK_exp2RK(fs, ex);
      luaK_codeABC(fs, OP_SETTABLE, var<span style=color:#f92672>-&gt;</span>u.s.info, var<span style=color:#f92672>-&gt;</span>u.s.aux, e);
      <span style=color:#66d9ef>break</span>;
    }
    <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span> {
      lua_assert(<span style=color:#ae81ff>0</span>);  <span style=color:#75715e>/* invalid var kind to store */</span>
      <span style=color:#66d9ef>break</span>;
    }
  }
  freeexp(fs, ex);
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 22</span>:
lcode.c</div><p>对应 case VGLOBAL，生成 setglobal 指令。</p><h4 id=upvalue>upvalue
<a class=anchor href=#upvalue>#</a></h4><p>分析如下代码，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> a

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>f</span>()
  a <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
<span style=color:#66d9ef>end</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  &#34;a&#34;  ; 0
.const  &#34;f&#34;  ; 0

  ; function [0] definition (level 2)
  ; 1 upvalues, 0 params, 0 is_vararg, 2 stacks
  .function  1 0 0 2
  .upvalue  &#34;a&#34;  ; 0
  .const  10  ; 0
  [1] loadk      0   0        ; 10
  [2] setupval   0   0        ; a
  [3] return     0   1
  ; end of function

[1] closure    1   0        ; 1 upvalues
[2] move       0   0
[3] setglobal  1   0        ; f
[4] return     0   1
; end of function
</code></pre></div><p>对于外层函数，a 是 local 变量，而对应内层函数，a 为 upval 变量。</p><p>基本过程同 global，不过 singlevaraux 搜索得到 VUPVAL，生成 setupval 指令。</p><h4 id=local>local
<a class=anchor href=#local>#</a></h4><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>

<span style=color:#66d9ef>local</span> b
b <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span></code></pre></td></tr></table></div></div><p>line 1 为 local 赋值语句，而 line 4 为普通赋值语句，不过恰巧赋值给 local 变量。</p><p>分析如下示例，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> a, b

b <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  &#34;a&#34;  ; 0
.local  &#34;b&#34;  ; 1
.const  10  ; 0
[1] loadk      1   0        ; 10
[2] return     0   1
; end of function
</code></pre></div><p>分析过程与上相同，singlevaraux 确定为 VLOCAL，针对寄存器位置，直接生成 loadk。</p><h4 id=indexed>indexed
<a class=anchor href=#indexed>#</a></h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> t <span style=color:#f92672>=</span> {}

t[<span style=color:#e6db74>&#39;a&#39;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  &#34;t&#34;  ; 0
.const  &#34;a&#34;  ; 0
.const  10  ; 1
[1] newtable   0   0   0    ; array=0, hash=0
[2] settable   0   256 257  ; &#34;a&#34; 10
[3] return     0   1
; end of function
</code></pre></div><p>VINDEXED 的分析分为两部分，singlevar 分析 t 为 local 变量，
同时在 primaryexp 中继续分析 &lsquo;a&rsquo; 为字符串值，存储在 k 表直接引用。
最终使用 <code>luaK_indexed</code> 确定 expdesc 的类型及相关数据。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">621
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">622
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">623
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">624
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>luaK_indexed</span> (FuncState <span style=color:#f92672>*</span>fs, expdesc <span style=color:#f92672>*</span>t, expdesc <span style=color:#f92672>*</span>k) {
  t<span style=color:#f92672>-&gt;</span>u.s.aux <span style=color:#f92672>=</span> luaK_exp2RK(fs, k);
  t<span style=color:#f92672>-&gt;</span>k <span style=color:#f92672>=</span> VINDEXED;
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 23</span>:
lcode.c</div><p>在最终赋值时，生成 gettable 指令。</p><p>之所以使用 RK(C) 作为索引，是因为索引值未必是常数，也可能是一个表，一个函数等其它值，
这里由 table 的特性决定的，这种通用的值只能由寄存器存储。</p><h3 id=function>function
<a class=anchor href=#function>#</a></h3><p>这个小节关注 function 分析的过程。</p><p>语法描述中，涉及函数定义的地方，主要有 3 处，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bnf data-lang=bnf>funcstat     <span style=color:#f92672>::=</span> FUNCTION funcname body
funcname     <span style=color:#f92672>::=</span> NAME {`.&#39; NAME} [`:&#39; NAME]
body         <span style=color:#f92672>::=</span> `(&#39; parlist `)&#39; chunk END
parlist      <span style=color:#f92672>::=</span> [ DOTS | NAME {`,&#39; NAME} [`,&#39; DOTS] ]

localstat    <span style=color:#f92672>::=</span> LOCAL FUNCTION NAME body

simpleexp    <span style=color:#f92672>::=</span> NUMBER | STRING | NIL | TRUE | FALSE | DOTS |
		 constructor | FUNCTION body | primaryexp
</code></pre></div><p>第 1 种对应全局函数定义，第 2 种对应 local 函数定义，第 3 种对应函数函数定义。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>f</span>()
<span style=color:#66d9ef>end</span>

<span style=color:#66d9ef>local</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>f</span>()
<span style=color:#66d9ef>end</span>

<span style=color:#66d9ef>local</span> f <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> ()
<span style=color:#66d9ef>end</span>
</code></pre></div><p>但无论哪一种形式，函数分析的核心函数在于 body，通过 chunk 生成 Proto，
最终赋值予 global/local 变量。</p><h4 id=param>param
<a class=anchor href=#param>#</a></h4><p>先来看参数部分。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>f</span>(a, b, ...)
<span style=color:#66d9ef>end</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  &#34;f&#34;  ; 0

  ; function [0] definition (level 2)
  ; 0 upvalues, 2 params, 7 is_vararg, 3 stacks
  .function  0 2 7 3
  .local  &#34;a&#34;  ; 0
  .local  &#34;b&#34;  ; 1
  .local  &#34;arg&#34;  ; 2
  [1] return     0   1
  ; end of function

[1] closure    0   0        ; 0 upvalues
[2] return     0   1
; end of function
</code></pre></div><p>参数部分由 parlist 处理，分为固定参数和可变参数。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">543
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">544
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">545
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">546
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">547
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">548
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">549
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">550
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">551
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">552
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">553
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">554
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">555
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">556
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">557
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">558
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">559
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">560
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">561
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">562
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">563
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">564
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">565
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">566
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">567
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">568
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">569
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">570
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">571
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">572
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">573
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>parlist</span> (LexState <span style=color:#f92672>*</span>ls) {
  <span style=color:#75715e>/* parlist -&gt; [ param { `,&#39; param } ] */</span>
  FuncState <span style=color:#f92672>*</span>fs <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>fs;
  Proto <span style=color:#f92672>*</span>f <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>f;
  <span style=color:#66d9ef>int</span> nparams <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  f<span style=color:#f92672>-&gt;</span>is_vararg <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>if</span> (ls<span style=color:#f92672>-&gt;</span>t.token <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;)&#39;</span>) {  <span style=color:#75715e>/* is `parlist&#39; not empty? */</span>
    <span style=color:#66d9ef>do</span> {
      <span style=color:#66d9ef>switch</span> (ls<span style=color:#f92672>-&gt;</span>t.token) {
	<span style=color:#66d9ef>case</span> TK_NAME: {  <span style=color:#75715e>/* param -&gt; NAME */</span>
	  new_localvar(ls, str_checkname(ls), nparams<span style=color:#f92672>++</span>);
	  <span style=color:#66d9ef>break</span>;
	}
	<span style=color:#66d9ef>case</span> TK_DOTS: {  <span style=color:#75715e>/* param -&gt; `...&#39; */</span>
	  luaX_next(ls);
<span style=color:#75715e>#if defined(LUA_COMPAT_VARARG)
</span><span style=color:#75715e></span>	  <span style=color:#75715e>/* use `arg&#39; as default name */</span>
	  new_localvarliteral(ls, <span style=color:#e6db74>&#34;arg&#34;</span>, nparams<span style=color:#f92672>++</span>);
	  f<span style=color:#f92672>-&gt;</span>is_vararg <span style=color:#f92672>=</span> VARARG_HASARG <span style=color:#f92672>|</span> VARARG_NEEDSARG;
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>	  f<span style=color:#f92672>-&gt;</span>is_vararg <span style=color:#f92672>|=</span> VARARG_ISVARARG;
	  <span style=color:#66d9ef>break</span>;
	}
	<span style=color:#66d9ef>default</span><span style=color:#f92672>:</span> luaX_syntaxerror(ls, <span style=color:#e6db74>&#34;&lt;name&gt; or &#34;</span> LUA_QL(<span style=color:#e6db74>&#34;...&#34;</span>) <span style=color:#e6db74>&#34; expected&#34;</span>);
      }
    } <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>f<span style=color:#f92672>-&gt;</span>is_vararg <span style=color:#f92672>&amp;&amp;</span> testnext(ls, <span style=color:#e6db74>&#39;,&#39;</span>));
  }
  adjustlocalvars(ls, nparams);
  f<span style=color:#f92672>-&gt;</span>numparams <span style=color:#f92672>=</span> cast_byte(fs<span style=color:#f92672>-&gt;</span>nactvar <span style=color:#f92672>-</span> (f<span style=color:#f92672>-&gt;</span>is_vararg <span style=color:#f92672>&amp;</span> VARARG_HASARG));
  luaK_reserveregs(fs, fs<span style=color:#f92672>-&gt;</span>nactvar);  <span style=color:#75715e>/* reserve register for parameters */</span>
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 24</span>:
lparser.c</div><p>固定参数的处理方法，和 local 变量相同，不再赘述。</p><p>对于可变参数，即参数列表的最后定义中出现 <code>...</code> ，表明函数接收可变数量的参数，
全部收纳入 <code>...</code> 中。</p><p>在 lua5.0 中，可以在参数定义时使用 <code>...</code> ， 但是没有 <code>...</code> 表达式，
意味着在函数体中使用传入的参数时，通过变量 arg 来引用。</p><p>arg 是一个 table，以数组形式存储了所有可变参数，同时 arg.n 存储了数组的长度。</p><p>下面是 lua5.1 的同义描述，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>f</span>(a, b, ...)
  <span style=color:#66d9ef>local</span> arg <span style=color:#f92672>=</span> {...}
  arg.n <span style=color:#f92672>=</span> select(<span style=color:#e6db74>&#34;#&#34;</span>, ...)
<span style=color:#66d9ef>end</span>
</code></pre></div><p>lua5.1 默认提供了对变量 arg 的兼容性，所以才会出现注册 arg 变量的情况。</p><p><code>fs->is_vararg</code> 是用来记录可变参数状态的变量，含义由 3 个二进制位综合表示。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">256
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">257
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">258
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">259
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/* masks for new-style vararg */</span>
<span style=color:#75715e>#define VARARG_HASARG		1
</span><span style=color:#75715e>#define VARARG_ISVARARG		2
</span><span style=color:#75715e>#define VARARG_NEEDSARG		4</span></code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 25</span>:
lobject.h</div><table><thead><tr><th>macro</th><th>number</th><th>desc</th></tr></thead><tbody><tr><td><code>VARARG_HASARG</code></td><td>0b001</td><td>方便计算参数数量，直接使用 & 运算就可以</td></tr><tr><td><code>VARARG_ISVARARG</code></td><td>0b010</td><td>是否存在可变参数</td></tr><tr><td><code>VARARG_NEEDSARG</code></td><td>0b100</td><td>是否需要 arg，当函数内部出现 <code>...</code> 表达式时，置为 0</td></tr></tbody></table><p>内部有如下几种模式</p><table><thead><tr><th>cond</th><th><code>is_vararg</code></th></tr></thead><tbody><tr><td>无可变参数</td><td>0b000</td></tr><tr><td>chunk</td><td>0b010</td></tr><tr><td>不需要 arg 变量</td><td>0b011</td></tr><tr><td>默认的兼容情况</td><td>0b111</td></tr></tbody></table><h4 id=upval>upval
<a class=anchor href=#upval>#</a></h4><p>函数体就是 chunk 过程，作为分析的入口，在内部被递归调用，这里不再多做解释。</p><p>这里想重点说明的是，函数对 upvalue 的引用过程。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> a

<span style=color:#66d9ef>local</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>f</span>()
   <span style=color:#66d9ef>local</span> b

   <span style=color:#66d9ef>local</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>g</span>()
      b <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>
      a <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
   <span style=color:#66d9ef>end</span>
<span style=color:#66d9ef>end</span></code></pre></td></tr></table></div></div><p>示例代码存在 3 层函数嵌套，chunk f g。</p><p>g 中引用的变量 a b 对于 g 而言都是 upvalue 类型。</p><p>当分析到 line 7 时，fs 的链接关系如下，</p><figure><img src=generator-f-g-upval.png></figure><p>首先分析变量 b，</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">183
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">184
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">185
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">186
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">187
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">188
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">189
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">190
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">191
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">192
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">193
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">194
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">195
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">196
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">197
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">198
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">199
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">200
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">201
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">202
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">203
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">204
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>singlevaraux</span> (FuncState <span style=color:#f92672>*</span>fs, TString <span style=color:#f92672>*</span>n, expdesc <span style=color:#f92672>*</span>var, <span style=color:#66d9ef>int</span> base) {
  <span style=color:#66d9ef>if</span> (fs <span style=color:#f92672>==</span> NULL) {  <span style=color:#75715e>/* no more levels? */</span>
    init_exp(var, VGLOBAL, NO_REG);  <span style=color:#75715e>/* default is global variable */</span>
    <span style=color:#66d9ef>return</span> VGLOBAL;
  }
  <span style=color:#66d9ef>else</span> {
    <span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> searchvar(fs, n);  <span style=color:#75715e>/* look up at current level */</span>
    <span style=color:#66d9ef>if</span> (v <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) {
      init_exp(var, VLOCAL, v);
      <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>base)
	markupval(fs, v);  <span style=color:#75715e>/* local will be used as an upval */</span>
      <span style=color:#66d9ef>return</span> VLOCAL;
    }
    <span style=color:#66d9ef>else</span> {  <span style=color:#75715e>/* not found at current level; try upper one */</span>
      <span style=color:#66d9ef>if</span> (singlevaraux(fs<span style=color:#f92672>-&gt;</span>prev, n, var, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>==</span> VGLOBAL)
	<span style=color:#66d9ef>return</span> VGLOBAL;
      var<span style=color:#f92672>-&gt;</span>u.s.info <span style=color:#f92672>=</span> indexupvalue(fs, n, var);  <span style=color:#75715e>/* else was LOCAL or UPVAL */</span>
      var<span style=color:#f92672>-&gt;</span>k <span style=color:#f92672>=</span> VUPVAL;  <span style=color:#75715e>/* upvalue in this level */</span>
      <span style=color:#66d9ef>return</span> VUPVAL;
    }
  }
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 26</span>:
lparser.c</div><p>在 fs g() 中搜索无果，搜索上层 fs f()，在 fs f() 的 local 变量中找到 b，
调用 indexupvalue，然后标识为 VUPVAL 类型返回。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">183
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">184
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">185
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">186
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">187
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">188
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">189
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">190
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">191
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">192
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">193
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">194
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">195
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">196
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">197
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">198
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">199
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">200
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">201
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">202
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">203
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">204
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>indexupvalue</span> (FuncState <span style=color:#f92672>*</span>fs, TString <span style=color:#f92672>*</span>name, expdesc <span style=color:#f92672>*</span>v) {
  <span style=color:#66d9ef>int</span> i;
  Proto <span style=color:#f92672>*</span>f <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>f;
  <span style=color:#66d9ef>int</span> oldsize <span style=color:#f92672>=</span> f<span style=color:#f92672>-&gt;</span>sizeupvalues;
  <span style=color:#66d9ef>for</span> (i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>f<span style=color:#f92672>-&gt;</span>nups; i<span style=color:#f92672>++</span>) {
    <span style=color:#66d9ef>if</span> (fs<span style=color:#f92672>-&gt;</span>upvalues[i].k <span style=color:#f92672>==</span> v<span style=color:#f92672>-&gt;</span>k <span style=color:#f92672>&amp;&amp;</span> fs<span style=color:#f92672>-&gt;</span>upvalues[i].info <span style=color:#f92672>==</span> v<span style=color:#f92672>-&gt;</span>u.s.info) {
      lua_assert(f<span style=color:#f92672>-&gt;</span>upvalues[i] <span style=color:#f92672>==</span> name);
      <span style=color:#66d9ef>return</span> i;
    }
  }
  <span style=color:#75715e>/* new one */</span>
  luaY_checklimit(fs, f<span style=color:#f92672>-&gt;</span>nups <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, LUAI_MAXUPVALUES, <span style=color:#e6db74>&#34;upvalues&#34;</span>);
  luaM_growvector(fs<span style=color:#f92672>-&gt;</span>L, f<span style=color:#f92672>-&gt;</span>upvalues, f<span style=color:#f92672>-&gt;</span>nups, f<span style=color:#f92672>-&gt;</span>sizeupvalues,
		  TString <span style=color:#f92672>*</span>, MAX_INT, <span style=color:#e6db74>&#34;&#34;</span>);
  <span style=color:#66d9ef>while</span> (oldsize <span style=color:#f92672>&lt;</span> f<span style=color:#f92672>-&gt;</span>sizeupvalues) f<span style=color:#f92672>-&gt;</span>upvalues[oldsize<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> NULL;
  f<span style=color:#f92672>-&gt;</span>upvalues[f<span style=color:#f92672>-&gt;</span>nups] <span style=color:#f92672>=</span> name;
  luaC_objbarrier(fs<span style=color:#f92672>-&gt;</span>L, f, name);
  lua_assert(v<span style=color:#f92672>-&gt;</span>k <span style=color:#f92672>==</span> VLOCAL <span style=color:#f92672>||</span> v<span style=color:#f92672>-&gt;</span>k <span style=color:#f92672>==</span> VUPVAL);
  fs<span style=color:#f92672>-&gt;</span>upvalues[f<span style=color:#f92672>-&gt;</span>nups].k <span style=color:#f92672>=</span> cast_byte(v<span style=color:#f92672>-&gt;</span>k);
  fs<span style=color:#f92672>-&gt;</span>upvalues[f<span style=color:#f92672>-&gt;</span>nups].info <span style=color:#f92672>=</span> cast_byte(v<span style=color:#f92672>-&gt;</span>u.s.info);
  <span style=color:#66d9ef>return</span> f<span style=color:#f92672>-&gt;</span>nups<span style=color:#f92672>++</span>;
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 27</span>:
lparser.c</div><p>在 indexupvalue 中，先搜索是否已经存在 upvalue b，若没有则存储到 upvalues 数组中。</p><p>f->upvalues 记录变量名，fs->upvalues 记录 upval 信息。</p><figure><img src=generator-f-g-upvalues-0.png></figure><figure><img src=generator-f-g-upvalues-1.png></figure><p>upvalue 其实可分为两种情况，一种是 VLOCAL，一种是 VUPVAL。</p><p>b 属于 VLOCAL 的情况，因为 b 和 g() 在一个层级，g() 内部只需要向上查找一个层级便可定位 b。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> upvaldesc {
  lu_byte k;
  lu_byte info;
} upvaldesc;</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 28</span>:
lparser.h</div><p>fs->upvalues 在记录 VLOCAL 的同时，也记录其对应的寄存器位置。</p><p>再来搜索变量 a，不存在于 g()，也不存在于 f() 中，在 chunk() 中找到。</p><p>此时 upvalues 数组的情况如下。</p><figure><img src=generator-f-g-upvalues-2.png></figure><figure><img src=generator-f-g-upvalues-3.png></figure><p>a 对于 g() 属于 VUPVAL 的情况，对于 f() 属于 VLOCAL 的情况。</p><p>值得注意，在搜索变量 a 的时候，indexupvalue 调用了两次，一次从 fs g() 出发，一次从 fs f() 出发。
这也解释了，为什么 f() 没有直接使用 a，但是其 upvalues 表中依然记录了 a。</p><p>当函数 g() 解析结束之后，将 Proto 结果链接到上层。</p><figure><img src=generator-f-g-upvalues-4.png></figure><p>得到 Proto 之后，生成 closure 指令将其赋值予变量 g。</p><p>同时在 closure 指令之后，生成了额外的两条指令，按顺序表明当前 closure 的 upvalue 的类型和索引信息。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>[2] move       0   0
[3] getupval   0   0        ; a
</code></pre></div><p>move 指令此时不表示普通的 move 含义，参数 A 无用，参数 B 指代 VLOCAL 的栈索引。
表示新建的 closure 第 1 个 upvalue 是 VLOCAL 类型，
指向当前作用域索引为 0 的寄存器。</p><p>getupval 指令同样，参数 A 无用，参数 B 表示上层 closure 中 upvalues 表中的序号。
表示第 2 个 upvalue 是 VUPVAL 类型，指向上个作用域索引为 0 的 upvalue。</p><p>使用这种方式，将 upvalue 的类型和索引存储到 code 中，
所以 f->upvalues 只需要单纯记录变量名称就足够了。</p><p>vm 在执行的时候，自然会理会其中的含义并做出相应处理。</p><h3 id=do>do
<a class=anchor href=#do>#</a></h3><p>相信很多人都对 ebnf 描述中的 block 和 chunk 有疑问。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bnf data-lang=bnf>stat         <span style=color:#f92672>::=</span> dostat
dostat       <span style=color:#f92672>::=</span> DO block END

block        <span style=color:#f92672>::=</span> chunk
</code></pre></div><p>chunk 已经是分析的入口，为什么 block 又生成 chunk，这样看来 block
不是应该在 chunk 上层吗？</p><p>其实这个问题可以这样看，chunk 可以看作是分析语句列表的方法，
block 调用 chunk，是为了分析 block 中的语句列表，并不是要生成新的 FuncState。</p><p>实际上，block 有其自己的一套逻辑。</p><p>do 语句是最纯粹调用 block 的语句。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> a

<span style=color:#66d9ef>do</span>
   <span style=color:#66d9ef>local</span> b
   <span style=color:#66d9ef>local</span> c
   <span style=color:#66d9ef>do</span>
      <span style=color:#66d9ef>local</span> d

      a <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
   <span style=color:#66d9ef>end</span>
<span style=color:#66d9ef>end</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 4 stacks
.function  0 0 2 4
.local  &#34;a&#34;  ; 0
.local  &#34;b&#34;  ; 1
.local  &#34;c&#34;  ; 2
.local  &#34;d&#34;  ; 3
.const  10  ; 0
[1] loadk      0   0        ; 10
[2] return     0   1
; end of function
</code></pre></div><p>从结果中，好像什么都看不到，和正常声明变量，进行赋值，是一样的效果。</p><p>实际上，do 语句的作用主要在于描述块作用域。</p><p>在 block() 方法中，</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">881
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">882
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">883
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">884
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">885
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">886
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">887
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">888
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">889
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>block</span> (LexState <span style=color:#f92672>*</span>ls) {
  <span style=color:#75715e>/* block -&gt; chunk */</span>
  FuncState <span style=color:#f92672>*</span>fs <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>fs;
  BlockCnt bl;
  enterblock(fs, <span style=color:#f92672>&amp;</span>bl, <span style=color:#ae81ff>0</span>);
  chunk(ls);
  lua_assert(bl.breaklist <span style=color:#f92672>==</span> NO_JUMP);
  leaveblock(fs);
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 29</span>:
lparser.c</div><p>先后调用 enterblock 和 leaveblock 方法，操作 fs->bl。</p><p>这里也说明了，虽然同样调用 chunk，但是在函数定义时，其使用 <code>open_func</code> <code>close_func</code> 来操作
fs->prev 形成链状结构，所以 block() 的行为主要是由 enterblock leaveblock 决定的。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e>** nodes for block list (list of active blocks)
</span><span style=color:#75715e>*/</span>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> BlockCnt {
  <span style=color:#66d9ef>struct</span> BlockCnt <span style=color:#f92672>*</span>previous;  <span style=color:#75715e>/* chain */</span>
  <span style=color:#66d9ef>int</span> breaklist;  <span style=color:#75715e>/* list of jumps out of this loop */</span>
  lu_byte nactvar;  <span style=color:#75715e>/* # active locals outside the breakable structure */</span>
  lu_byte upval;  <span style=color:#75715e>/* true if some variable in the block is an upvalue */</span>
  lu_byte isbreakable;  <span style=color:#75715e>/* true if `block&#39; is a loop */</span>
} BlockCnt;</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 30</span>:
lparser.c</div><p>BlockCnt 的结构并不复杂，</p><ul><li><code>struct BlockCnt *previous</code> ，指向父 block</li><li><code>int breaklist</code> ，在 while 章节讲解</li><li><code>lu_byte nactvar</code> ，进入 block 前保存 nactvar</li><li><code>lu_byte upval</code> ，当前块作用域中是否有 local 变量用作 upvalue，在 repeat 章节讲解</li><li><code>lu_byte isbreakable</code> ，是否是一个循环语句块，在 while 章节讲解。</li></ul><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">285
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">286
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">287
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">288
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">289
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">290
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">291
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">292
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">293
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">294
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">295
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">296
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">297
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">298
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">299
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">300
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">301
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">302
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">303
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">304
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">305
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">306
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">307
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>enterblock</span> (FuncState <span style=color:#f92672>*</span>fs, BlockCnt <span style=color:#f92672>*</span>bl, lu_byte isbreakable) {
  bl<span style=color:#f92672>-&gt;</span>breaklist <span style=color:#f92672>=</span> NO_JUMP;
  bl<span style=color:#f92672>-&gt;</span>isbreakable <span style=color:#f92672>=</span> isbreakable;
  bl<span style=color:#f92672>-&gt;</span>nactvar <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>nactvar;
  bl<span style=color:#f92672>-&gt;</span>upval <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  bl<span style=color:#f92672>-&gt;</span>previous <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>bl;
  fs<span style=color:#f92672>-&gt;</span>bl <span style=color:#f92672>=</span> bl;
  lua_assert(fs<span style=color:#f92672>-&gt;</span>freereg <span style=color:#f92672>==</span> fs<span style=color:#f92672>-&gt;</span>nactvar);
}


<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>leaveblock</span> (FuncState <span style=color:#f92672>*</span>fs) {
  BlockCnt <span style=color:#f92672>*</span>bl <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>bl;
  fs<span style=color:#f92672>-&gt;</span>bl <span style=color:#f92672>=</span> bl<span style=color:#f92672>-&gt;</span>previous;
  removevars(fs<span style=color:#f92672>-&gt;</span>ls, bl<span style=color:#f92672>-&gt;</span>nactvar);
  <span style=color:#66d9ef>if</span> (bl<span style=color:#f92672>-&gt;</span>upval)
    luaK_codeABC(fs, OP_CLOSE, bl<span style=color:#f92672>-&gt;</span>nactvar, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
  <span style=color:#75715e>/* a block either controls scope or breaks (never both) */</span>
  lua_assert(<span style=color:#f92672>!</span>bl<span style=color:#f92672>-&gt;</span>isbreakable <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>bl<span style=color:#f92672>-&gt;</span>upval);
  lua_assert(bl<span style=color:#f92672>-&gt;</span>nactvar <span style=color:#f92672>==</span> fs<span style=color:#f92672>-&gt;</span>nactvar);
  fs<span style=color:#f92672>-&gt;</span>freereg <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>nactvar;  <span style=color:#75715e>/* free registers */</span>
  luaK_patchtohere(fs, bl<span style=color:#f92672>-&gt;</span>breaklist);
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 31</span>:
lparser.c</div><p>enterblock 新建 BlockCnt，指向父 block，并记录当前 nactvar。
leaveblock 则相反，删除顶层 block，将 fs->freereg 重置回原来的 nactvar。</p><p>明显地起到了作用域分隔的作用。</p><figure><img src=generator-do-block.png></figure><p>在第 1 次进入 do block 时，外部只定义了 local a，只有一个局部变量，
此时保存 nactvar 为 1。</p><p>第 2 次进入 do block 时，增加了定义 local b c，新的 BlockCnt 链接到父 block，
保存 nactvar 为 3。</p><p>在内部，修改 a = 10，这个 a 正是最外层的 local a 而不是 upvalue，因为 upvalue
只作用于不同函数之间，目前 local a b c d 是属于一个函数作用域的。</p><p>离开内层 do block 时，恢复 freereg 到 nactvar=3 且重置了 fs->nactvar，相当于回收了变量 d。</p><p>至于 block 在循环中的作用，到循环语句章节再讲解。</p><h3 id=if>if
<a class=anchor href=#if>#</a></h3><p>本节来分析，在代码生成过程中是如何处理 if 语句的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bnf data-lang=bnf>stat         <span style=color:#f92672>::=</span> ifstat

ifstat       <span style=color:#f92672>::=</span> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END
cond         <span style=color:#f92672>::=</span> expr
block        <span style=color:#f92672>::=</span> chunk
</code></pre></div><p>前面已经提到过，整体的分析过程是从左至右，从前至后的，
而 if 是分支结构，不同于分析过程的线性结构。</p><p>lua 内部使用一种精巧的方式解决这个问题。</p><h4 id=if>if
<a class=anchor href=#if>#</a></h4><p>首先来看示例代码，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> a, b

<span style=color:#66d9ef>if</span> b <span style=color:#66d9ef>then</span>
   a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
<span style=color:#66d9ef>end</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  &#34;a&#34;  ; 0
.local  &#34;b&#34;  ; 1
.const  1  ; 0
[1] test       1       0    ; to [3] if true
[2] jmp        1            ; to [4]
[3] loadk      0   0        ; 1
[4] return     0   1
; end of function
</code></pre></div><p>整体流程的示意如下，TRUE 表示条件为真所执行的字节码，这里为 loadk。</p><figure><img src=generator-if.png></figure><p>在分支结构中扮演重要角色的是两种指令，test 和 jmp。</p><p>在 vm 的执行过程中，pc 问题默认自增的，即执行完当前指令后，pc++，
对于 test 和 jmp 也不例外。</p><p>jmp 指令有一个参数，即跳转的距离，可正可负，意味着可以向前跳转，也可以向后。</p><p>根据 pc++ 的原则，</p><ul><li>指令 <code>jmp -1</code> 表示循环执行当前的 jmp 指令，因为 jmp 跳转到自身</li><li>指令 <code>jmp 0</code> 表示跳转到下一条指令，即正常执行</li><li>指令 <code>jmp 1</code> 表示略过下一条指令，跳转到下下一条指令</li></ul><p>jmp 是无条件跳转，而 test 指令不同，需要针对 True 和 False 跳转到不同的地方。
lua 使用了一种简洁的模式来安排。</p><p>（假设参数 <code>C = 0</code> ）test 指令之后固定接着一条 jmp 指令，用于执行 False 跳转。
jmp 指令之后紧接着 True 语句块。</p><p>在这种安排下，</p><ul><li>如果为 False，正常执行下一条指令，下一条 jmp 跳转到 False 语句块</li><li>如果为 True，vm 执行 pc++ ++，跳过 test 后的 jmp 指令，执行 True 语句块</li></ul><p>这样就不用使得 test 指令过于复杂。</p><p>对照示例代码，内部使用 ifstat() 来分析 if 语句。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1130
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1131
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1132
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1133
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1134
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1135
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1136
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1137
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1138
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1139
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1140
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1141
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1142
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1143
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1144
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1145
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1146
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1147
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1148
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1149
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1150
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1151
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1152
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1153
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1154
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1155
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1156
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1157
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1158
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1159
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1160
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1161
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1162
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>test_then_block</span> (LexState <span style=color:#f92672>*</span>ls) {
  <span style=color:#75715e>/* test_then_block -&gt; [IF | ELSEIF] cond THEN block */</span>
  <span style=color:#66d9ef>int</span> condexit;
  luaX_next(ls);  <span style=color:#75715e>/* skip IF or ELSEIF */</span>
  condexit <span style=color:#f92672>=</span> cond(ls);
  checknext(ls, TK_THEN);
  block(ls);  <span style=color:#75715e>/* `then&#39; part */</span>
  <span style=color:#66d9ef>return</span> condexit;
}


<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ifstat</span> (LexState <span style=color:#f92672>*</span>ls, <span style=color:#66d9ef>int</span> line) {
  <span style=color:#75715e>/* ifstat -&gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */</span>
  FuncState <span style=color:#f92672>*</span>fs <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>fs;
  <span style=color:#66d9ef>int</span> flist;
  <span style=color:#66d9ef>int</span> escapelist <span style=color:#f92672>=</span> NO_JUMP;
  flist <span style=color:#f92672>=</span> test_then_block(ls);  <span style=color:#75715e>/* IF cond THEN block */</span>
  <span style=color:#66d9ef>while</span> (ls<span style=color:#f92672>-&gt;</span>t.token <span style=color:#f92672>==</span> TK_ELSEIF) {
    luaK_concat(fs, <span style=color:#f92672>&amp;</span>escapelist, luaK_jump(fs));
    luaK_patchtohere(fs, flist);
    flist <span style=color:#f92672>=</span> test_then_block(ls);  <span style=color:#75715e>/* ELSEIF cond THEN block */</span>
  }
  <span style=color:#66d9ef>if</span> (ls<span style=color:#f92672>-&gt;</span>t.token <span style=color:#f92672>==</span> TK_ELSE) {
    luaK_concat(fs, <span style=color:#f92672>&amp;</span>escapelist, luaK_jump(fs));
    luaK_patchtohere(fs, flist);
    luaX_next(ls);  <span style=color:#75715e>/* skip ELSE (after patch, for correct line info) */</span>
    block(ls);  <span style=color:#75715e>/* `else&#39; part */</span>
  }
  <span style=color:#66d9ef>else</span>
    luaK_concat(fs, <span style=color:#f92672>&amp;</span>escapelist, flist);
  luaK_patchtohere(fs, escapelist);
  check_match(ls, TK_END, TK_IF, line);
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 32</span>:
lparser.c</div><p>使用 <code>test_then_block()</code> 分析 <code>IF cond THEN block</code> 的部分，
使用 cond() 分析条件部分，</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">965
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">966
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">967
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">968
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">969
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">970
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">971
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">972
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>cond</span> (LexState <span style=color:#f92672>*</span>ls) {
  <span style=color:#75715e>/* cond -&gt; exp */</span>
  expdesc v;
  expr(ls, <span style=color:#f92672>&amp;</span>v);  <span style=color:#75715e>/* read condition */</span>
  <span style=color:#66d9ef>if</span> (v.k <span style=color:#f92672>==</span> VNIL) v.k <span style=color:#f92672>=</span> VFALSE;  <span style=color:#75715e>/* `falses&#39; are all equal here */</span>
  luaK_goiftrue(ls<span style=color:#f92672>-&gt;</span>fs, <span style=color:#f92672>&amp;</span>v);
  <span style=color:#66d9ef>return</span> v.f;
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 33</span>:
lparser.c</div><p>进入 <code>luaK_goiftrue()</code> ，调用 <code>jumponcond</code> 和 <code>condjump</code> ，生成了 test 指令和 jmp 指令，</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">524
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">525
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">526
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">527
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">528
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">529
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">530
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">531
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">532
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">533
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">534
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">535
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">536
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">537
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">538
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">539
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">540
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">541
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">542
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">543
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">544
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">545
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">546
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">547
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">548
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">549
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">550
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">551
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">552
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">553
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">554
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">555
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">556
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">557
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">558
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">559
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">560
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>jumponcond</span> (FuncState <span style=color:#f92672>*</span>fs, expdesc <span style=color:#f92672>*</span>e, <span style=color:#66d9ef>int</span> cond) {
  <span style=color:#66d9ef>if</span> (e<span style=color:#f92672>-&gt;</span>k <span style=color:#f92672>==</span> VRELOCABLE) {
    Instruction ie <span style=color:#f92672>=</span> getcode(fs, e);
    <span style=color:#66d9ef>if</span> (GET_OPCODE(ie) <span style=color:#f92672>==</span> OP_NOT) {
      fs<span style=color:#f92672>-&gt;</span>pc<span style=color:#f92672>--</span>;  <span style=color:#75715e>/* remove previous OP_NOT */</span>
      <span style=color:#66d9ef>return</span> condjump(fs, OP_TEST, GETARG_B(ie), <span style=color:#ae81ff>0</span>, <span style=color:#f92672>!</span>cond);
    }
    <span style=color:#75715e>/* else go through */</span>
  }
  discharge2anyreg(fs, e);
  freeexp(fs, e);
  <span style=color:#66d9ef>return</span> condjump(fs, OP_TESTSET, NO_REG, e<span style=color:#f92672>-&gt;</span>u.s.info, cond);
}


<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>luaK_goiftrue</span> (FuncState <span style=color:#f92672>*</span>fs, expdesc <span style=color:#f92672>*</span>e) {
  <span style=color:#66d9ef>int</span> pc;  <span style=color:#75715e>/* pc of last jump */</span>
  luaK_dischargevars(fs, e);
  <span style=color:#66d9ef>switch</span> (e<span style=color:#f92672>-&gt;</span>k) {
    <span style=color:#66d9ef>case</span> VK: <span style=color:#66d9ef>case</span> VKNUM: <span style=color:#66d9ef>case</span> VTRUE: {
      pc <span style=color:#f92672>=</span> NO_JUMP;  <span style=color:#75715e>/* always true; do nothing */</span>
      <span style=color:#66d9ef>break</span>;
    }
    <span style=color:#66d9ef>case</span> VJMP: {
      invertjump(fs, e);
      pc <span style=color:#f92672>=</span> e<span style=color:#f92672>-&gt;</span>u.s.info;
      <span style=color:#66d9ef>break</span>;
    }
    <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span> {
      pc <span style=color:#f92672>=</span> jumponcond(fs, e, <span style=color:#ae81ff>0</span>);
      <span style=color:#66d9ef>break</span>;
    }
  }
  luaK_concat(fs, <span style=color:#f92672>&amp;</span>e<span style=color:#f92672>-&gt;</span>f, pc);  <span style=color:#75715e>/* insert last jump in `f&#39; list */</span>
  luaK_patchtohere(fs, e<span style=color:#f92672>-&gt;</span>t);
  e<span style=color:#f92672>-&gt;</span>t <span style=color:#f92672>=</span> NO_JUMP;
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 34</span>:
lcode.c</div><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">74
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">75
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">76
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">77
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>condjump</span> (FuncState <span style=color:#f92672>*</span>fs, OpCode op, <span style=color:#66d9ef>int</span> A, <span style=color:#66d9ef>int</span> B, <span style=color:#66d9ef>int</span> C) {
  luaK_codeABC(fs, op, A, B, C);
  <span style=color:#66d9ef>return</span> luaK_jump(fs);
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 35</span>:
lcode.c</div><p>最终 <code>cond()</code> 返回 jmp 指令的索引，在 ifstat() 中由 flist 保存。</p><p>下面就是关键的地方，lua 如何确定跳转的位置，其中有几个关键的过程，concat，patch 和 dischargejpc。</p><p>在 <code>test_then_block()</code> 之后，解析了 cond 和 true block，并保留了 jmp 指令的索引。</p><figure><img src=generator-if-test-then-block.png></figure><p>因为其后没有 else/elseif 语句，直接执行 line 1159，</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">185
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">186
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">187
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">188
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">189
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">190
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">191
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">192
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">193
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">194
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">195
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">196
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>luaK_concat</span> (FuncState <span style=color:#f92672>*</span>fs, <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>l1, <span style=color:#66d9ef>int</span> l2) {
  <span style=color:#66d9ef>if</span> (l2 <span style=color:#f92672>==</span> NO_JUMP) <span style=color:#66d9ef>return</span>;
  <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span>l1 <span style=color:#f92672>==</span> NO_JUMP)
    <span style=color:#f92672>*</span>l1 <span style=color:#f92672>=</span> l2;
  <span style=color:#66d9ef>else</span> {
    <span style=color:#66d9ef>int</span> list <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>l1;
    <span style=color:#66d9ef>int</span> next;
    <span style=color:#66d9ef>while</span> ((next <span style=color:#f92672>=</span> getjump(fs, list)) <span style=color:#f92672>!=</span> NO_JUMP)  <span style=color:#75715e>/* find last element */</span>
      list <span style=color:#f92672>=</span> next;
    fixjump(fs, list, l2);
  }
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 36</span>:
lcode.c</div><p>将 flist 链接到 escapelist 上，</p><figure><img src=generator-if-test-then-block-1.png></figure><p>其后执行 line 1160，执行 patch 过程，</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">179
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">180
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">181
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">182
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>luaK_patchtohere</span> (FuncState <span style=color:#f92672>*</span>fs, <span style=color:#66d9ef>int</span> list) {
  luaK_getlabel(fs);
  luaK_concat(fs, <span style=color:#f92672>&amp;</span>fs<span style=color:#f92672>-&gt;</span>jpc, list);
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 37</span>:
lcode.c</div><p>将 escapelist 链接到 fs->jpc 上，</p><figure><img src=generator-if-test-then-block-2.png></figure><p>最终在生成 TRUE 之后的语句时，执行 dischargejpc 过程，</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">789
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">790
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">791
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">792
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">793
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">794
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">795
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">796
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">797
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">798
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">799
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">800
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">801
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>luaK_code</span> (FuncState <span style=color:#f92672>*</span>fs, Instruction i, <span style=color:#66d9ef>int</span> line) {
  Proto <span style=color:#f92672>*</span>f <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>f;
  dischargejpc(fs);  <span style=color:#75715e>/* `pc&#39; will change */</span>
  <span style=color:#75715e>/* put new instruction in code array */</span>
  luaM_growvector(fs<span style=color:#f92672>-&gt;</span>L, f<span style=color:#f92672>-&gt;</span>code, fs<span style=color:#f92672>-&gt;</span>pc, f<span style=color:#f92672>-&gt;</span>sizecode, Instruction,
		  MAX_INT, <span style=color:#e6db74>&#34;code size overflow&#34;</span>);
  f<span style=color:#f92672>-&gt;</span>code[fs<span style=color:#f92672>-&gt;</span>pc] <span style=color:#f92672>=</span> i;
  <span style=color:#75715e>/* save corresponding line information */</span>
  luaM_growvector(fs<span style=color:#f92672>-&gt;</span>L, f<span style=color:#f92672>-&gt;</span>lineinfo, fs<span style=color:#f92672>-&gt;</span>pc, f<span style=color:#f92672>-&gt;</span>sizelineinfo, <span style=color:#66d9ef>int</span>,
		  MAX_INT, <span style=color:#e6db74>&#34;code size overflow&#34;</span>);
  f<span style=color:#f92672>-&gt;</span>lineinfo[fs<span style=color:#f92672>-&gt;</span>pc] <span style=color:#f92672>=</span> line;
  <span style=color:#66d9ef>return</span> fs<span style=color:#f92672>-&gt;</span>pc<span style=color:#f92672>++</span>;
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 38</span>:
lcode.c</div><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">150
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">151
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">152
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">153
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">154
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">155
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">156
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">157
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">158
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">159
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">160
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">161
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">162
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">163
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">164
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">165
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">166
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>patchlistaux</span> (FuncState <span style=color:#f92672>*</span>fs, <span style=color:#66d9ef>int</span> list, <span style=color:#66d9ef>int</span> vtarget, <span style=color:#66d9ef>int</span> reg,
			  <span style=color:#66d9ef>int</span> dtarget) {
  <span style=color:#66d9ef>while</span> (list <span style=color:#f92672>!=</span> NO_JUMP) {
    <span style=color:#66d9ef>int</span> next <span style=color:#f92672>=</span> getjump(fs, list);
    <span style=color:#66d9ef>if</span> (patchtestreg(fs, list, reg))
      fixjump(fs, list, vtarget);
    <span style=color:#66d9ef>else</span>
      fixjump(fs, list, dtarget);  <span style=color:#75715e>/* jump to default target */</span>
    list <span style=color:#f92672>=</span> next;
  }
}


<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dischargejpc</span> (FuncState <span style=color:#f92672>*</span>fs) {
  patchlistaux(fs, fs<span style=color:#f92672>-&gt;</span>jpc, fs<span style=color:#f92672>-&gt;</span>pc, NO_REG, fs<span style=color:#f92672>-&gt;</span>pc);
  fs<span style=color:#f92672>-&gt;</span>jpc <span style=color:#f92672>=</span> NO_JUMP;
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 39</span>:
lcode.c</div><figure><img src=generator-if-3.png></figure><p>此时已经在 TRUE 语句块之外，也明确当前的指令索引和 jmp 指令索引，
直接计算距离的差值，修改 jmp 指令的参数，跳转到此位置。</p><p>综合来看，concat 将需要重新定位的 jmp 指令链接起来，最终链接到 jpc 上，
由 dischargejpc 过程，调整所有链接的 jmp 指令，使其跳转到当前位置。</p><p>单纯的 if 语句比较简单，读者或许还体会不到这种方法的作用，下面来看更复杂的语句。</p><h4 id=if-else>if else
<a class=anchor href=#if-else>#</a></h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> a, b

<span style=color:#66d9ef>if</span> b <span style=color:#66d9ef>then</span>
   a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
<span style=color:#66d9ef>else</span>
   a <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
<span style=color:#66d9ef>end</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  &#34;a&#34;  ; 0
.local  &#34;b&#34;  ; 1
.const  1  ; 0
.const  0  ; 1
[1] test       1       0    ; to [3] if true
[2] jmp        2            ; to [5]
[3] loadk      0   0        ; 1
[4] jmp        1            ; to [6]
[5] loadk      0   1        ; 0
[6] return     0   1
; end of function
</code></pre></div><figure><img src=generator-if-else-0.png></figure><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1141
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1142
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1143
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1144
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1145
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1146
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1147
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1148
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1149
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1150
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1151
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1152
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1153
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1154
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1155
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1156
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1157
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1158
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1159
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1160
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1161
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1162
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ifstat</span> (LexState <span style=color:#f92672>*</span>ls, <span style=color:#66d9ef>int</span> line) {
  <span style=color:#75715e>/* ifstat -&gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */</span>
  FuncState <span style=color:#f92672>*</span>fs <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>fs;
  <span style=color:#66d9ef>int</span> flist;
  <span style=color:#66d9ef>int</span> escapelist <span style=color:#f92672>=</span> NO_JUMP;
  flist <span style=color:#f92672>=</span> test_then_block(ls);  <span style=color:#75715e>/* IF cond THEN block */</span>
  <span style=color:#66d9ef>while</span> (ls<span style=color:#f92672>-&gt;</span>t.token <span style=color:#f92672>==</span> TK_ELSEIF) {
    luaK_concat(fs, <span style=color:#f92672>&amp;</span>escapelist, luaK_jump(fs));
    luaK_patchtohere(fs, flist);
    flist <span style=color:#f92672>=</span> test_then_block(ls);  <span style=color:#75715e>/* ELSEIF cond THEN block */</span>
  }
  <span style=color:#66d9ef>if</span> (ls<span style=color:#f92672>-&gt;</span>t.token <span style=color:#f92672>==</span> TK_ELSE) {
    luaK_concat(fs, <span style=color:#f92672>&amp;</span>escapelist, luaK_jump(fs));
    luaK_patchtohere(fs, flist);
    luaX_next(ls);  <span style=color:#75715e>/* skip ELSE (after patch, for correct line info) */</span>
    block(ls);  <span style=color:#75715e>/* `else&#39; part */</span>
  }
  <span style=color:#66d9ef>else</span>
    luaK_concat(fs, <span style=color:#f92672>&amp;</span>escapelist, flist);
  luaK_patchtohere(fs, escapelist);
  check_match(ls, TK_END, TK_IF, line);
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 40</span>:
lparser.c</div><p>在 if else 语句中，解析 cond 和 true block 之后，要继续解析 else false block 部分。</p><p>false block 生成字节码也遵循一定的模式，先生成 jmp 指令，用于跳出 true block，
其次再生成 false block。</p><p>其中将这个 jmp 链接到 escapelist 上，因为分析到 false block 的起始位置，
所以重定向 test 部分的 jmp 到这个位置。</p><figure><img src=generator-if-else-1.png></figure><p>最终将 escapelist 链接到 jpc 上，进行 dischargejpc 操作。</p><figure><img src=generator-if-else-2.png></figure><p>由这种模式可以看出，flist 表示 false list，escapelist 表示跳出 true list。</p><p>discharge 的过程就是先将目标链接到 fs->jpc 上，然后从 fs->jpc 开始，重新定位所有 jmp 的目标位置。</p><h4 id=if-elseif>if elseif
<a class=anchor href=#if-elseif>#</a></h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> a, b, c

<span style=color:#66d9ef>if</span> b <span style=color:#66d9ef>then</span>
   a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
<span style=color:#66d9ef>elseif</span> c <span style=color:#66d9ef>then</span>
   a <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
<span style=color:#66d9ef>end</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 3 stacks
.function  0 0 2 3
.local  &#34;a&#34;  ; 0
.local  &#34;b&#34;  ; 1
.local  &#34;c&#34;  ; 2
.const  1  ; 0
.const  2  ; 1
[1] test       1       0    ; to [3] if true
[2] jmp        2            ; to [5]
[3] loadk      0   0        ; 1
[4] jmp        3            ; to [8]
[5] test       2       0    ; to [7] if true
[6] jmp        1            ; to [8]
[7] loadk      0   1        ; 2
[8] return     0   1
; end of function
</code></pre></div><figure><img src=generator-if-else-if-0.png></figure><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1141
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1142
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1143
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1144
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1145
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1146
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1147
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1148
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1149
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1150
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1151
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1152
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1153
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1154
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1155
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1156
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1157
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1158
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1159
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1160
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1161
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1162
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ifstat</span> (LexState <span style=color:#f92672>*</span>ls, <span style=color:#66d9ef>int</span> line) {
  <span style=color:#75715e>/* ifstat -&gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */</span>
  FuncState <span style=color:#f92672>*</span>fs <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>fs;
  <span style=color:#66d9ef>int</span> flist;
  <span style=color:#66d9ef>int</span> escapelist <span style=color:#f92672>=</span> NO_JUMP;
  flist <span style=color:#f92672>=</span> test_then_block(ls);  <span style=color:#75715e>/* IF cond THEN block */</span>
  <span style=color:#66d9ef>while</span> (ls<span style=color:#f92672>-&gt;</span>t.token <span style=color:#f92672>==</span> TK_ELSEIF) {
    luaK_concat(fs, <span style=color:#f92672>&amp;</span>escapelist, luaK_jump(fs));
    luaK_patchtohere(fs, flist);
    flist <span style=color:#f92672>=</span> test_then_block(ls);  <span style=color:#75715e>/* ELSEIF cond THEN block */</span>
  }
  <span style=color:#66d9ef>if</span> (ls<span style=color:#f92672>-&gt;</span>t.token <span style=color:#f92672>==</span> TK_ELSE) {
    luaK_concat(fs, <span style=color:#f92672>&amp;</span>escapelist, luaK_jump(fs));
    luaK_patchtohere(fs, flist);
    luaX_next(ls);  <span style=color:#75715e>/* skip ELSE (after patch, for correct line info) */</span>
    block(ls);  <span style=color:#75715e>/* `else&#39; part */</span>
  }
  <span style=color:#66d9ef>else</span>
    luaK_concat(fs, <span style=color:#f92672>&amp;</span>escapelist, flist);
  luaK_patchtohere(fs, escapelist);
  check_match(ls, TK_END, TK_IF, line);
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 41</span>:
lparser.c</div><p>elseif 结构是不限数量的，相比之下，if 和 else 只能有一个，
所以这里用 while 循环来重复检测所有 elseif 块。</p><p>对于一个 elseif 块，先生成 jmp 指令，再重新调用 <code>test_then_block</code> ，当做一个 if 块来处理。</p><p>示例代码中只有一个 elseif 块，所以在执行到 line 1151 时，生成字节码如下，</p><figure><img src=generator-if-else-if-1.png></figure><p>在生成最终的 return 之前，在 line 1159 将 flist 链接到 escapelist 上，因为它们有同样的终点。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">185
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">186
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">187
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">188
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">189
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">190
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">191
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">192
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">193
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">194
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">195
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">196
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>luaK_concat</span> (FuncState <span style=color:#f92672>*</span>fs, <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>l1, <span style=color:#66d9ef>int</span> l2) {
  <span style=color:#66d9ef>if</span> (l2 <span style=color:#f92672>==</span> NO_JUMP) <span style=color:#66d9ef>return</span>;
  <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span>l1 <span style=color:#f92672>==</span> NO_JUMP)
    <span style=color:#f92672>*</span>l1 <span style=color:#f92672>=</span> l2;
  <span style=color:#66d9ef>else</span> {
    <span style=color:#66d9ef>int</span> list <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>l1;
    <span style=color:#66d9ef>int</span> next;
    <span style=color:#66d9ef>while</span> ((next <span style=color:#f92672>=</span> getjump(fs, list)) <span style=color:#f92672>!=</span> NO_JUMP)  <span style=color:#75715e>/* find last element */</span>
      list <span style=color:#f92672>=</span> next;
    fixjump(fs, list, l2);
  }
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 42</span>:
lcode.c</div><p>其中将 4 jmp 指令，跳转到 6 jmp，相当于将 jmp 链接起来，以 escapelist 为索引链的开始。</p><figure><img src=generator-if-else-if-2.png></figure><p>最终在 discharge 的时候，只需要顺着 escapelist 往下，就可以访问到所有需要重定位的 jmp 指令，
并进行相应参数的修改。</p><h4 id=if-elseif-else>if elseif else
<a class=anchor href=#if-elseif-else>#</a></h4><p>嵌套的过程，读者可使用上述方法，自主探索，在此不再赘述。</p><h3 id=while>while
<a class=anchor href=#while>#</a></h3><p>分支之后，来探索经典的 while 循环结构。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bnf data-lang=bnf>whilestat    <span style=color:#f92672>::=</span> WHILE cond DO block END
</code></pre></div><p>分析如下简单的示例，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> a, b

<span style=color:#66d9ef>while</span> b <span style=color:#66d9ef>do</span>
   a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
<span style=color:#66d9ef>end</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  &#34;a&#34;  ; 0
.local  &#34;b&#34;  ; 1
.const  1  ; 0
[1] test       1       0    ; to [3] if true
[2] jmp        2            ; to [5]
[3] loadk      0   0        ; 1
[4] jmp        -4           ; to [1]
[5] return     0   1
; end of function
</code></pre></div><figure><img src=generator-while-0.png></figure><p>可以看出，while 结构生成字节码也是模式化的，cond 生成 test 和 jmp 指令，
其后是循环体，最后的 jmp 指令用于跳转到循环开始，只有 test 为 false 的时候才会跳出循环体。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 991
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 992
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 993
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 994
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 995
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 996
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 997
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 998
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 999
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1000
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1001
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1002
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1003
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1004
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1005
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1006
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1007
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>whilestat</span> (LexState <span style=color:#f92672>*</span>ls, <span style=color:#66d9ef>int</span> line) {
  <span style=color:#75715e>/* whilestat -&gt; WHILE cond DO block END */</span>
  FuncState <span style=color:#f92672>*</span>fs <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>fs;
  <span style=color:#66d9ef>int</span> whileinit;
  <span style=color:#66d9ef>int</span> condexit;
  BlockCnt bl;
  luaX_next(ls);  <span style=color:#75715e>/* skip WHILE */</span>
  whileinit <span style=color:#f92672>=</span> luaK_getlabel(fs);
  condexit <span style=color:#f92672>=</span> cond(ls);
  enterblock(fs, <span style=color:#f92672>&amp;</span>bl, <span style=color:#ae81ff>1</span>);
  checknext(ls, TK_DO);
  block(ls);
  luaK_patchlist(fs, luaK_jump(fs), whileinit);
  check_match(ls, TK_END, TK_WHILE, line);
  leaveblock(fs);
  luaK_patchtohere(fs, condexit);  <span style=color:#75715e>/* false conditions finish the loop */</span>
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 43</span>:
lparser.c</div><p>生成的过程并不难理解，根据对 concat 和 patch 的理解，</p><figure><img src=generator-while-1.png></figure><h4 id=break>break
<a class=anchor href=#break>#</a></h4><p>因为 break 语句只能用于循环中，所以放在这里和 while 一起讲解。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bnf data-lang=bnf>breakstat    <span style=color:#f92672>::=</span> BREAK
</code></pre></div><p>分析如下示例，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> a, b

<span style=color:#66d9ef>while</span> b <span style=color:#66d9ef>do</span>
   a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
   <span style=color:#66d9ef>break</span>
<span style=color:#66d9ef>end</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  &#34;a&#34;  ; 0
.local  &#34;b&#34;  ; 1
.const  1  ; 0
[1] test       1       0    ; to [3] if true
[2] jmp        3            ; to [6]
[3] loadk      0   0        ; 1
[4] jmp        1            ; to [6]
[5] jmp        -5           ; to [1]
[6] return     0   1
; end of function
</code></pre></div><figure><img src=generator-break-0.png></figure><p>可以看出，break 在循环体生成了 jmp 指令，跳转到循环外，这个过程由以下几点协同来实现。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 975
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 976
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 977
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 978
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 979
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 980
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 981
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 982
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 983
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 984
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 985
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 986
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 987
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 988
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 989
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 990
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 991
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 992
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 993
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 994
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 995
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 996
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 997
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 998
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 999
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1000
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1001
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1002
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1003
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1004
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1005
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1006
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1007
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>breakstat</span> (LexState <span style=color:#f92672>*</span>ls) {
  FuncState <span style=color:#f92672>*</span>fs <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>fs;
  BlockCnt <span style=color:#f92672>*</span>bl <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>bl;
  <span style=color:#66d9ef>int</span> upval <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>while</span> (bl <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>bl<span style=color:#f92672>-&gt;</span>isbreakable) {
    upval <span style=color:#f92672>|=</span> bl<span style=color:#f92672>-&gt;</span>upval;
    bl <span style=color:#f92672>=</span> bl<span style=color:#f92672>-&gt;</span>previous;
  }
  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>bl)
    luaX_syntaxerror(ls, <span style=color:#e6db74>&#34;no loop to break&#34;</span>);
  <span style=color:#66d9ef>if</span> (upval)
    luaK_codeABC(fs, OP_CLOSE, bl<span style=color:#f92672>-&gt;</span>nactvar, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
  luaK_concat(fs, <span style=color:#f92672>&amp;</span>bl<span style=color:#f92672>-&gt;</span>breaklist, luaK_jump(fs));
}


<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>whilestat</span> (LexState <span style=color:#f92672>*</span>ls, <span style=color:#66d9ef>int</span> line) {
  <span style=color:#75715e>/* whilestat -&gt; WHILE cond DO block END */</span>
  FuncState <span style=color:#f92672>*</span>fs <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>fs;
  <span style=color:#66d9ef>int</span> whileinit;
  <span style=color:#66d9ef>int</span> condexit;
  BlockCnt bl;
  luaX_next(ls);  <span style=color:#75715e>/* skip WHILE */</span>
  whileinit <span style=color:#f92672>=</span> luaK_getlabel(fs);
  condexit <span style=color:#f92672>=</span> cond(ls);
  enterblock(fs, <span style=color:#f92672>&amp;</span>bl, <span style=color:#ae81ff>1</span>);
  checknext(ls, TK_DO);
  block(ls);
  luaK_patchlist(fs, luaK_jump(fs), whileinit);
  check_match(ls, TK_END, TK_WHILE, line);
  leaveblock(fs);
  luaK_patchtohere(fs, condexit);  <span style=color:#75715e>/* false conditions finish the loop */</span>
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 44</span>:
lparser.c</div><p>line 1000，调用 enterblock 新建了 <code>breakable = 1</code> 的 BlockCnt，</p><p>line 979，break 语句不断向上层的 BlockCnt 检测是否存在 breakable 的 BlockCnt，
不然就提示语法错误，no loop to break。（直到代码生成时，才检测出这个语法错误）</p><p>找到相应的 BlockCnt 之后，line 987 将 break 生成的 jmp 指令链接到 bl->breaklist 上，</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">296
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">297
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">298
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">299
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">300
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">301
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">302
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">303
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">304
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">305
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">306
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">307
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>leaveblock</span> (FuncState <span style=color:#f92672>*</span>fs) {
  BlockCnt <span style=color:#f92672>*</span>bl <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>bl;
  fs<span style=color:#f92672>-&gt;</span>bl <span style=color:#f92672>=</span> bl<span style=color:#f92672>-&gt;</span>previous;
  removevars(fs<span style=color:#f92672>-&gt;</span>ls, bl<span style=color:#f92672>-&gt;</span>nactvar);
  <span style=color:#66d9ef>if</span> (bl<span style=color:#f92672>-&gt;</span>upval)
    luaK_codeABC(fs, OP_CLOSE, bl<span style=color:#f92672>-&gt;</span>nactvar, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
  <span style=color:#75715e>/* a block either controls scope or breaks (never both) */</span>
  lua_assert(<span style=color:#f92672>!</span>bl<span style=color:#f92672>-&gt;</span>isbreakable <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>bl<span style=color:#f92672>-&gt;</span>upval);
  lua_assert(bl<span style=color:#f92672>-&gt;</span>nactvar <span style=color:#f92672>==</span> fs<span style=color:#f92672>-&gt;</span>nactvar);
  fs<span style=color:#f92672>-&gt;</span>freereg <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>nactvar;  <span style=color:#75715e>/* free registers */</span>
  luaK_patchtohere(fs, bl<span style=color:#f92672>-&gt;</span>breaklist);
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 45</span>:
lparser.c</div><p>最终在 line 1005 leaveblock 的时候，line 306 将 bl->breaklist 上的 jmp 重定位。</p><h3 id=for>for
<a class=anchor href=#for>#</a></h3><p>repeat 循环和 while 循环非常相似，主要是通过 jmp 来实现的。
而 for 循环很特殊，用专门的指令来实现。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bnf data-lang=bnf>forstat      <span style=color:#f92672>::=</span> FOR (fornum | forlist) END
fornum       <span style=color:#f92672>::=</span> NAME = expr `,&#39; expr [`,&#39; expr] forbody
forlist      <span style=color:#f92672>::=</span> NAME {`,&#39; NAME} IN explist forbody
forbody      <span style=color:#f92672>::=</span> DO block
</code></pre></div><p>for 语句分为两种，一种只用于数字迭代的 fornum，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>for</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>2</span> <span style=color:#66d9ef>do</span>

<span style=color:#66d9ef>end</span>
</code></pre></div><p>另一种通用迭代 forlist，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>for</span> k, v <span style=color:#66d9ef>in</span> pairs(t) <span style=color:#66d9ef>do</span>

<span style=color:#66d9ef>end</span>
</code></pre></div><p>两种用法在底层使用不同的指令来实现。</p><h4 id=fornum>fornum
<a class=anchor href=#fornum>#</a></h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bnf data-lang=bnf>fornum       <span style=color:#f92672>::=</span> NAME = expr `,&#39; expr [`,&#39; expr] forbody
forbody      <span style=color:#f92672>::=</span> DO block
</code></pre></div><p><code>=</code> 后的 3 个表达式对应循环变量的初始值，目标值和间隔值，间隔值默认为 1。</p><p>分析如下代码，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>

<span style=color:#66d9ef>for</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>2</span> <span style=color:#66d9ef>do</span>
   a <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
<span style=color:#66d9ef>end</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 5 stacks
.function  0 0 2 5
.local  &#34;a&#34;  ; 0
.local  &#34;(for index)&#34;  ; 1
.local  &#34;(for limit)&#34;  ; 2
.local  &#34;(for step)&#34;  ; 3
.local  &#34;i&#34;  ; 4
.const  0  ; 0
.const  1  ; 1
.const  10  ; 2
.const  2  ; 3
[1] loadk      0   0        ; 0
[2] loadk      1   1        ; 1
[3] loadk      2   2        ; 10
[4] loadk      3   3        ; 2
[5] forprep    1   1        ; to [7]
[6] add        0   0   257  ; 1
[7] forloop    1   -2       ; to [6] if loop
[8] return     0   1
; end of function
</code></pre></div><figure><img src=generator-fornum-0.png></figure><p>其中的生成模式也明确，先生成 forprep 做准备工作，跳转到 forloop，
之后分析 forbody，最终生成 fooloop，用于跳转到循环开始/结束循环。</p><p>根据 opcode 描述的语义，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>OP_FORPREP,/*	A sBx	R(A)-=R(A+2); pc+=sBx				*/

OP_FORLOOP,/*	A sBx	R(A)+=R(A+2);
			if R(A) &lt;?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }*/
</code></pre></div><p>forprep 先将循环变量减去间隔值，再跳转到 forloop。</p><p>而 forloop 将循环值加上间隔值，再和结束值对比，判断是否要跳出循环，
如果继续循环，则将循环值赋给循环变量；否则跳出循环。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1046
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1047
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1048
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1049
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1050
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1051
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1052
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1053
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1054
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1055
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1056
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1057
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1058
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1059
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1060
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1061
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1062
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1063
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1064
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1065
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1066
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1067
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1068
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1069
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1070
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1071
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1072
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1073
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1074
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1075
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1076
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1077
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1078
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1079
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1080
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1081
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1082
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1083
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1084
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1085
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1086
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>forbody</span> (LexState <span style=color:#f92672>*</span>ls, <span style=color:#66d9ef>int</span> base, <span style=color:#66d9ef>int</span> line, <span style=color:#66d9ef>int</span> nvars, <span style=color:#66d9ef>int</span> isnum) {
  <span style=color:#75715e>/* forbody -&gt; DO block */</span>
  BlockCnt bl;
  FuncState <span style=color:#f92672>*</span>fs <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>fs;
  <span style=color:#66d9ef>int</span> prep, endfor;
  adjustlocalvars(ls, <span style=color:#ae81ff>3</span>);  <span style=color:#75715e>/* control variables */</span>
  checknext(ls, TK_DO);
  prep <span style=color:#f92672>=</span> isnum <span style=color:#f92672>?</span> luaK_codeAsBx(fs, OP_FORPREP, base, NO_JUMP) <span style=color:#f92672>:</span> luaK_jump(fs);
  enterblock(fs, <span style=color:#f92672>&amp;</span>bl, <span style=color:#ae81ff>0</span>);  <span style=color:#75715e>/* scope for declared variables */</span>
  adjustlocalvars(ls, nvars);
  luaK_reserveregs(fs, nvars);
  block(ls);
  leaveblock(fs);  <span style=color:#75715e>/* end of scope for declared variables */</span>
  luaK_patchtohere(fs, prep);
  endfor <span style=color:#f92672>=</span> (isnum) <span style=color:#f92672>?</span> luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP) <span style=color:#f92672>:</span>
		     luaK_codeABC(fs, OP_TFORLOOP, base, <span style=color:#ae81ff>0</span>, nvars);
  luaK_fixline(fs, line);  <span style=color:#75715e>/* pretend that `OP_FOR&#39; starts the loop */</span>
  luaK_patchlist(fs, (isnum <span style=color:#f92672>?</span> endfor : luaK_jump(fs)), prep <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
}


<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>fornum</span> (LexState <span style=color:#f92672>*</span>ls, TString <span style=color:#f92672>*</span>varname, <span style=color:#66d9ef>int</span> line) {
  <span style=color:#75715e>/* fornum -&gt; NAME = exp1,exp1[,exp1] forbody */</span>
  FuncState <span style=color:#f92672>*</span>fs <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>fs;
  <span style=color:#66d9ef>int</span> base <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>freereg;
  new_localvarliteral(ls, <span style=color:#e6db74>&#34;(for index)&#34;</span>, <span style=color:#ae81ff>0</span>);
  new_localvarliteral(ls, <span style=color:#e6db74>&#34;(for limit)&#34;</span>, <span style=color:#ae81ff>1</span>);
  new_localvarliteral(ls, <span style=color:#e6db74>&#34;(for step)&#34;</span>, <span style=color:#ae81ff>2</span>);
  new_localvar(ls, varname, <span style=color:#ae81ff>3</span>);
  checknext(ls, <span style=color:#e6db74>&#39;=&#39;</span>);
  exp1(ls);  <span style=color:#75715e>/* initial value */</span>
  checknext(ls, <span style=color:#e6db74>&#39;,&#39;</span>);
  exp1(ls);  <span style=color:#75715e>/* limit */</span>
  <span style=color:#66d9ef>if</span> (testnext(ls, <span style=color:#e6db74>&#39;,&#39;</span>))
    exp1(ls);  <span style=color:#75715e>/* optional step */</span>
  <span style=color:#66d9ef>else</span> {  <span style=color:#75715e>/* default step = 1 */</span>
    luaK_codeABx(fs, OP_LOADK, fs<span style=color:#f92672>-&gt;</span>freereg, luaK_numberK(fs, <span style=color:#ae81ff>1</span>));
    luaK_reserveregs(fs, <span style=color:#ae81ff>1</span>);
  }
  forbody(ls, base, line, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 46</span>:
lparser.c</div><p>生成的过程并不难理解，值得关注的是变量部分。</p><p>在 local 表中隐式生成了 3 个变量，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>.local  &#34;(for index)&#34;  ; 1
.local  &#34;(for limit)&#34;  ; 2
.local  &#34;(for step)&#34;  ; 3
</code></pre></div><p>分别对应初始值，结束值和间隔值，变量都加了 ()，所以不会和 lua 代码中分析得到的变量名冲突。</p><p>在 fornum 语句整体分析的过程中，生成了 3 层 BlockCnt，</p><figure><img src=generator-fornum-3-blocks.png></figure><p>最外层 block 是在 forstat 中生成的， <code>breakable = 1</code> ，用于 break；</p><p>中间层 block 将隐式生成的变量 (for index) 之类和循环变量 i 分开；</p><p>最内层 block 用于 forbody block。</p><h4 id=forlist>forlist
<a class=anchor href=#forlist>#</a></h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bnf data-lang=bnf>forlist      <span style=color:#f92672>::=</span> NAME {`,&#39; NAME} IN explist forbody
forbody      <span style=color:#f92672>::=</span> DO block
</code></pre></div><p>forlist 用于迭代器循环，最常见的就是用 pairs 循环遍历 table。</p><p>分析如下示例，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>

<span style=color:#66d9ef>for</span> k, v <span style=color:#66d9ef>in</span> pairs({}) <span style=color:#66d9ef>do</span>
   a <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
<span style=color:#66d9ef>end</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 7 stacks
.function  0 0 2 7
.local  &#34;a&#34;  ; 0
.local  &#34;(for generator)&#34;  ; 1
.local  &#34;(for state)&#34;  ; 2
.local  &#34;(for control)&#34;  ; 3
.local  &#34;k&#34;  ; 4
.local  &#34;v&#34;  ; 5
.const  0  ; 0
.const  &#34;pairs&#34;  ; 1
.const  1  ; 2
[1] loadk      0   0        ; 0
[2] getglobal  1   1        ; pairs
[3] newtable   2   0   0    ; array=0, hash=0
[4] call       1   2   4
[5] jmp        1            ; to [7]
[6] add        0   0   258  ; 1
[7] tforloop   1       2    ; to [9] if exit
[8] jmp        -3           ; to [6]
[9] return     0   1
; end of function
</code></pre></div><figure><img src=generator-forlist-0.png></figure><p>forlist 的生成模式有些不同，先生成 jmp 跳转到 tforloop 指令，
而 tforloop 根据 opcode 的语义，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>OP_TFORLOOP,/*	A C	R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2));
                        if R(A+3) ~= nil then R(A+2)=R(A+3) else pc++	*/
</code></pre></div><p>判断为 true 时，正常执行下一条指令；为 false 时，执行 pc++，跳过下一条指令。
而下一条指令固定是 jmp，用于定位到 forbody 的开始。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1089
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1090
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1091
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1092
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1093
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1094
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1095
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1096
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1097
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1098
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1099
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1100
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1101
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1102
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1103
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1104
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1105
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1106
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1107
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1108
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1109
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>forlist</span> (LexState <span style=color:#f92672>*</span>ls, TString <span style=color:#f92672>*</span>indexname) {
  <span style=color:#75715e>/* forlist -&gt; NAME {,NAME} IN explist1 forbody */</span>
  FuncState <span style=color:#f92672>*</span>fs <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>fs;
  expdesc e;
  <span style=color:#66d9ef>int</span> nvars <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>int</span> line;
  <span style=color:#66d9ef>int</span> base <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>freereg;
  <span style=color:#75715e>/* create control variables */</span>
  new_localvarliteral(ls, <span style=color:#e6db74>&#34;(for generator)&#34;</span>, nvars<span style=color:#f92672>++</span>);
  new_localvarliteral(ls, <span style=color:#e6db74>&#34;(for state)&#34;</span>, nvars<span style=color:#f92672>++</span>);
  new_localvarliteral(ls, <span style=color:#e6db74>&#34;(for control)&#34;</span>, nvars<span style=color:#f92672>++</span>);
  <span style=color:#75715e>/* create declared variables */</span>
  new_localvar(ls, indexname, nvars<span style=color:#f92672>++</span>);
  <span style=color:#66d9ef>while</span> (testnext(ls, <span style=color:#e6db74>&#39;,&#39;</span>))
    new_localvar(ls, str_checkname(ls), nvars<span style=color:#f92672>++</span>);
  checknext(ls, TK_IN);
  line <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>linenumber;
  adjust_assign(ls, <span style=color:#ae81ff>3</span>, explist1(ls, <span style=color:#f92672>&amp;</span>e), <span style=color:#f92672>&amp;</span>e);
  luaK_checkstack(fs, <span style=color:#ae81ff>3</span>);  <span style=color:#75715e>/* extra space to call generator */</span>
  forbody(ls, base, line, nvars <span style=color:#f92672>-</span> <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>0</span>);
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 47</span>:
lparser.c</div><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1046
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1047
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1048
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1049
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1050
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1051
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1052
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1053
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1054
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1055
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1056
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1057
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1058
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1059
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1060
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1061
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1062
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1063
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1064
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>forbody</span> (LexState <span style=color:#f92672>*</span>ls, <span style=color:#66d9ef>int</span> base, <span style=color:#66d9ef>int</span> line, <span style=color:#66d9ef>int</span> nvars, <span style=color:#66d9ef>int</span> isnum) {
  <span style=color:#75715e>/* forbody -&gt; DO block */</span>
  BlockCnt bl;
  FuncState <span style=color:#f92672>*</span>fs <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>fs;
  <span style=color:#66d9ef>int</span> prep, endfor;
  adjustlocalvars(ls, <span style=color:#ae81ff>3</span>);  <span style=color:#75715e>/* control variables */</span>
  checknext(ls, TK_DO);
  prep <span style=color:#f92672>=</span> isnum <span style=color:#f92672>?</span> luaK_codeAsBx(fs, OP_FORPREP, base, NO_JUMP) <span style=color:#f92672>:</span> luaK_jump(fs);
  enterblock(fs, <span style=color:#f92672>&amp;</span>bl, <span style=color:#ae81ff>0</span>);  <span style=color:#75715e>/* scope for declared variables */</span>
  adjustlocalvars(ls, nvars);
  luaK_reserveregs(fs, nvars);
  block(ls);
  leaveblock(fs);  <span style=color:#75715e>/* end of scope for declared variables */</span>
  luaK_patchtohere(fs, prep);
  endfor <span style=color:#f92672>=</span> (isnum) <span style=color:#f92672>?</span> luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP) <span style=color:#f92672>:</span>
		     luaK_codeABC(fs, OP_TFORLOOP, base, <span style=color:#ae81ff>0</span>, nvars);
  luaK_fixline(fs, line);  <span style=color:#75715e>/* pretend that `OP_FOR&#39; starts the loop */</span>
  luaK_patchlist(fs, (isnum <span style=color:#f92672>?</span> endfor : luaK_jump(fs)), prep <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 48</span>:
lparser.c</div><p>其中同样隐式声明了 3 个变量，用于控制循环状态，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>.local  &#34;(for generator)&#34;  ; 1
.local  &#34;(for state)&#34;  ; 2
.local  &#34;(for control)&#34;  ; 3
</code></pre></div><h3 id=ret>ret
<a class=anchor href=#ret>#</a></h3><p>return 语句是非常直观的，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bnf data-lang=bnf>retstat      <span style=color:#f92672>::=</span> RETURN [explist]
</code></pre></div><p>用于从当前 closure 中返回，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>OP_RETURN,/*	A B	return R(A), ... ,R(A+B-2)	(see note)	*/
</code></pre></div><p>示例代码，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> a, b

<span style=color:#66d9ef>return</span> a, b
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 4 stacks
.function  0 0 2 4
.local  &#34;a&#34;  ; 0
.local  &#34;b&#34;  ; 1
[1] move       2   0
[2] move       3   1
[3] return     2   3
[4] return     0   1
; end of function
</code></pre></div><p>对应 retstat 过程，</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1238
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1239
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1240
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1241
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1242
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1243
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1244
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1245
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1246
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1247
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1248
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1249
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1250
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1251
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1252
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1253
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1254
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1255
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1256
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1257
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1258
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1259
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1260
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1261
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1262
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1263
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1264
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1265
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1266
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1267
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1268
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>retstat</span> (LexState <span style=color:#f92672>*</span>ls) {
  <span style=color:#75715e>/* stat -&gt; RETURN explist */</span>
  FuncState <span style=color:#f92672>*</span>fs <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>fs;
  expdesc e;
  <span style=color:#66d9ef>int</span> first, nret;  <span style=color:#75715e>/* registers with returned values */</span>
  luaX_next(ls);  <span style=color:#75715e>/* skip RETURN */</span>
  <span style=color:#66d9ef>if</span> (block_follow(ls<span style=color:#f92672>-&gt;</span>t.token) <span style=color:#f92672>||</span> ls<span style=color:#f92672>-&gt;</span>t.token <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;;&#39;</span>)
    first <span style=color:#f92672>=</span> nret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>/* return no values */</span>
  <span style=color:#66d9ef>else</span> {
    nret <span style=color:#f92672>=</span> explist1(ls, <span style=color:#f92672>&amp;</span>e);  <span style=color:#75715e>/* optional return values */</span>
    <span style=color:#66d9ef>if</span> (hasmultret(e.k)) {
      luaK_setmultret(fs, <span style=color:#f92672>&amp;</span>e);
      <span style=color:#66d9ef>if</span> (e.k <span style=color:#f92672>==</span> VCALL <span style=color:#f92672>&amp;&amp;</span> nret <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {  <span style=color:#75715e>/* tail call? */</span>
	SET_OPCODE(getcode(fs,<span style=color:#f92672>&amp;</span>e), OP_TAILCALL);
	lua_assert(GETARG_A(getcode(fs,<span style=color:#f92672>&amp;</span>e)) <span style=color:#f92672>==</span> fs<span style=color:#f92672>-&gt;</span>nactvar);
      }
      first <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>nactvar;
      nret <span style=color:#f92672>=</span> LUA_MULTRET;  <span style=color:#75715e>/* return all values */</span>
    }
    <span style=color:#66d9ef>else</span> {
      <span style=color:#66d9ef>if</span> (nret <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)  <span style=color:#75715e>/* only one single value? */</span>
	first <span style=color:#f92672>=</span> luaK_exp2anyreg(fs, <span style=color:#f92672>&amp;</span>e);
      <span style=color:#66d9ef>else</span> {
	luaK_exp2nextreg(fs, <span style=color:#f92672>&amp;</span>e);  <span style=color:#75715e>/* values must go to the `stack&#39; */</span>
	first <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>nactvar;  <span style=color:#75715e>/* return all `active&#39; values */</span>
	lua_assert(nret <span style=color:#f92672>==</span> fs<span style=color:#f92672>-&gt;</span>freereg <span style=color:#f92672>-</span> first);
      }
    }
  }
  luaK_ret(fs, first, nret);
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 49</span>:
lparser.c</div><p>在 line 1267 生成 return 指令。</p><h3 id=function-call>function call
<a class=anchor href=#function-call>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bnf data-lang=bnf>funccallstat <span style=color:#f92672>::=</span> prefixexp primaryexp (`:&#39; NAME funcargs | funcargs)
funcargs     <span style=color:#f92672>::=</span> `(&#39; [ explist ] `)&#39; | constructor | STRING
</code></pre></div><p>函数调用和函数定义不同。</p><p>假如函数定义接收 2 个参数，返回 1 个值，
而在函数调用时，可传递 3 个参数，不使用返回值。</p><p>至于多/少的参数/返回值怎么处理，取决于 vm，在 lua 中，如果多了则废弃，少了则补 nil。</p><p>比如如下示例，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>f</span>()
   <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
<span style=color:#66d9ef>end</span>

f(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 5 stacks
.function  0 0 2 5
.local  &#34;f&#34;  ; 0
.const  1  ; 0
.const  2  ; 1
.const  3  ; 2

  ; function [0] definition (level 2)
  ; 0 upvalues, 0 params, 0 is_vararg, 2 stacks
  .function  0 0 0 2
  .const  1  ; 0
  [1] loadk      0   0        ; 1
  [2] return     0   2
  [3] return     0   1
  ; end of function

[1] closure    0   0        ; 0 upvalues
[2] move       1   0
[3] loadk      2   0        ; 1
[4] loadk      3   1        ; 2
[5] loadk      4   2        ; 3
[6] call       1   4   1
[7] return     0   1
; end of function
</code></pre></div><p>哪怕函数定义不接收参数，返回 1 个值，在调用时，只根据调用语句的意愿，
传入 3 个参数，不要返回值。</p><figure><img src=generator-func-call.png></figure><p>根据 opcode 的语义，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>OP_CALL,/*	A B C	R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */
</code></pre></div><p>在调用前，先将函数压栈，其次紧随着传入的参数值；
调用后，将所有返回值，从调用函数处，向上覆盖。</p><p>示例因为不需要返回值，所以调用后，原来的函数加参数位置置为空。</p><p>call 指令生成过程参考 funcargs，</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">609
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">610
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">611
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">612
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">613
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">614
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">615
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">616
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">617
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">618
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">619
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">620
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">621
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">622
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">623
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">624
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">625
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">626
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">627
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">628
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">629
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">630
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">631
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">632
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">633
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">634
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">635
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">636
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">637
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">638
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">639
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">640
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">641
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">642
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">643
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">644
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">645
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">646
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">647
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">648
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">649
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">650
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">651
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">652
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">653
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">654
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">655
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>funcargs</span> (LexState <span style=color:#f92672>*</span>ls, expdesc <span style=color:#f92672>*</span>f) {
  FuncState <span style=color:#f92672>*</span>fs <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>fs;
  expdesc args;
  <span style=color:#66d9ef>int</span> base, nparams;
  <span style=color:#66d9ef>int</span> line <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>linenumber;
  <span style=color:#66d9ef>switch</span> (ls<span style=color:#f92672>-&gt;</span>t.token) {
    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;(&#39;</span><span style=color:#f92672>:</span> {  <span style=color:#75715e>/* funcargs -&gt; `(&#39; [ explist1 ] `)&#39; */</span>
      <span style=color:#66d9ef>if</span> (line <span style=color:#f92672>!=</span> ls<span style=color:#f92672>-&gt;</span>lastline)
	luaX_syntaxerror(ls,<span style=color:#e6db74>&#34;ambiguous syntax (function call x new statement)&#34;</span>);
      luaX_next(ls);
      <span style=color:#66d9ef>if</span> (ls<span style=color:#f92672>-&gt;</span>t.token <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;)&#39;</span>)  <span style=color:#75715e>/* arg list is empty? */</span>
	args.k <span style=color:#f92672>=</span> VVOID;
      <span style=color:#66d9ef>else</span> {
	explist1(ls, <span style=color:#f92672>&amp;</span>args);
	luaK_setmultret(fs, <span style=color:#f92672>&amp;</span>args);
      }
      check_match(ls, <span style=color:#e6db74>&#39;)&#39;</span>, <span style=color:#e6db74>&#39;(&#39;</span>, line);
      <span style=color:#66d9ef>break</span>;
    }
    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;{&#39;</span><span style=color:#f92672>:</span> {  <span style=color:#75715e>/* funcargs -&gt; constructor */</span>
      constructor(ls, <span style=color:#f92672>&amp;</span>args);
      <span style=color:#66d9ef>break</span>;
    }
    <span style=color:#66d9ef>case</span> TK_STRING: {  <span style=color:#75715e>/* funcargs -&gt; STRING */</span>
      codestring(ls, <span style=color:#f92672>&amp;</span>args, ls<span style=color:#f92672>-&gt;</span>t.seminfo.ts);
      luaX_next(ls);  <span style=color:#75715e>/* must use `seminfo&#39; before `next&#39; */</span>
      <span style=color:#66d9ef>break</span>;
    }
    <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span> {
      luaX_syntaxerror(ls, <span style=color:#e6db74>&#34;function arguments expected&#34;</span>);
      <span style=color:#66d9ef>return</span>;
    }
  }
  lua_assert(f<span style=color:#f92672>-&gt;</span>k <span style=color:#f92672>==</span> VNONRELOC);
  base <span style=color:#f92672>=</span> f<span style=color:#f92672>-&gt;</span>u.s.info;  <span style=color:#75715e>/* base register for call */</span>
  <span style=color:#66d9ef>if</span> (hasmultret(args.k))
    nparams <span style=color:#f92672>=</span> LUA_MULTRET;  <span style=color:#75715e>/* open call */</span>
  <span style=color:#66d9ef>else</span> {
    <span style=color:#66d9ef>if</span> (args.k <span style=color:#f92672>!=</span> VVOID)
      luaK_exp2nextreg(fs, <span style=color:#f92672>&amp;</span>args);  <span style=color:#75715e>/* close last argument */</span>
    nparams <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>freereg <span style=color:#f92672>-</span> (base<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>);
  }
  init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>));
  luaK_fixline(fs, line);
  fs<span style=color:#f92672>-&gt;</span>freereg <span style=color:#f92672>=</span> base<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;  <span style=color:#75715e>/* call remove function and arguments and leaves
</span><span style=color:#75715e>			    (unless changed) one result */</span>
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 50</span>:
lparser.c</div><p>计算参数的个数，line 651 生成 call 指令，返回值暂时用 1，根据上下文再进行后续的修正。</p><h4 id=self>self
<a class=anchor href=#self>#</a></h4><p>使用 <code>:</code> 的函数定义和调用方式，更多是出于一种便利，
作用就是将调用对象本身，默认当作第 1 个参数。</p><p>如下两种定义方式就是同义的，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> o <span style=color:#f92672>=</span> {}

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>f</span>(self)
  print(self)
<span style=color:#66d9ef>end</span>

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>o</span>:<span style=color:#a6e22e>g</span>()
  print(self)
<span style=color:#66d9ef>end</span>

o.f(o)

o:g()
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>table: 0x557b5c2091c0
table: 0x557b5c2091c0
</code></pre></div><p>分析示例，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> o <span style=color:#f92672>=</span> {}

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>o</span>:<span style=color:#a6e22e>f</span>()
<span style=color:#66d9ef>end</span>

o:f()
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 3 stacks
.function  0 0 2 3
.local  &#34;o&#34;  ; 0
.const  &#34;f&#34;  ; 0

; function [0] definition (level 2)
; 0 upvalues, 1 params, 0 is_vararg, 2 stacks
.function  0 1 0 2
.local  &#34;self&#34;  ; 0
[1] return     0   1
; end of function

[1] newtable   0   0   0    ; array=0, hash=0
[2] closure    1   0        ; 0 upvalues
[3] settable   0   256 1    ; &#34;f&#34;
[4] self       1   0   256  ; &#34;f&#34;
[5] call       1   2   1
[6] return     0   1
; end of function
</code></pre></div><p>self 指令生成在 call 指令之前，结合 self 指令的语义，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>OP_SELF,/*	A B C	R(A+1) := R(B); R(A) := R(B)[RK(C)]		*/
</code></pre></div><p>结合示例字节码，self 相当于在栈中布置了 o 和 f，方便 call 进行调用，</p><figure><img src=generator-self.png></figure><p>内部在 primaryexp 中调用 <code>luaK_self</code> 生成 self 指令，</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">690
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">691
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">692
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">693
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">694
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">695
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">696
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">697
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">698
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">699
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">700
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">701
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">702
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">703
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">704
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">705
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">706
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">707
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">708
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">709
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">710
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">711
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">712
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">713
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">714
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">715
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">716
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">717
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">718
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">719
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">720
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">721
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">722
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">723
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">724
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>primaryexp</span> (LexState <span style=color:#f92672>*</span>ls, expdesc <span style=color:#f92672>*</span>v) {
  <span style=color:#75715e>/* primaryexp -&gt;
</span><span style=color:#75715e>	prefixexp { `.&#39; NAME | `[&#39; exp `]&#39; | `:&#39; NAME funcargs | funcargs } */</span>
  FuncState <span style=color:#f92672>*</span>fs <span style=color:#f92672>=</span> ls<span style=color:#f92672>-&gt;</span>fs;
  prefixexp(ls, v);
  <span style=color:#66d9ef>for</span> (;;) {
    <span style=color:#66d9ef>switch</span> (ls<span style=color:#f92672>-&gt;</span>t.token) {
      <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;.&#39;</span><span style=color:#f92672>:</span> {  <span style=color:#75715e>/* field */</span>
	field(ls, v);
	<span style=color:#66d9ef>break</span>;
      }
      <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;[&#39;</span><span style=color:#f92672>:</span> {  <span style=color:#75715e>/* `[&#39; exp1 `]&#39; */</span>
	expdesc key;
	luaK_exp2anyreg(fs, v);
	yindex(ls, <span style=color:#f92672>&amp;</span>key);
	luaK_indexed(fs, v, <span style=color:#f92672>&amp;</span>key);
	<span style=color:#66d9ef>break</span>;
      }
      <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;:&#39;</span><span style=color:#f92672>:</span> {  <span style=color:#75715e>/* `:&#39; NAME funcargs */</span>
	expdesc key;
	luaX_next(ls);
	checkname(ls, <span style=color:#f92672>&amp;</span>key);
	luaK_self(fs, v, <span style=color:#f92672>&amp;</span>key);
	funcargs(ls, v);
	<span style=color:#66d9ef>break</span>;
      }
      <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;(&#39;</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>case</span> TK_STRING: <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;{&#39;</span><span style=color:#f92672>:</span> {  <span style=color:#75715e>/* funcargs */</span>
	luaK_exp2nextreg(fs, v);
	funcargs(ls, v);
	<span style=color:#66d9ef>break</span>;
      }
      <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>return</span>;
    }
  }
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 51</span>:
lparser.c</div><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">503
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">504
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">505
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">506
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">507
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">508
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">509
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">510
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">511
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">512
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">513
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>luaK_self</span> (FuncState <span style=color:#f92672>*</span>fs, expdesc <span style=color:#f92672>*</span>e, expdesc <span style=color:#f92672>*</span>key) {
  <span style=color:#66d9ef>int</span> func;
  luaK_exp2anyreg(fs, e);
  freeexp(fs, e);
  func <span style=color:#f92672>=</span> fs<span style=color:#f92672>-&gt;</span>freereg;
  luaK_reserveregs(fs, <span style=color:#ae81ff>2</span>);
  luaK_codeABC(fs, OP_SELF, func, e<span style=color:#f92672>-&gt;</span>u.s.info, luaK_exp2RK(fs, key));
  freeexp(fs, key);
  e<span style=color:#f92672>-&gt;</span>u.s.info <span style=color:#f92672>=</span> func;
  e<span style=color:#f92672>-&gt;</span>k <span style=color:#f92672>=</span> VNONRELOC;
}</code></pre></td></tr></table></div></div><div class=src-block-caption><span class=src-block-number>Code Snippet 52</span>:
lcode.c</div><h4 id=tailcall>tailcall
<a class=anchor href=#tailcall>#</a></h4><p>结合 return，存在种特殊形式的函数调用 tailcall。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#75715e>-- tail call</span>
<span style=color:#66d9ef>return</span> f()
<span style=color:#75715e>-- not tail call</span>
<span style=color:#66d9ef>return</span> a, b, f()
</code></pre></div><p>在 return 语句后，仅跟随单独的函数调用，这种形式称为尾调用，
在 vm 中可以进行栈优化，到 vm 章节再详细解释。</p><h2 id=practice>practice
<a class=anchor href=#practice>#</a></h2><p>这个章节的内容虽然很长，但还远远没有将所有功能描述完全。</p><p>其它值得研究的功能包括</p><ul><li>binop，二元运算<ul><li>arithmetic，算术运算，如何优先级</li><li>logic，逻辑运算，and or 短路逻辑</li></ul></li><li>table 字面量</li><li>repeat 语句</li><li>close，修改 upvalue 状态</li><li>etc</li></ul><p>希望读者可以自行结合代码示例探索。</p><table><thead><tr><th>文件</th><th>建议</th></tr></thead><tbody><tr><td>lparser.h</td><td>仔细阅读</td></tr><tr><td>lparser.c</td><td>仔细阅读</td></tr><tr><td>lcode.h</td><td>仔细阅读</td></tr><tr><td>lcode.c</td><td>仔细阅读</td></tr></tbody></table></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/DreamAndDead/lua-5.1-source-guide/commit/8c359ebae66c3a96c4a0c7ed6ba49ad52483055a title="最后修改者 DreamAndDead | February 23, 2021" target=_blank rel=noopener><img src=/lua-5.1-source-guide/svg/calendar.svg class=book-icon alt=Calendar>
<span>February 23, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/DreamAndDead/lua-5.1-source-guide/edit/master/site/content/docs/generator/index.md target=_blank rel=noopener><img src=/lua-5.1-source-guide/svg/edit.svg class=book-icon alt=Edit>
<span>编辑本页</span></a></div></div></footer><div class=book-comments><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"lua-book"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#function-vs-proto-vs-closure>function vs proto vs closure</a><ul><li><a href=#chunk>chunk</a></li><li><a href=#embeded>embeded</a></li><li><a href=#funcstate>FuncState</a></li><li><a href=#big-picture>big picture</a></li><li><a href=#funcstate-vs-proto>FuncState vs Proto</a></li></ul></li><li><a href=#generate>generate</a></li><li><a href=#key-concept>key concept</a><ul><li><a href=#variable>variable</a></li><li><a href=#register>register</a></li></ul></li><li><a href=#statement>statement</a><ul><li><a href=#tool>tool</a></li><li><a href=#local>local</a></li><li><a href=#expdesc>expdesc</a></li><li><a href=#assign>assign</a></li><li><a href=#function>function</a></li><li><a href=#do>do</a></li><li><a href=#if>if</a></li><li><a href=#while>while</a></li><li><a href=#for>for</a></li><li><a href=#ret>ret</a></li><li><a href=#function-call>function call</a></li></ul></li><li><a href=#practice>practice</a></li></ul></li></ul></nav></div></aside></main></body></html>