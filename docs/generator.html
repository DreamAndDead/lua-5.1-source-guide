<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2021-01-13 三 10:21 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>generator</title>
<meta name="generator" content="Org mode">
<meta name="author" content="DreamAndDead">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link id="theme" rel="stylesheet" type="text/css" href="htmlize.css">
<link rel="stylesheet" type="text/css" href="style.css">
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">generator</h1>
<p>
上一章尝试单独解析语法分析过程，本章关注具体的代码生成过程。
</p>


<div id="orgcfe442c" class="figure">
<p><img src="generator-feature.png" alt="generator-feature.png">
</p>
</div>

<div id="outline-container-org85a1b1a" class="outline-2">
<h2 id="org85a1b1a"><span class="section-number-2">1</span> function vs proto vs closure</h2>
<div class="outline-text-2" id="text-1">
<p>
在具体深入代码生成之前，先来区分三个概念，function proto 和 closure。
</p>

<p>
function，是 lua 语言中定义的概念，是 8 种基础类型之一，表示函数，
具体在 lua 代码中用关键字 <code>function</code> 来定义。
</p>

<p>
如同 string 概念在底层由 TString 结构来实现一样，
function 在底层用 Proto 结构来实现，是 function 整体编译之后得到的同语义结构。
</p>

<p>
编译得到的 Proto 是静态的，在实际运行的时候，需要封装为 Closure 结构，交由 vm 来执行。
Closure 为 upvalue 分配了空间，并统一表示了 c function 和 lua function。
</p>

<p>
这也是为什么在 object 章节，提到基础类型对应的实现结构时，用 Closure 而不是用 Proto 来表示 function。
</p>

<p>
所以在编译时期，我们关注 Proto，而在运行时期，才关注 Closure。
</p>
</div>

<div id="outline-container-org3420d32" class="outline-3">
<h3 id="org3420d32"><span class="section-number-3">1.1</span> chunk</h3>
<div class="outline-text-3" id="text-1-1">
<p>
lua 内部使用了一种巧妙的实现，在编译时，将整个文件当做一个匿名 function 来对待。
相当于文件头加了 <code>function ()</code> ，文件尾加了 <code>end</code> 。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>lparser.c</label><pre class="src src-c"><span class="linenr">383: </span><span class="org-type">Proto</span> *<span class="org-function-name">luaY_parser</span> (<span class="org-type">lua_State</span> *<span class="org-variable-name">L</span>, <span class="org-type">ZIO</span> *<span class="org-variable-name">z</span>, <span class="org-type">Mbuffer</span> *<span class="org-variable-name">buff</span>, <span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">name</span>) {
<span class="linenr">384: </span>  <span class="org-keyword">struct</span> <span class="org-type">LexState</span> <span class="org-variable-name">lexstate</span>;
<span class="linenr">385: </span>  <span class="org-keyword">struct</span> <span class="org-type">FuncState</span> <span class="org-variable-name">funcstate</span>;
<span class="linenr">386: </span>  lexstate.buff = buff;
<span class="linenr">387: </span>  luaX_setinput(L, &amp;lexstate, z, luaS_new(L, name));
<span class="linenr">388: </span>  open_func(&amp;lexstate, &amp;funcstate);
<span class="linenr">389: </span>  funcstate.f-&gt;is_vararg = VARARG_ISVARARG;  <span class="org-comment-delimiter">/* </span><span class="org-comment">main func. is always vararg</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">390: </span>  luaX_next(&amp;lexstate);  <span class="org-comment-delimiter">/* </span><span class="org-comment">read first token</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">391: </span>  chunk(&amp;lexstate);
<span class="linenr">392: </span>  check(&amp;lexstate, TK_EOS);
<span class="linenr">393: </span>  close_func(&amp;lexstate);
<span class="linenr">394: </span>  lua_assert(funcstate.prev == <span class="org-constant">NULL</span>);
<span class="linenr">395: </span>  lua_assert(funcstate.f-&gt;nups == 0);
<span class="linenr">396: </span>  lua_assert(lexstate.fs == <span class="org-constant">NULL</span>);
<span class="linenr">397: </span>  <span class="org-keyword">return</span> funcstate.f;
<span class="linenr">398: </span>}
</pre>
</div>

<p>
可以看到， <code>luaY_parser</code> 读取文件，最终生成并返回 <code>Proto *</code> 。
</p>

<p>
因为整体分析的入口是 chunk，lua 又将文件当做匿名函数来对待，
这也是很多 lua 书籍中提到 chunk 的原因，表示文件编译得到的结果。
</p>
</div>
</div>

<div id="outline-container-org984e5f6" class="outline-3">
<h3 id="org984e5f6"><span class="section-number-3">1.2</span> embeded</h3>
<div class="outline-text-3" id="text-1-2">
<p>
如果按照 function 和 Proto 一一对应的关系，会出现函数层级的问题。
</p>

<p>
比如下面的示例代码，
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">function</span> <span class="org-function-name">a</span>()
   <span class="org-keyword">function</span> <span class="org-function-name">b</span>()
   <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

<span class="org-keyword">function</span> <span class="org-function-name">c</span>()
   <span class="org-keyword">function</span> <span class="org-function-name">d</span>()
   <span class="org-keyword">end</span>

   <span class="org-keyword">function</span> <span class="org-function-name">e</span>()
   <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
如果将 lua 代码文件看作 Proto chunk，代码中定义的 a b c d 同样是 function 且编译为 Proto。
但是 function a b c d e 是 lua 代码的一部分，所以其 Proto 也应该被包含在 Proto chunk 中。
</p>

<p>
lua 内部根据 function 定义的位置，来记录这种包含关系。
</p>


<div id="org40698e2" class="figure">
<p><img src="generator-function-level.png" alt="generator-function-level.png">
</p>
</div>

<p>
function a c 直接定义在代码文件（顶层匿名函数）中，
b d e 则直接定义在 a 和 c 中。
</p>


<div id="org1d727e0" class="figure">
<p><img src="generator-proto-level.png" alt="generator-proto-level.png">
</p>
</div>

<p>
Proto 结构中使用 struct Proto * 数组 p（Line 235）来记录其直接包含的 Proto。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>lobject.h</label><pre class="src src-C"><span class="linenr">228: </span><span class="org-comment-delimiter">/*</span>
<span class="linenr">229: </span><span class="org-comment">** Function Prototypes</span>
<span class="linenr">230: </span><span class="org-comment-delimiter">*/</span>
<span class="linenr">231: </span><span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">Proto</span> {
<span class="linenr">232: </span>  CommonHeader;
<span class="linenr">233: </span>  <span class="org-type">TValue</span> *<span class="org-variable-name">k</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">constants used by the function</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">234: </span>  <span class="org-type">Instruction</span> *<span class="org-variable-name">code</span>;
<span class="linenr">235: </span>  <span class="org-keyword">struct</span> <span class="org-type">Proto</span> **<span class="org-variable-name">p</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">functions defined inside the function</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">236: </span>  <span class="org-type">int</span> *<span class="org-variable-name">lineinfo</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">map from opcodes to source lines</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">237: </span>  <span class="org-keyword">struct</span> <span class="org-type">LocVar</span> *<span class="org-variable-name">locvars</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">information about local variables</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">238: </span>  <span class="org-type">TString</span> **<span class="org-variable-name">upvalues</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">upvalue names</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">239: </span>  <span class="org-type">TString</span>  *<span class="org-variable-name">source</span>;
<span class="linenr">240: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizeupvalues</span>;
<span class="linenr">241: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizek</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">size of `k'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">242: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizecode</span>;
<span class="linenr">243: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizelineinfo</span>;
<span class="linenr">244: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizep</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">size of `p'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">245: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizelocvars</span>;
<span class="linenr">246: </span>  <span class="org-type">int</span> <span class="org-variable-name">linedefined</span>;
<span class="linenr">247: </span>  <span class="org-type">int</span> <span class="org-variable-name">lastlinedefined</span>;
<span class="linenr">248: </span>  <span class="org-type">GCObject</span> *<span class="org-variable-name">gclist</span>;
<span class="linenr">249: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">nups</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">number of upvalues</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">250: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">numparams</span>;
<span class="linenr">251: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">is_vararg</span>;
<span class="linenr">252: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">maxstacksize</span>;
<span class="linenr">253: </span>} <span class="org-type">Proto</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org5b478ed" class="outline-3">
<h3 id="org5b478ed"><span class="section-number-3">1.3</span> FuncState</h3>
<div class="outline-text-3" id="text-1-3">
<p>
在 lua 的语法分析中，function 解析是一个重要的部分。
</p>

<p>
EBNF 和 regex 的区别在于，EBNF 可以描述一种递归过程，而 regex 则不能。
</p>

<p>
chunk 作为解析 function 的入口，得到 Proto，这个过程在遇到 function 定义时，不断的递归调用，生成 Proto，
并按照层级链接起来。
</p>

<p>
在了解这个过程之前，要先介绍另一个重要的结构 FuncState 。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>lparser.h</label><pre class="src src-c"><span class="linenr">57: </span><span class="org-comment-delimiter">/* </span><span class="org-comment">state needed to generate code for a given function</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">58: </span><span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">FuncState</span> {
<span class="linenr">59: </span>  <span class="org-type">Proto</span> *<span class="org-variable-name">f</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">current function header</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">60: </span>  <span class="org-type">Table</span> *<span class="org-variable-name">h</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">table to find (and reuse) elements in `k'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">61: </span>  <span class="org-keyword">struct</span> <span class="org-type">FuncState</span> *<span class="org-variable-name">prev</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">enclosing function</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">62: </span>  <span class="org-keyword">struct</span> <span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">lexical state</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">63: </span>  <span class="org-keyword">struct</span> <span class="org-type">lua_State</span> *<span class="org-variable-name">L</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">copy of the Lua state</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">64: </span>  <span class="org-keyword">struct</span> <span class="org-type">BlockCnt</span> *<span class="org-variable-name">bl</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">chain of current blocks</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">65: </span>  <span class="org-type">int</span> <span class="org-variable-name">pc</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">next position to code (equivalent to `ncode')</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">66: </span>  <span class="org-type">int</span> <span class="org-variable-name">lasttarget</span>;   <span class="org-comment-delimiter">/* </span><span class="org-comment">`pc' of last `jump target'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">67: </span>  <span class="org-type">int</span> <span class="org-variable-name">jpc</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">list of pending jumps to `pc'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">68: </span>  <span class="org-type">int</span> <span class="org-variable-name">freereg</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">first free register</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">69: </span>  <span class="org-type">int</span> <span class="org-variable-name">nk</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">number of elements in `k'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">70: </span>  <span class="org-type">int</span> <span class="org-variable-name">np</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">number of elements in `p'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">71: </span>  <span class="org-type">short</span> <span class="org-variable-name">nlocvars</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">number of elements in `locvars'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">72: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">nactvar</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">number of active local variables</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">73: </span>  <span class="org-type">upvaldesc</span> <span class="org-variable-name">upvalues</span>[LUAI_MAXUPVALUES];  <span class="org-comment-delimiter">/* </span><span class="org-comment">upvalues</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">74: </span>  <span class="org-type">unsigned</span> <span class="org-type">short</span> <span class="org-variable-name">actvar</span>[LUAI_MAXVARS];  <span class="org-comment-delimiter">/* </span><span class="org-comment">declared-variable stack</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">75: </span>} <span class="org-type">FuncState</span>;
</pre>
</div>

<p>
从名称可以看出，和 LexState 相似，也用于记录中间状态。
FuncState 用于记录 function 分析过程中的状态，和 function 定义一一对应，
每遇到一个 function 定义时，lua 都会新建一个 FuncState，记录当下解析 function 的中间状态。
</p>
</div>
</div>

<div id="outline-container-org6bc1c06" class="outline-3">
<h3 id="org6bc1c06"><span class="section-number-3">1.4</span> big picture</h3>
<div class="outline-text-3" id="text-1-4">
<p>
LexState FuncState Proto 这三者在分析过程中协同生成最终的 Proto。
</p>

<p>
比如解析如下示例代码，
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="linenr">1: </span><span class="org-keyword">function</span> <span class="org-function-name">a</span>()
<span class="linenr">2: </span>   <span class="org-keyword">function</span> <span class="org-function-name">b</span>()
<span class="linenr">3: </span>   <span class="org-keyword">end</span>
<span class="linenr">4: </span><span class="org-keyword">end</span>
</pre>
</div>

<p>
在整体文件分析开始之前，parser 已经准备好 FuncState，通过 LexState.ls 索引，
FuncState.f 指向相应要生成的 Proto。
</p>


<div id="orgaf05642" class="figure">
<p><img src="generator-big-picture-0.png" alt="generator-big-picture-0.png">
</p>
</div>

<p>
解析第 1 行之后，需要函数定义 a，parser 生成新的 FuncState，并更新 ls.fs 的指向。
同时，fs a 通过 prev 指向 fs chunk，表示层级关系。
</p>


<div id="orgb86e661" class="figure">
<p><img src="generator-big-picture-1.png" alt="generator-big-picture-1.png">
</p>
</div>


<p>
第 2 行，遇到函数 b 定义，同样的，生成 FuncState 并更新 ls.fs 的指向。
</p>


<div id="org3daf212" class="figure">
<p><img src="generator-big-picture-2.png" alt="generator-big-picture-2.png">
</p>
</div>

<p>
第 3 行，函数 b 定义结束，此时 ls.fs 指向 fs b 的 prev，回到上个函数定义层级。
并将函数 b 生成的 Proto 链接到上层函数 a 的 Proto。
</p>

<p>
此时，fs b 已经结束其作用。
</p>


<div id="orgb0a43a1" class="figure">
<p><img src="generator-big-picture-3.png" alt="generator-big-picture-3.png">
</p>
</div>


<div id="org5077cb5" class="figure">
<p><img src="generator-big-picture-4.png" alt="generator-big-picture-4.png">
</p>
</div>

<p>
第 4 行，函数 a 定义结束，同上，更新 ls.fs 指向，并链接 Proto a 到 Proto chunk。
</p>


<div id="org76b6556" class="figure">
<p><img src="generator-big-picture-5.png" alt="generator-big-picture-5.png">
</p>
</div>

<p>
最终返回 Proto chunk，ls 和 fs 都已经结束其使命，毕竟它们的作用只用于记录中间状态
</p>

<p>
在 parser 内部，上面描述的过程发生在 <code>open_func() close_func()</code> 中，读者可仔细体会其细节。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>lparser.c</label><pre class="src src-c"><span class="linenr">328: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">open_func</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>, <span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>) {
<span class="linenr">329: </span>  <span class="org-type">lua_State</span> *<span class="org-variable-name">L</span> = ls-&gt;L;
<span class="linenr">330: </span>  <span class="org-type">Proto</span> *<span class="org-variable-name">f</span> = luaF_newproto(L);
<span class="linenr">331: </span>  fs-&gt;f = f;
<span class="linenr">332: </span>  fs-&gt;prev = ls-&gt;fs;  <span class="org-comment-delimiter">/* </span><span class="org-comment">linked list of funcstates</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">333: </span>  fs-&gt;ls = ls;
<span class="linenr">334: </span>  fs-&gt;L = L;
<span class="linenr">335: </span>  ls-&gt;fs = fs;
<span class="linenr">336: </span>  fs-&gt;pc = 0;
<span class="linenr">337: </span>  fs-&gt;lasttarget = -1;
<span class="linenr">338: </span>  fs-&gt;jpc = NO_JUMP;
<span class="linenr">339: </span>  fs-&gt;freereg = 0;
<span class="linenr">340: </span>  fs-&gt;nk = 0;
<span class="linenr">341: </span>  fs-&gt;np = 0;
<span class="linenr">342: </span>  fs-&gt;nlocvars = 0;
<span class="linenr">343: </span>  fs-&gt;nactvar = 0;
<span class="linenr">344: </span>  fs-&gt;bl = <span class="org-constant">NULL</span>;
<span class="linenr">345: </span>  f-&gt;source = ls-&gt;source;
<span class="linenr">346: </span>  f-&gt;maxstacksize = 2;  <span class="org-comment-delimiter">/* </span><span class="org-comment">registers 0/1 are always valid</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">347: </span>  fs-&gt;h = luaH_new(L, 0, 0);
<span class="linenr">348: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">anchor table of constants and prototype (to avoid being collected)</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">349: </span>  sethvalue2s(L, L-&gt;top, fs-&gt;h);
<span class="linenr">350: </span>  incr_top(L);
<span class="linenr">351: </span>  setptvalue2s(L, L-&gt;top, f);
<span class="linenr">352: </span>  incr_top(L);
<span class="linenr">353: </span>}
<span class="linenr">354: </span>
<span class="linenr">355: </span>
<span class="linenr">356: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">close_func</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>) {
<span class="linenr">357: </span>  <span class="org-type">lua_State</span> *<span class="org-variable-name">L</span> = ls-&gt;L;
<span class="linenr">358: </span>  <span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span> = ls-&gt;fs;
<span class="linenr">359: </span>  <span class="org-type">Proto</span> *<span class="org-variable-name">f</span> = fs-&gt;f;
<span class="linenr">360: </span>  removevars(ls, 0);
<span class="linenr">361: </span>  luaK_ret(fs, 0, 0);  <span class="org-comment-delimiter">/* </span><span class="org-comment">final return</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">362: </span>  luaM_reallocvector(L, f-&gt;code, f-&gt;sizecode, fs-&gt;pc, Instruction);
<span class="linenr">363: </span>  f-&gt;sizecode = fs-&gt;pc;
<span class="linenr">364: </span>  luaM_reallocvector(L, f-&gt;lineinfo, f-&gt;sizelineinfo, fs-&gt;pc, <span class="org-type">int</span>);
<span class="linenr">365: </span>  f-&gt;sizelineinfo = fs-&gt;pc;
<span class="linenr">366: </span>  luaM_reallocvector(L, f-&gt;k, f-&gt;sizek, fs-&gt;nk, TValue);
<span class="linenr">367: </span>  f-&gt;sizek = fs-&gt;nk;
<span class="linenr">368: </span>  luaM_reallocvector(L, f-&gt;p, f-&gt;sizep, fs-&gt;np, <span class="org-type">Proto</span> *);
<span class="linenr">369: </span>  f-&gt;sizep = fs-&gt;np;
<span class="linenr">370: </span>  luaM_reallocvector(L, f-&gt;locvars, f-&gt;sizelocvars, fs-&gt;nlocvars, LocVar);
<span class="linenr">371: </span>  f-&gt;sizelocvars = fs-&gt;nlocvars;
<span class="linenr">372: </span>  luaM_reallocvector(L, f-&gt;upvalues, f-&gt;sizeupvalues, f-&gt;nups, <span class="org-type">TString</span> *);
<span class="linenr">373: </span>  f-&gt;sizeupvalues = f-&gt;nups;
<span class="linenr">374: </span>  lua_assert(luaG_checkcode(f));
<span class="linenr">375: </span>  lua_assert(fs-&gt;bl == <span class="org-constant">NULL</span>);
<span class="linenr">376: </span>  ls-&gt;fs = fs-&gt;prev;
<span class="linenr">377: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">last token read was anchored in defunct function; must reanchor it</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">378: </span>  <span class="org-keyword">if</span> (fs) anchor_token(ls);
<span class="linenr">379: </span>  L-&gt;top -= 2;  <span class="org-comment-delimiter">/* </span><span class="org-comment">remove table and prototype from the stack</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">380: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0321ec9" class="outline-3">
<h3 id="org0321ec9"><span class="section-number-3">1.5</span> FuncState vs Proto</h3>
<div class="outline-text-3" id="text-1-5">
<p>
FuncState 和 Proto 作为分析过程中两个最重要的结构，值得详细做一番了解。
</p>

<p>
仔细观察两个结构内部的字段，会发现两者之间有紧密的联系，界限很模糊，
都些许记录了分析过程的结果。
关键的差异在于，Proto 只保留最终结果，而 FuncState 记录中间状态。
</p>

<p>
对应这个原则，来详细探究下两个结构的内部。
</p>

<p>
先来看 Proto。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>lobject.h</label><pre class="src src-C"><span class="linenr">228: </span><span class="org-comment-delimiter">/*</span>
<span class="linenr">229: </span><span class="org-comment">** Function Prototypes</span>
<span class="linenr">230: </span><span class="org-comment-delimiter">*/</span>
<span class="linenr">231: </span><span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">Proto</span> {
<span class="linenr">232: </span>  CommonHeader;
<span class="linenr">233: </span>  <span class="org-type">TValue</span> *<span class="org-variable-name">k</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">constants used by the function</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">234: </span>  <span class="org-type">Instruction</span> *<span class="org-variable-name">code</span>;
<span class="linenr">235: </span>  <span class="org-keyword">struct</span> <span class="org-type">Proto</span> **<span class="org-variable-name">p</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">functions defined inside the function</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">236: </span>  <span class="org-type">int</span> *<span class="org-variable-name">lineinfo</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">map from opcodes to source lines</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">237: </span>  <span class="org-keyword">struct</span> <span class="org-type">LocVar</span> *<span class="org-variable-name">locvars</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">information about local variables</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">238: </span>  <span class="org-type">TString</span> **<span class="org-variable-name">upvalues</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">upvalue names</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">239: </span>  <span class="org-type">TString</span>  *<span class="org-variable-name">source</span>;
<span class="linenr">240: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizeupvalues</span>;
<span class="linenr">241: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizek</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">size of `k'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">242: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizecode</span>;
<span class="linenr">243: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizelineinfo</span>;
<span class="linenr">244: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizep</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">size of `p'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">245: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizelocvars</span>;
<span class="linenr">246: </span>  <span class="org-type">int</span> <span class="org-variable-name">linedefined</span>;
<span class="linenr">247: </span>  <span class="org-type">int</span> <span class="org-variable-name">lastlinedefined</span>;
<span class="linenr">248: </span>  <span class="org-type">GCObject</span> *<span class="org-variable-name">gclist</span>;
<span class="linenr">249: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">nups</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">number of upvalues</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">250: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">numparams</span>;
<span class="linenr">251: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">is_vararg</span>;
<span class="linenr">252: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">maxstacksize</span>;
<span class="linenr">253: </span>} <span class="org-type">Proto</span>;
</pre>
</div>

<p>
其中字段分为 3 部分来看
</p>

<p>
暂不讨论
</p>
<ul class="org-ul">
<li><code>int *lineinfo</code></li>
<li><code>TString *source</code></li>
<li><code>int linedefined</code></li>
<li><code>int lastlinedefined</code></li>
<li><code>GCObject *gclist</code></li>
</ul>

<p>
元信息
</p>
<ul class="org-ul">
<li><code>lu_byte numparams</code> ，函数的固定参数个数</li>
<li><code>lu_byte is_vararg</code> ，函数的可变参数</li>
<li><code>lu_byte maxstacksize</code> ，函数运行时，最大使用的栈空间</li>
</ul>

<p>
数组结果
</p>
<ul class="org-ul">
<li><code>TValue *k</code> ，常量表</li>
<li><code>Instruction *code</code> ，字节码</li>
<li><code>struct Proto **p</code> ，内部其它函数定义</li>
<li><code>struct LocVar *locvars</code> ，局部变量信息</li>
<li><code>TString **upvalues</code> ，upvalue 信息</li>
<li>与 len size 相关的字段</li>
</ul>

<p>
对照之前对 vm 执行模型的讨论，code 和 k 就与之对应。
</p>

<p>
这里一个有意思的区别，在于 size 和 n。
</p>

<p>
上面提到的 5 个数组，都对应一个 size 字段，用于记录数组的大小。
同时，也对应一个 n 字段，用于记录当前数组已使用的大小（下一个空闲的位置）。
</p>

<p>
在分析的过程中，数组 size 值记录空间总长度，当空间不足时，会继续扩大分配。
而数组 n 值用于时刻标识下一个空闲索引，记录分析结果并自增，它的值比 size 小。
</p>

<p>
当最终分析结束时，将 n 值赋值给相应的 size 值，省略多余不用的空间，此时两者才会相同。
</p>

<p>
如此看来，n 值应该存放在 FuncState 中，但是存在例外的是 <code>lu_byte nups</code> 。
</p>


<div id="org40f7a49" class="figure">
<p><img src="generator-fcode.png" alt="generator-fcode.png">
</p>
</div>


<div id="org3d766db" class="figure">
<p><img src="generator-fk.png" alt="generator-fk.png">
</p>
</div>


<div id="org8b08d6f" class="figure">
<p><img src="generator-fp.png" alt="generator-fp.png">
</p>
</div>



<div id="orgbfc9a1f" class="figure">
<p><img src="generator-fupval.png" alt="generator-fupval.png">
</p>
</div>


<div id="org0d8a38a" class="figure">
<p><img src="generator-flocvars.png" alt="generator-flocvars.png">
</p>
</div>

<p>
相同的视角，来观察 FuncState。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span>lparser.h</label><pre class="src src-c"><span class="linenr">57: </span><span class="org-comment-delimiter">/* </span><span class="org-comment">state needed to generate code for a given function</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">58: </span><span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">FuncState</span> {
<span class="linenr">59: </span>  <span class="org-type">Proto</span> *<span class="org-variable-name">f</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">current function header</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">60: </span>  <span class="org-type">Table</span> *<span class="org-variable-name">h</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">table to find (and reuse) elements in `k'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">61: </span>  <span class="org-keyword">struct</span> <span class="org-type">FuncState</span> *<span class="org-variable-name">prev</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">enclosing function</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">62: </span>  <span class="org-keyword">struct</span> <span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">lexical state</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">63: </span>  <span class="org-keyword">struct</span> <span class="org-type">lua_State</span> *<span class="org-variable-name">L</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">copy of the Lua state</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">64: </span>  <span class="org-keyword">struct</span> <span class="org-type">BlockCnt</span> *<span class="org-variable-name">bl</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">chain of current blocks</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">65: </span>  <span class="org-type">int</span> <span class="org-variable-name">pc</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">next position to code (equivalent to `ncode')</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">66: </span>  <span class="org-type">int</span> <span class="org-variable-name">lasttarget</span>;   <span class="org-comment-delimiter">/* </span><span class="org-comment">`pc' of last `jump target'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">67: </span>  <span class="org-type">int</span> <span class="org-variable-name">jpc</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">list of pending jumps to `pc'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">68: </span>  <span class="org-type">int</span> <span class="org-variable-name">freereg</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">first free register</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">69: </span>  <span class="org-type">int</span> <span class="org-variable-name">nk</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">number of elements in `k'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">70: </span>  <span class="org-type">int</span> <span class="org-variable-name">np</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">number of elements in `p'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">71: </span>  <span class="org-type">short</span> <span class="org-variable-name">nlocvars</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">number of elements in `locvars'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">72: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">nactvar</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">number of active local variables</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">73: </span>  <span class="org-type">upvaldesc</span> <span class="org-variable-name">upvalues</span>[LUAI_MAXUPVALUES];  <span class="org-comment-delimiter">/* </span><span class="org-comment">upvalues</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">74: </span>  <span class="org-type">unsigned</span> <span class="org-type">short</span> <span class="org-variable-name">actvar</span>[LUAI_MAXVARS];  <span class="org-comment-delimiter">/* </span><span class="org-comment">declared-variable stack</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">75: </span>} <span class="org-type">FuncState</span>;
</pre>
</div>

<p>
暂不讨论
</p>
<ul class="org-ul">
<li><code>Proto *f</code></li>
<li><code>struct FuncState *prev</code></li>
<li><code>struct LexState *ls</code></li>
<li><code>struct lua_State *L</code></li>
</ul>

<p>
后续讨论
</p>
<ul class="org-ul">
<li><code>struct BlockCnt *bl</code></li>
<li><code>int lasttarget</code></li>
<li><code>int jpc</code></li>
<li><code>int freereg</code></li>
</ul>

<p>
中间结果
</p>
<ul class="org-ul">
<li><code>upvaldesc upvalues[LUAI_MAXUPVALUES]</code></li>
<li><code>unsigned short actvar[LUAI_MAXVARS]</code></li>
<li>其它 n 字段</li>
</ul>

<p>
两个数组是定长的，即 size 是固定的， <code>f-&gt;nups</code> <code>fs-&gt;nactvar</code> 用于对应其 n 字段。
</p>


<div id="orgcbfd174" class="figure">
<p><img src="generator-fsupval.png" alt="generator-fsupval.png">
</p>
</div>


<div id="orgf2d6c76" class="figure">
<p><img src="generator-fsactvar.png" alt="generator-fsactvar.png">
</p>
</div>

<p>
在编译过程中，所得到的结果会不断的存储入上述数组及其它字段中。
</p>
</div>
</div>
</div>

<div id="outline-container-orgda89633" class="outline-2">
<h2 id="orgda89633"><span class="section-number-2">2</span> generate</h2>
<div class="outline-text-2" id="text-2">
<p>
从某种角度看，编译过程就是规则间的同义转换过程。
</p>

<p>
代码生成，最终将符合语法规则的 lua 代码，生成为 vm 可执行的同义字节码，
这个过程是隐藏在语法分析下的艺术。
</p>

<p>
两个规则间可以进行同义转换的连接点，在于对 vm 的共识，
正因为编译器"懂得" vm，知晓字节码的格式与功能，知晓运行时的栈结构，
知晓 k 表 Gbl 表的读取方式，才能生成 vm 可执行的同义字节码。
</p>

<p>
这种共识贯穿在整个代码生成的过程中。
</p>

<p>
但是无论编译器如何了解 vm，编译时和运行时还是存在区别的。
代码生成时，只是想象存在一个假想的 vm，它在执行生成的所有结果。
</p>

<p>
所以代码生成这个过程是最为繁杂的，到 vm 真正运行时反而轻松了，只需要读指令，执行指令就可以了。
</p>

<p>
阅读代码生成相关的代码，笔者还没有精确地把握住其中的原理，只能提供几个原则给读者参考，
</p>
<ul class="org-ul">
<li>总体是语法制导翻译的过程</li>
<li>使用后缀方式的生成顺序，比如 a + b 按照 a b + 的顺序来转换生成</li>
<li>精确模拟 vm 的运行方式，包括栈运算，Gbl 表及其它</li>
</ul>

<p>
章节结束之后，读者可以多使用调试器分析示例代码，探索其中的奥妙。
</p>
</div>
</div>

<div id="outline-container-org64f28c2" class="outline-2">
<h2 id="org64f28c2"><span class="section-number-2">3</span> key concept</h2>
<div class="outline-text-2" id="text-3">
<p>
在仔细探索代码生成之前，先明确几个在生成过程中的重点。
</p>
</div>

<div id="outline-container-org3a7d0dc" class="outline-3">
<h3 id="org3a7d0dc"><span class="section-number-3">3.1</span> variable</h3>
<div class="outline-text-3" id="text-3-1">
<p>
从作用域来看，lua 中的变量有 3 类，分别为 <code>local upvalue global</code> ，
三者在底层的实现方式各不相同。
</p>
</div>

<div id="outline-container-org43bb332" class="outline-4">
<h4 id="org43bb332"><span class="section-number-4">3.1.1</span> local</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
local 变量的活动范围（active），开始于在作用域中出现的那一刻，一直到作用域结束，
而作用域是有明显的栈特性的，新开辟作用域时入栈，离开作用域时出栈。
</p>

<p>
在一个作用域内，local 变量按照声明顺序入栈，离开作用域时全部出栈，变为 inactive 状态。
</p>

<p>
利用这个特性，lua 在编译时，在 fs 中用 actvar 和 nactvar 时刻记录着当前 active local 变量的状态。
</p>

<p>
比如如下示例代码，
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">a</span>

<span class="org-keyword">do</span>
   <span class="org-keyword">local</span> <span class="org-variable-name">b</span>
   <span class="org-keyword">do</span>
      <span class="org-keyword">local</span> <span class="org-variable-name">c</span>
   <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

<span class="org-keyword">do</span>
   <span class="org-keyword">local</span> <span class="org-variable-name">d</span>
   <span class="org-keyword">do</span>
      <span class="org-keyword">local</span> <span class="org-variable-name">e</span>
   <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
在代码分析的不同时刻， <code>fs-&gt;actvar</code> 记录的栈状态是这样的，
</p>


<div id="org26a8659" class="figure">
<p><img src="generator-active-local-scope.png" alt="generator-active-local-scope.png">
</p>
</div>

<p>
上面只是粗略描述了 active local 变量的栈状态，而实际在 parser 内部，是通过两个数组来存储的。
</p>


<div id="orgafa5003" class="figure">
<p><img src="generator-actvar-locvars.png" alt="generator-actvar-locvars.png">
</p>
</div>

<p>
数组 <code>fs-&gt;actvar</code> 的元素是 <code>unsigned short</code> 类型，只用来记录变量的索引。
索引数组 <code>f-&gt;locvars</code> 中的元素，其中元素类型为 <code>struct LocVar *</code> 。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 7: </span>lobject.h</label><pre class="src src-c"><span class="linenr">262: </span><span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">LocVar</span> {
<span class="linenr">263: </span>  <span class="org-type">TString</span> *<span class="org-variable-name">varname</span>;
<span class="linenr">264: </span>  <span class="org-type">int</span> <span class="org-variable-name">startpc</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">first point where variable is active</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">265: </span>  <span class="org-type">int</span> <span class="org-variable-name">endpc</span>;    <span class="org-comment-delimiter">/* </span><span class="org-comment">first point where variable is dead</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">266: </span>} <span class="org-type">LocVar</span>;
</pre>
</div>

<p>
LocVar 主要记录变量的名字， <code>startpc endpc</code> 在字节码层面记录其活动范围。
</p>

<p>
宏 getlocvar 精确描述了图示过程。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 8: </span>lparser.c</label><pre class="src src-c"><span class="linenr">32: </span><span class="org-preprocessor">#define</span> <span class="org-function-name">getlocvar</span>(<span class="org-variable-name">fs</span>, <span class="org-variable-name">i</span>)        ((fs)-&gt;f-&gt;locvars[(fs)-&gt;actvar[i]])
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc9535ef" class="outline-4">
<h4 id="orgc9535ef"><span class="section-number-4">3.1.2</span> upvalue</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
upvalue 在本文翻译为上值，它即非 local，又不是 global。
直观从代码上看，即引用作用域之外的变量。
</p>

<p>
lua 将 function 作为基础类型之一，可以作为普通变量，参数，返回值，赋值，而四处流转。
又因为 local 变量的作用域限定于词法，这便是 upvalue 机制发挥作用的地方。
</p>

<p>
如下示例代码，
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-keyword">function</span> <span class="org-function-name">outer</span>()
   <span class="org-keyword">local</span> <span class="org-variable-name">a</span> = 0

   <span class="org-keyword">local</span> <span class="org-keyword">function</span> <span class="org-function-name">inner</span>()
      a = a + 1
      <span class="org-builtin">print</span>(a)
   <span class="org-keyword">end</span>

   inner()

   <span class="org-keyword">return</span> inner
<span class="org-keyword">end</span>

<span class="org-keyword">local</span> <span class="org-variable-name">f</span> = outer()

f()
f()
</pre>
</div>

<pre class="example">
1
2
3
</pre>


<p>
内部第 1 次调用 inner() 时，输出 1 。
当调用 outer()，将 inner 赋值与 f，调用两次 f() 得到 2 3 。
</p>

<p>
第 1 次调用 inner() 时，依然在 a 的作用域内，输出 1 是符合直觉的。
</p>

<p>
问题在于调用 f() 时，因为 a 只作用在 outer 的作用域，而 f 在 outer 作用域外部，
已经离开了 a 的作用域，这种情况下为何还可以访问 a ？
</p>

<p>
这便是闭包机制的由来，a 对于 inner 而言是 upvalue 类型。
这也是 lua 中为何 function 不是 function 而是 closure 的原因，function 及 upvalue 组成了 closure，
所有 func 在运行时都封装为 closure 来运行，其中重要的原因就在于单独分配 upvalue 空间并管理。
</p>

<p>
详细的说，第 1 次调用 inner() 时，local a 依然存活，称 upvalue a 为 open 状态。
当离开 outer() 作用域，upvalue a 为 close 状态。
</p>
</div>
</div>

<div id="outline-container-org36b0d80" class="outline-4">
<h4 id="org36b0d80"><span class="section-number-4">3.1.3</span> global</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
如果依然说，global 变量是除 local 变量和 upvalue 变量的变量，读者肯定不信服。
</p>

<p>
之所以存在 upvalue 和 global，隐含的一点是，在 lua 中外层变量对于内层是可见的，
既然是可见的，对于外层变量引用自然有一个查找的过程，变量类型正是在查找的过程中确定的。
</p>

<ul class="org-ul">
<li>在当前作用域中可以找到的，为 local 类型</li>
<li>在当前作用域之外的作用域可以找到的，为 upvalue 类型</li>
<li>所有作用域都无法找到的，为 global 类型</li>
</ul>

<p>
按照这个逻辑，顶层的 chunk 是没有 upvalue 的，在当前作用域中查找不到的变量，
只能是 global 类型。
</p>

<p>
setfenv 影响的就是函数的 global 环境，
设定不同的 global 表，可以影响内部对 global 的引用，
实现不同的运行效果，类似于封装成一个小沙盒，
</p>

<p>
比如如下代码，变量 a 对 outer inner 都是全局变量，所以全部修改都影响到 global a 的值。
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-keyword">function</span> <span class="org-function-name">outer</span>()
  a = 10

  <span class="org-keyword">local</span> <span class="org-keyword">function</span> <span class="org-function-name">inner</span>()
    a = a + 1
    <span class="org-keyword">return</span> a
  <span class="org-keyword">end</span>

  <span class="org-keyword">return</span> inner
<span class="org-keyword">end</span>

<span class="org-keyword">local</span> <span class="org-variable-name">f</span> = outer()

<span class="org-builtin">print</span>(f(), a)
<span class="org-builtin">print</span>(f(), a)
<span class="org-builtin">print</span>(f(), a)
</pre>
</div>

<pre class="example">
11	11
12	12
13	13
</pre>
</div>
</div>
</div>

<div id="outline-container-org817cea7" class="outline-3">
<h3 id="org817cea7"><span class="section-number-3">3.2</span> register</h3>
<div class="outline-text-3" id="text-3-2">
<p>
寄存器的主要作用是，存取 local 变量和存取中间结果。
</p>

<p>
寄存器在编译时是一个抽象的概念，没有具体的分配空间，编译器只知晓存在这块区域，
并且按照自己的需要来使用和调试。
</p>

<p>
而在实际运行时，寄存器存储在 vm 的栈中。
</p>
</div>
</div>
</div>


<div id="outline-container-orge88350e" class="outline-2">
<h2 id="orge88350e"><span class="section-number-2">4</span> statement</h2>
<div class="outline-text-2" id="text-4">
<p>
本节开始从实例具体分析代码生成的过程，和实例一起来探求其中的生成模式。
</p>

<p>
因为语法元素的递归性，其中的组合是无限的，所以本节只挑选讲解部分重要的“原子性”的部分，
至于各种组合的变数读者可自由探索。
</p>
</div>

<div id="outline-container-org0cad10c" class="outline-3">
<h3 id="org0cad10c"><span class="section-number-3">4.1</span> tool</h3>
<div class="outline-text-3" id="text-4-1">
<p>
在开始以实例为基础的探索之前，先详细介绍相应工具的使用。
</p>

<p>
以交互式启动 chunkspy，用于临时检验一些想法。
</p>

<pre class="example" id="orgce69bf0">
$ make spy
</pre>

<p>
分析特定 lua 文件，输出相应的编译结果。
</p>

<pre class="example" id="org2658303">
$ make -s inspect source=lua_file_path
</pre>

<p>
比如分析如下代码，
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">a</span> = 1
</pre>
</div>

<p>
会输出如下结果，
</p>

<pre class="example" id="org3077005">
<span class="linenr">1: </span>; function [0] definition (level 1)
<span class="linenr">2: </span>; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
<span class="linenr">3: </span>.function  0 0 2 2
<span class="linenr">4: </span>.local  "a"  ; 0
<span class="linenr">5: </span>.const  1  ; 0
<span class="linenr">6: </span>[1] loadk      0   0        ; 1
<span class="linenr">7: </span>[2] return     0   1      
<span class="linenr">8: </span>; end of function
</pre>

<p>
逐行来看，
</p>

<p>
line 1
</p>

<p>
level 1 指的是第一层级，即 chunk；
function [0] 表明是当前层级的第 1 个函数（以 0 开始索引）
</p>

<p>
line 2
</p>

<p>
函数有 0 个 upvalue，0 个参数，按 <code>0b010</code> 模式接收可变参数，需要分配栈容量 2。
</p>

<p>
line 3
</p>

<p>
意义和 line 2 相同，line 2 是 line 3 的注释
</p>

<p>
line 4 5
</p>

<p>
.local 列出所有局部变量的名称及索引，即 f-&gt;locvars 的内容
.const 列出 k 表的内容及索引
</p>

<p>
line 6 7
</p>

<p>
详细打印 f-&gt;code 指令，最终一行总是默认生成一条 return 指令
</p>

<p>
line 8
</p>

<p>
注释，表明 function 结束
</p>

<p>
读者结合 opcode 章节对各个指令功能的理解，不难理解 lua 代码和字节码的同义关系。
</p>
</div>
</div>

<div id="outline-container-org306ba26" class="outline-3">
<h3 id="org306ba26"><span class="section-number-3">4.2</span> local</h3>
<div class="outline-text-3" id="text-4-2">
<p>
先来观察 local 语句。
</p>

<p>
语法描述如下，
</p>

<div class="org-src-container">
<pre class="src src-bnf">stat      <span class="org-constant">::=</span> localstat
localstat <span class="org-constant">::=</span> LOCAL NAME {`,' NAME} [`=' explist]
localstat <span class="org-constant">::=</span> LOCAL FUNCTION NAME body
</pre>
</div>

<p>
localstat 可用于定义局部变量和局部函数。
</p>

<p>
函数部分到后面小节再讨论，对于局部变量，根据是否赋值可分为两种情况。
</p>
</div>

<div id="outline-container-org920841f" class="outline-4">
<h4 id="org920841f"><span class="section-number-4">4.2.1</span> no assignment</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
如下简单的代码示例，定义局部变量，无赋值，
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>, <span class="org-variable-name">c</span>
</pre>
</div>

<p>
分析得到如下结果，
</p>

<pre class="example" id="org0599b75">
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 3 stacks
.function  0 0 2 3
.local  "a"  ; 0
.local  "b"  ; 1
.local  "c"  ; 2
[1] return     0   1      
; end of function
</pre>

<p>
示例代码只是单纯进行了局部变量的声明，最终没有生成任何字节码。
</p>

<p>
分析的过程，就是递归向下的函数过程， <code>chunk -&gt; stat -&gt; localstat</code> 。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 9: </span>lparser.c</label><pre class="src src-C"><span class="linenr">1179: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">localstat</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>) {
<span class="linenr">1180: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">stat -&gt; LOCAL NAME {`,' NAME} [`=' explist1]</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1181: </span>  <span class="org-type">int</span> <span class="org-variable-name">nvars</span> = 0;
<span class="linenr">1182: </span>  <span class="org-type">int</span> <span class="org-variable-name">nexps</span>;
<span class="linenr">1183: </span>  <span class="org-type">expdesc</span> <span class="org-variable-name">e</span>;
<span class="linenr">1184: </span>  <span class="org-keyword">do</span> {
<span id="coderef-new_localvar" class="coderef-off"><span class="linenr">1185: </span>    new_localvar(ls, str_checkname(ls), nvars++);</span>
<span class="linenr">1186: </span>  } <span class="org-keyword">while</span> (testnext(ls, <span class="org-string">','</span>));
<span class="linenr">1187: </span>  <span class="org-keyword">if</span> (testnext(ls, <span class="org-string">'='</span>))
<span class="linenr">1188: </span>    nexps = explist1(ls, &amp;e);
<span class="linenr">1189: </span>  <span class="org-keyword">else</span> {
<span class="linenr">1190: </span>    e.k = VVOID;
<span class="linenr">1191: </span>    nexps = 0;
<span class="linenr">1192: </span>  }
<span class="linenr">1193: </span>  adjust_assign(ls, nvars, nexps, &amp;e);
<span class="linenr">1194: </span>  adjustlocalvars(ls, nvars);
<span class="linenr">1195: </span>}
</pre>
</div>

<p>
关键在于 <a href="#coderef-new_localvar" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-new_localvar');" onmouseout="CodeHighlightOff(this, 'coderef-new_localvar');">new<sub>localvar</sub></a> 函数，在循环中读入 a b c，并进行变量分析。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 10: </span>lparser.c</label><pre class="src src-C"><span class="linenr">160: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">new_localvar</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>, <span class="org-type">TString</span> *<span class="org-variable-name">name</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span>) {
<span class="linenr">161: </span>  <span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span> = ls-&gt;fs;
<span class="linenr">162: </span>  luaY_checklimit(fs, fs-&gt;nactvar+n+1, LUAI_MAXVARS, <span class="org-string">"local variables"</span>);
<span class="linenr">163: </span>  fs-&gt;actvar[fs-&gt;nactvar+n] = cast(<span class="org-type">unsigned</span> <span class="org-type">short</span>, registerlocalvar(ls, name));
<span class="linenr">164: </span>}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 11: </span>lparser.c</label><pre class="src src-C"><span class="linenr">143: </span><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">registerlocalvar</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>, <span class="org-type">TString</span> *<span class="org-variable-name">varname</span>) {
<span class="linenr">144: </span>  <span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span> = ls-&gt;fs;
<span class="linenr">145: </span>  <span class="org-type">Proto</span> *<span class="org-variable-name">f</span> = fs-&gt;f;
<span class="linenr">146: </span>  <span class="org-type">int</span> <span class="org-variable-name">oldsize</span> = f-&gt;sizelocvars;
<span class="linenr">147: </span>  luaM_growvector(ls-&gt;L, f-&gt;locvars, fs-&gt;nlocvars, f-&gt;sizelocvars,
<span class="linenr">148: </span>                  LocVar, SHRT_MAX, <span class="org-string">"too many local variables"</span>);
<span class="linenr">149: </span>  <span class="org-keyword">while</span> (oldsize &lt; f-&gt;sizelocvars) f-&gt;locvars[oldsize++].varname = <span class="org-constant">NULL</span>;
<span class="linenr">150: </span>  f-&gt;locvars[fs-&gt;nlocvars].varname = varname;
<span class="linenr">151: </span>  luaC_objbarrier(ls-&gt;L, f, varname);
<span class="linenr">152: </span>  <span class="org-keyword">return</span> fs-&gt;nlocvars++;
<span class="linenr">153: </span>}
</pre>
</div>

<p>
其中根据变量出现的顺序，依次使用 registerlocalvar 得到变量索引，再记录到 <code>fs-&gt;actvar</code> 中。
</p>

<p>
这就是前面讨论过的，局部变量的存储方式，使用 <code>fs-&gt;actvar</code> 记录索引， <code>f-&gt;locvars</code> 记录变量名称。
</p>


<div id="org9088193" class="figure">
<p><img src="generator-local-no-assign.png" alt="generator-local-no-assign.png">
</p>
</div>

<p>
<a href="#coderef-new_localvar" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-new_localvar');" onmouseout="CodeHighlightOff(this, 'coderef-new_localvar');">new<sub>locvar</sub></a> 完成的就是这个过程。
</p>

<p>
这也对应了 chunkspy 分析结果中的 .local 部分。
</p>
</div>
</div>

<div id="outline-container-org96bc860" class="outline-4">
<h4 id="org96bc860"><span class="section-number-4">4.2.2</span> with assignment</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
再来看 local 变量赋值的情况。
</p>

<p>
分析示例代码，得到如下结果，
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>, <span class="org-variable-name">c</span>, <span class="org-variable-name">d</span>, <span class="org-variable-name">e</span> = 10, <span class="org-string">"second"</span>, <span class="org-constant">nil</span>, <span class="org-constant">true</span>, <span class="org-constant">false</span>
</pre>
</div>

<pre class="example" id="orgb538e31">
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 5 stacks
.function  0 0 2 5
.local  "a"  ; 0
.local  "b"  ; 1
.local  "c"  ; 2
.local  "d"  ; 3
.local  "e"  ; 4
.const  10  ; 0
.const  "second"  ; 1
[1] loadk      0   0        ; 10
[2] loadk      1   1        ; "second"
[3] loadnil    2   2      
[4] loadbool   3   1   0    ; true
[5] loadbool   4   0   0    ; false
[6] return     0   1      
; end of function
</pre>

<p>
除了 .local 条目变多了，也增加了 .const 部分，意味着 k 表多出了 2 项记录。
</p>

<p>
依旧从 localstat 来分析，
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 12: </span>lparser.c</label><pre class="src src-C"><span class="linenr">1179: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">localstat</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>) {
<span class="linenr">1180: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">stat -&gt; LOCAL NAME {`,' NAME} [`=' explist1]</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1181: </span>  <span class="org-type">int</span> <span class="org-variable-name">nvars</span> = 0;
<span class="linenr">1182: </span>  <span class="org-type">int</span> <span class="org-variable-name">nexps</span>;
<span class="linenr">1183: </span>  <span class="org-type">expdesc</span> <span class="org-variable-name">e</span>;
<span class="linenr">1184: </span>  <span class="org-keyword">do</span> {
<span class="linenr">1185: </span>    new_localvar(ls, str_checkname(ls), nvars++);
<span class="linenr">1186: </span>  } <span class="org-keyword">while</span> (testnext(ls, <span class="org-string">','</span>));
<span class="linenr">1187: </span>  <span class="org-keyword">if</span> (testnext(ls, <span class="org-string">'='</span>))
<span id="coderef-localstat_explist" class="coderef-off"><span class="linenr">1188: </span>    nexps = explist1(ls, &amp;e);</span>
<span class="linenr">1189: </span>  <span class="org-keyword">else</span> {
<span class="linenr">1190: </span>    e.k = VVOID;
<span class="linenr">1191: </span>    nexps = 0;
<span class="linenr">1192: </span>  }
<span class="linenr">1193: </span>  adjust_assign(ls, nvars, nexps, &amp;e);
<span class="linenr">1194: </span>  adjustlocalvars(ls, nvars);
<span class="linenr">1195: </span>}
</pre>
</div>

<p>
在记录变量信息之后，遇到 <code>=</code> ，开始分析 <code>=</code> 后的 <a href="#coderef-localstat_explist" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-localstat_explist');" onmouseout="CodeHighlightOff(this, 'coderef-localstat_explist');">表达式列表</a> ，作为变量的赋值内容。
</p>

<p>
后面的表达式都是简单表达式，最终会调用 simpleexp 进行解析。
</p>

<div class="org-src-container">
<pre class="src src-bnf">explist      <span class="org-constant">::=</span> expr {`,' expr}
expr         <span class="org-constant">::=</span> subexpr
subexpr      <span class="org-constant">::=</span> (simpleexp <span class="org-warning">|</span> unop subexpr) {binop subexpr}

simpleexp    <span class="org-constant">::=</span> NUMBER <span class="org-warning">|</span> STRING <span class="org-warning">|</span> NIL <span class="org-warning">|</span> TRUE <span class="org-warning">|</span> FALSE <span class="org-warning">|</span> DOTS <span class="org-warning">|</span>
                 constructor <span class="org-warning">|</span> FUNCTION body <span class="org-warning">|</span> primaryexp
</pre>
</div>

<p>
下面有趣的地方来了，字节码和 k 表中的元素是何时生成的？
这就和代码生成的方式紧密相关了。
</p>

<p>
parser 模块中代码生成的强大在于，它是流式生成的。
意思即一边读入 token，分析状态，就直接生成代码！
</p>

<p>
从代码具体来看，
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="linenr">596: </span><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">explist1</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">v</span>) {
<span class="linenr">597: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">explist1 -&gt; expr { `,' expr }</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">598: </span>  <span class="org-type">int</span> <span class="org-variable-name">n</span> = 1;  <span class="org-comment-delimiter">/* </span><span class="org-comment">at least one expression</span><span class="org-comment-delimiter"> */</span>
<span id="coderef-fir_exp" class="coderef-off"><span class="linenr">599: </span>  expr(ls, v);</span>
<span class="linenr">600: </span>  <span class="org-keyword">while</span> (testnext(ls, <span class="org-string">','</span>)) {
<span id="coderef-fir_gen" class="coderef-off"><span class="linenr">601: </span>    luaK_exp2nextreg(ls-&gt;fs, v);</span>
<span id="coderef-sec_exp" class="coderef-off"><span class="linenr">602: </span>    expr(ls, v);</span>
<span class="linenr">603: </span>    n++;
<span class="linenr">604: </span>  }
<span class="linenr">605: </span>  <span class="org-keyword">return</span> n;
<span class="linenr">606: </span>}
</pre>
</div>

<p>
在<a href="#coderef-fir_exp" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-fir_exp');" onmouseout="CodeHighlightOff(this, 'coderef-fir_exp');">第 1 次分析表达式</a> 时，读入并分析了 10，并在 <a href="#coderef-sec_exp" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-sec_exp');" onmouseout="CodeHighlightOff(this, 'coderef-sec_exp');">第 2 次分析表达式 "second"</a> 之前，已经<a href="#coderef-fir_gen" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-fir_gen');" onmouseout="CodeHighlightOff(this, 'coderef-fir_gen');">生成代码并更新了 k 表</a>。
</p>

<p>
先来看 expr()，由于分析的是简单表达式，最终会调用 simpleexp 进行分析，
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="linenr">727: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">simpleexp</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">v</span>) {
<span class="linenr">728: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">simpleexp -&gt; NUMBER | STRING | NIL | true | false | ... |</span>
<span class="linenr">729: </span><span class="org-comment">                  constructor | FUNCTION body | primaryexp</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">730: </span>  <span class="org-keyword">switch</span> (ls-&gt;t.token) {
<span class="linenr">731: </span>    <span class="org-keyword">case</span> TK_NUMBER: {
<span class="linenr">732: </span>      init_exp(v, VKNUM, 0);
<span class="linenr">733: </span>      v-&gt;u.nval = ls-&gt;t.seminfo.r;
<span class="linenr">734: </span>      <span class="org-keyword">break</span>;
<span class="linenr">735: </span>    }
<span class="linenr">736: </span>    <span class="org-keyword">case</span> TK_STRING: {
<span class="linenr">737: </span>      codestring(ls, v, ls-&gt;t.seminfo.ts);
<span class="linenr">738: </span>      <span class="org-keyword">break</span>;
<span class="linenr">739: </span>    }
<span class="linenr">740: </span>    <span class="org-keyword">case</span> TK_NIL: {
<span class="linenr">741: </span>      init_exp(v, VNIL, 0);
<span class="linenr">742: </span>      <span class="org-keyword">break</span>;
<span class="linenr">743: </span>    }
<span class="linenr">744: </span>    <span class="org-keyword">case</span> TK_TRUE: {
<span class="linenr">745: </span>      init_exp(v, VTRUE, 0);
<span class="linenr">746: </span>      <span class="org-keyword">break</span>;
<span class="linenr">747: </span>    }
<span class="linenr">748: </span>    <span class="org-keyword">case</span> TK_FALSE: {
<span class="linenr">749: </span>      init_exp(v, VFALSE, 0);
<span class="linenr">750: </span>      <span class="org-keyword">break</span>;
<span class="linenr">751: </span>    }
<span class="linenr">752: </span>    <span class="org-keyword">case</span> TK_DOTS: {  <span class="org-comment-delimiter">/* </span><span class="org-comment">vararg</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">753: </span>      <span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span> = ls-&gt;fs;
<span class="linenr">754: </span>      check_condition(ls, fs-&gt;f-&gt;is_vararg,
<span class="linenr">755: </span>                      <span class="org-string">"cannot use "</span> LUA_QL(<span class="org-string">"..."</span>) <span class="org-string">" outside a vararg function"</span>);
<span class="linenr">756: </span>      fs-&gt;f-&gt;is_vararg &amp;= ~VARARG_NEEDSARG;  <span class="org-comment-delimiter">/* </span><span class="org-comment">don't need 'arg'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">757: </span>      init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 1, 0));
<span class="linenr">758: </span>      <span class="org-keyword">break</span>;
<span class="linenr">759: </span>    }
<span class="linenr">760: </span>    <span class="org-keyword">case</span> <span class="org-string">'{'</span>: {  <span class="org-comment-delimiter">/* </span><span class="org-comment">constructor</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">761: </span>      constructor(ls, v);
<span class="linenr">762: </span>      <span class="org-keyword">return</span>;
<span class="linenr">763: </span>    }
<span class="linenr">764: </span>    <span class="org-keyword">case</span> TK_FUNCTION: {
<span class="linenr">765: </span>      luaX_next(ls);
<span class="linenr">766: </span>      body(ls, v, 0, ls-&gt;linenumber);
<span class="linenr">767: </span>      <span class="org-keyword">return</span>;
<span class="linenr">768: </span>    }
<span class="linenr">769: </span>    <span class="org-keyword">default</span>: {
<span class="linenr">770: </span>      primaryexp(ls, v);
<span class="linenr">771: </span>      <span class="org-keyword">return</span>;
<span class="linenr">772: </span>    }
<span class="linenr">773: </span>  }
<span class="linenr">774: </span>  luaX_next(ls);
<span class="linenr">775: </span>}
</pre>
</div>

<p>
第 1 次分析 10 时，token 类型是 <code>TK_NUMBER</code> ，直接填充 expdesc 即可，
然后调用 luaK<sub>exp2nextreg</sub> 生成代码。
</p>

<p>
luaK<sub>exp2nextreg</sub> 是一个综合过程，由更基础的几个函数组成。
</p>

<p>
深入分析之前，先来补充之前 FuncState 未描述的一个字段，freereg。
</p>

<p>
字节码被 vm 运行时，vm 维持一个栈，来存放寄存器和中间结果。
编译器只知晓这个栈的存在，但是在编译时，这个栈并没有真实存在，
只能凭借想象去操作它。
</p>

<p>
freereg 就是用来记录栈顶的变量。
</p>

<p>
当存储新的寄存器值时，freereg 就会自增，为寄存器开出空间；
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 13: </span>lcode.c</label><pre class="src src-c"><span class="linenr">209: </span><span class="org-type">void</span> <span class="org-function-name">luaK_reserveregs</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span>) {
<span class="linenr">210: </span>  luaK_checkstack(fs, n);
<span class="linenr">211: </span>  fs-&gt;freereg += n;
<span class="linenr">212: </span>}
</pre>
</div>

<p>
相应的，如果寄存器不再使用，freereg 会自减，回收相应的空间。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 14: </span>lcode.c</label><pre class="src src-c"><span class="linenr">215: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">freereg</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">int</span> <span class="org-variable-name">reg</span>) {
<span class="linenr">216: </span>  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>ISK(reg) &amp;&amp; reg &gt;= fs-&gt;nactvar) {
<span class="linenr">217: </span>    fs-&gt;freereg--;
<span class="linenr">218: </span>    lua_assert(reg == fs-&gt;freereg);
<span class="linenr">219: </span>  }
<span class="linenr">220: </span>}
</pre>
</div>

<p>
从中可以看出，freereg 将栈分为两部分，在栈底为 local 变量保留空间（reg &gt;= fs-&gt;nactvar），
上层用于计算中间结果。
</p>


<div id="org667f59e" class="figure">
<p><img src="generator-freereg-stack.png" alt="generator-freereg-stack.png">
</p>
</div>


<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 15: </span>lcode.c</label><pre class="src src-c"><span class="linenr">414: </span><span class="org-type">void</span> <span class="org-function-name">luaK_exp2nextreg</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">e</span>) {
<span class="linenr">415: </span>  luaK_dischargevars(fs, e);
<span class="linenr">416: </span>  freeexp(fs, e);
<span class="linenr">417: </span>  luaK_reserveregs(fs, 1);
<span class="linenr">418: </span>  exp2reg(fs, e, fs-&gt;freereg - 1);
<span class="linenr">419: </span>}
</pre>
</div>

<p>
在 luaK<sub>exp2nextreg</sub> 中，先找出下一个可用的栈/寄存器空间，然后将表达式的值解析到寄存器中，
即生成字节码。
</p>

<p>
最终在 discharge2reg 函数生成相应指令 loadk。
</p>

<p>
这里出现了第二个重点，对 k 表的操作。
</p>

<p>
因为其类型为数字，所以调用的是 luaK<sub>numberK</sub>。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 16: </span>lcode.c</label><pre class="src src-c"><span class="linenr">229: </span><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">addk</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">TValue</span> *<span class="org-variable-name">k</span>, <span class="org-type">TValue</span> *<span class="org-variable-name">v</span>) {
<span class="linenr">230: </span>  <span class="org-type">lua_State</span> *<span class="org-variable-name">L</span> = fs-&gt;L;
<span class="linenr">231: </span>  <span class="org-type">TValue</span> *<span class="org-variable-name">idx</span> = luaH_set(L, fs-&gt;h, k);
<span class="linenr">232: </span>  <span class="org-type">Proto</span> *<span class="org-variable-name">f</span> = fs-&gt;f;
<span class="linenr">233: </span>  <span class="org-type">int</span> <span class="org-variable-name">oldsize</span> = f-&gt;sizek;
<span class="linenr">234: </span>  <span class="org-keyword">if</span> (ttisnumber(idx)) {
<span class="linenr">235: </span>    lua_assert(luaO_rawequalObj(&amp;fs-&gt;f-&gt;k[cast_int(nvalue(idx))], v));
<span class="linenr">236: </span>    <span class="org-keyword">return</span> cast_int(nvalue(idx));
<span class="linenr">237: </span>  }
<span class="linenr">238: </span>  <span class="org-keyword">else</span> {  <span class="org-comment-delimiter">/* </span><span class="org-comment">constant not found; create a new entry</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">239: </span>    setnvalue(idx, cast_num(fs-&gt;nk));
<span class="linenr">240: </span>    luaM_growvector(L, f-&gt;k, fs-&gt;nk, f-&gt;sizek, TValue,
<span class="linenr">241: </span>                    MAXARG_Bx, <span class="org-string">"constant table overflow"</span>);
<span class="linenr">242: </span>    <span class="org-keyword">while</span> (oldsize &lt; f-&gt;sizek) setnilvalue(&amp;f-&gt;k[oldsize++]);
<span class="linenr">243: </span>    setobj(L, &amp;f-&gt;k[fs-&gt;nk], v);
<span class="linenr">244: </span>    luaC_barrier(L, f, v);
<span class="linenr">245: </span>    <span class="org-keyword">return</span> fs-&gt;nk++;
<span class="linenr">246: </span>  }
<span class="linenr">247: </span>}
<span class="linenr">248: </span>
<span class="linenr">249: </span>
<span class="linenr">250: </span><span class="org-type">int</span> <span class="org-function-name">luaK_stringK</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">TString</span> *<span class="org-variable-name">s</span>) {
<span class="linenr">251: </span>  <span class="org-type">TValue</span> <span class="org-variable-name">o</span>;
<span class="linenr">252: </span>  setsvalue(fs-&gt;L, &amp;o, s);
<span class="linenr">253: </span>  <span class="org-keyword">return</span> addk(fs, &amp;o, &amp;o);
<span class="linenr">254: </span>}
<span class="linenr">255: </span>
<span class="linenr">256: </span>
<span class="linenr">257: </span><span class="org-type">int</span> <span class="org-function-name">luaK_numberK</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">lua_Number</span> <span class="org-variable-name">r</span>) {
<span class="linenr">258: </span>  <span class="org-type">TValue</span> <span class="org-variable-name">o</span>;
<span class="linenr">259: </span>  setnvalue(&amp;o, r);
<span class="linenr">260: </span>  <span class="org-keyword">return</span> addk(fs, &amp;o, &amp;o);
<span class="linenr">261: </span>}
<span class="linenr">262: </span>
<span class="linenr">263: </span>
<span class="linenr">264: </span><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">boolK</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span>) {
<span class="linenr">265: </span>  <span class="org-type">TValue</span> <span class="org-variable-name">o</span>;
<span class="linenr">266: </span>  setbvalue(&amp;o, b);
<span class="linenr">267: </span>  <span class="org-keyword">return</span> addk(fs, &amp;o, &amp;o);
<span class="linenr">268: </span>}
<span class="linenr">269: </span>
<span class="linenr">270: </span>
<span class="linenr">271: </span><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">nilK</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>) {
<span class="linenr">272: </span>  <span class="org-type">TValue</span> <span class="org-variable-name">k</span>, <span class="org-variable-name">v</span>;
<span class="linenr">273: </span>  setnilvalue(&amp;v);
<span class="linenr">274: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">cannot use nil as key; instead use table itself to represent nil</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">275: </span>  sethvalue(fs-&gt;L, &amp;k, fs-&gt;h);
<span class="linenr">276: </span>  <span class="org-keyword">return</span> addk(fs, &amp;k, &amp;v);
<span class="linenr">277: </span>}
</pre>
</div>

<p>
所有操作 k 表的方法，最终都使用 addk 操作，其作用也很简单，
在 k 表中搜索，如果存在，则直接返回相应索引，其中使用 table fs-&gt;h 做 k 表元素的反向索引，加快搜索过程；
若不存在，则自增，并返回相应的索引。
</p>


<div id="orgb9f0ac6" class="figure">
<p><img src="generator-numberk-10.png" alt="generator-numberk-10.png">
</p>
</div>

<p>
将数字 10 存储入 k 表之后，生成 loadk 指令，将 freereg 和 k 索引作为其操作数。
</p>

<p>
至此，parser 只读入了 token 10，便已经完成了操作 k 表，记录常数，并生成对应的指令，令人惊奇。
</p>

<p>
对于第 2 个表达式 "second"，在 simpleexp 时，提前调用 codestring 加入了 k 表，
将其作为 VK 类型来对待。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 17: </span>lparser.c</label><pre class="src src-c"><span class="linenr">133: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">codestring</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">e</span>, <span class="org-type">TString</span> *<span class="org-variable-name">s</span>) {
<span class="linenr">134: </span>  init_exp(e, VK, luaK_stringK(ls-&gt;fs, s));
<span class="linenr">135: </span>}
</pre>
</div>


<div id="org8c08852" class="figure">
<p><img src="generator-stringk-second.png" alt="generator-stringk-second.png">
</p>
</div>

<p>
同样的生成 loadk 指令。
</p>

<p>
回到 localstat()，前面对变量和表达式进行解析之后，记录了 <code>=</code> 两边的数量 nvars nexps，
<code>adjust_assign()</code> 进行左右数量的调整，多余的 var 空间置为 nil，多余的 exp 则省略。
</p>

<p>
最终调用 <code>adjustlocalvars()</code> 调整 fs-&gt;nactvar 的值。
</p>
</div>
</div>
</div>


<div id="outline-container-orgacae4b5" class="outline-3">
<h3 id="orgacae4b5"><span class="section-number-3">4.3</span> expdesc</h3>
<div class="outline-text-3" id="text-4-3">
<p>
从 localstat 的示例中，已经看到代码生成的逻辑是别具一格的。
</p>

<p>
结合递归下降，语法制导，后缀顺序，vm opcode 语义，得以以线性顺序生成字节码。
</p>

<p>
其中 expdesc 的作用是非常重要的，将一些属性附加到文法符号上，辅助代码生成过程。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 18: </span>lparser.h</label><pre class="src src-c"><span class="org-comment-delimiter">/*</span>
<span class="org-comment">** Expression descriptor</span>
<span class="org-comment-delimiter">*/</span>

<span class="org-keyword">typedef</span> <span class="org-keyword">enum</span> {
  <span class="org-variable-name">VVOID</span>,        <span class="org-comment-delimiter">/* </span><span class="org-comment">no value</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VNIL</span>,
  <span class="org-variable-name">VTRUE</span>,
  <span class="org-variable-name">VFALSE</span>,
  <span class="org-variable-name">VK</span>,           <span class="org-comment-delimiter">/* </span><span class="org-comment">info = index of constant in `k'</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VKNUM</span>,        <span class="org-comment-delimiter">/* </span><span class="org-comment">nval = numerical value</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VLOCAL</span>,       <span class="org-comment-delimiter">/* </span><span class="org-comment">info = local register</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VUPVAL</span>,       <span class="org-comment-delimiter">/* </span><span class="org-comment">info = index of upvalue in `upvalues'</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VGLOBAL</span>,      <span class="org-comment-delimiter">/* </span><span class="org-comment">info = index of table; aux = index of global name in `k'</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VINDEXED</span>,     <span class="org-comment-delimiter">/* </span><span class="org-comment">info = table register; aux = index register (or `k')</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VJMP</span>,         <span class="org-comment-delimiter">/* </span><span class="org-comment">info = instruction pc</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VRELOCABLE</span>,   <span class="org-comment-delimiter">/* </span><span class="org-comment">info = instruction pc</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VNONRELOC</span>,    <span class="org-comment-delimiter">/* </span><span class="org-comment">info = result register</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VCALL</span>,        <span class="org-comment-delimiter">/* </span><span class="org-comment">info = instruction pc</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VVARARG</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">info = instruction pc</span><span class="org-comment-delimiter"> */</span>
} <span class="org-type">expkind</span>;

<span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">expdesc</span> {
  <span class="org-type">expkind</span> <span class="org-variable-name">k</span>;
  <span class="org-keyword">union</span> {
    <span class="org-keyword">struct</span> { <span class="org-type">int</span> <span class="org-variable-name">info</span>, <span class="org-variable-name">aux</span>; } <span class="org-variable-name">s</span>;
    <span class="org-type">lua_Number</span> <span class="org-variable-name">nval</span>;
  } <span class="org-variable-name">u</span>;
  <span class="org-type">int</span> <span class="org-variable-name">t</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">patch list of `exit when true'</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">int</span> <span class="org-variable-name">f</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">patch list of `exit when false'</span><span class="org-comment-delimiter"> */</span>
} <span class="org-type">expdesc</span>;
</pre>
</div>

<p>
expdesc 用于记录 exp 表达式的相关信息。
</p>

<p>
和 token 类型类似，expdesc 内部有字段记录类型，其它字段记录附加信息。
</p>

<p>
所有类型用 enum expkind 表示，相应类型后的注释描述了对应其它字段需要记录的信息。
</p>

<p>
其中重点的函数是 discharge2reg 和 dischargevars，用于解析相应的 expdesc，生成代码并更新状态。
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">expkind</th>
<th scope="col" class="org-left">u</th>
<th scope="col" class="org-left">discharge</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">VVOID</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">VNIL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">生成指令 loadnil，重置为 VNONRELOC</td>
</tr>

<tr>
<td class="org-left">VTRUE</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">生成指令 loadbool，重置为 VNONRELOC</td>
</tr>

<tr>
<td class="org-left">VFALSE</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">生成指令 loadbool，重置为 VNONRELOC</td>
</tr>

<tr>
<td class="org-left">VK</td>
<td class="org-left">info 记录 k 表索引</td>
<td class="org-left">生成指令 loadk，重置为 VNONRELOC</td>
</tr>

<tr>
<td class="org-left">VKNUM</td>
<td class="org-left">nval 记录数值</td>
<td class="org-left">生成指令 loadk，重置为 VNONRELOC</td>
</tr>

<tr>
<td class="org-left">VLOCAL</td>
<td class="org-left">info 记录寄存器索引</td>
<td class="org-left">重置为 VNONRELOC</td>
</tr>

<tr>
<td class="org-left">VUPVAL</td>
<td class="org-left">info 记录 upvalues 数组中的索引</td>
<td class="org-left">生成指令 GETUPVAL, 重置为 VRELOCABLE，info 记录指令索引</td>
</tr>

<tr>
<td class="org-left">VGLOBAL</td>
<td class="org-left">info 全局表的索引，aux 全局名称的 k 表索引</td>
<td class="org-left">生成指令 GETGLOBAL, 重置为 VRELOCABLE，info 记录指令索引</td>
</tr>

<tr>
<td class="org-left">VINDEXED</td>
<td class="org-left">info table 所在寄存器的索引，aux 索引值的 RK 值</td>
<td class="org-left">生成指令 GETTABLE, 重置为 VRELOCABLE，info 记录指令索引</td>
</tr>

<tr>
<td class="org-left">VJMP</td>
<td class="org-left">info 当前指令索引</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">VRELOCABLE</td>
<td class="org-left">info 当前指令索引</td>
<td class="org-left">定位到指令位置，修改 A 参数为 reg</td>
</tr>

<tr>
<td class="org-left">VNONRELOC</td>
<td class="org-left">info 最终解析得到的寄存器位置</td>
<td class="org-left">如果当前寄存器位置与目标位置不同，则生成 move 指令；相同则什么都不做</td>
</tr>

<tr>
<td class="org-left">VCALL</td>
<td class="org-left">info 当前指令索引</td>
<td class="org-left">重置为 VNONRELOC，info 记录指令的 A 参数</td>
</tr>

<tr>
<td class="org-left">VVARARG</td>
<td class="org-left">info 当前指令索引</td>
<td class="org-left">重置为 VRELOCABLE</td>
</tr>
</tbody>
</table>

<p>
具体如此设计的原因及作用，还需要读者在不同情况下再尝试领会。
</p>
</div>
</div>

<div id="outline-container-org0b27cc4" class="outline-3">
<h3 id="org0b27cc4"><span class="section-number-3">4.4</span> assign</h3>
<div class="outline-text-3" id="text-4-4">
<p>
本节来探讨赋值语句
</p>

<div class="org-src-container">
<pre class="src src-bnf">stat         <span class="org-constant">::=</span> exprstat
exprstat     <span class="org-constant">::=</span> assignstat

assignstat   <span class="org-constant">::=</span> (prefixexp <span class="org-warning">|</span> primaryexp (`.' NAME <span class="org-warning">|</span> `[' expr `]')) assignment
assignment   <span class="org-constant">::=</span> `,' assignstat <span class="org-warning">|</span> `=' explist

primaryexp   <span class="org-constant">::=</span> prefixexp {`.' NAME <span class="org-warning">|</span> `[' expr `]' <span class="org-warning">|</span> `:' NAME funcargs <span class="org-warning">|</span> funcargs}
prefixexp    <span class="org-constant">::=</span> NAME <span class="org-warning">|</span> `(' expr `)'
</pre>
</div>

<p>
赋值语句根据变量的类型不同，分为 global upvalue local indexed 几种情况，
对应 expdesc 中的 VGLOBAL VUPVAL VLOCAL VINDEXED。
</p>
</div>

<div id="outline-container-orgf03ca87" class="outline-4">
<h4 id="orgf03ca87"><span class="section-number-4">4.4.1</span> global</h4>
<div class="outline-text-4" id="text-4-4-1">
<p>
先来看 global 的赋值情况。
</p>

<p>
分析如下代码，
</p>

<div class="org-src-container">
<pre class="src src-lua">a, b, c = 10, 20, 30
</pre>
</div>

<pre class="example" id="orgcb054f9">
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 3 stacks
.function  0 0 2 3
.const  "a"  ; 0
.const  "b"  ; 1
.const  "c"  ; 2
.const  10  ; 3
.const  20  ; 4
.const  30  ; 5
[1] loadk      0   3        ; 10
[2] loadk      1   4        ; 20
[3] loadk      2   5        ; 30
[4] setglobal  2   2        ; c
[5] setglobal  1   1        ; b
[6] setglobal  0   0        ; a
[7] return     0   1      
; end of function
</pre>

<p>
从 chunk 递归向下，最终到达 assignment 函数。
</p>

<p>
从 ebnf 描述中可以看出，assignment 是一个递归的过程。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 19: </span>lparser.c</label><pre class="src src-c"><span class="linenr">931: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">assignment</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>, <span class="org-keyword">struct</span> <span class="org-type">LHS_assign</span> *<span class="org-variable-name">lh</span>, <span class="org-type">int</span> <span class="org-variable-name">nvars</span>) {
<span class="linenr">932: </span>  <span class="org-type">expdesc</span> <span class="org-variable-name">e</span>;
<span class="linenr">933: </span>  check_condition(ls, VLOCAL &lt;= lh-&gt;v.k &amp;&amp; lh-&gt;v.k &lt;= VINDEXED,
<span class="linenr">934: </span>                      <span class="org-string">"syntax error"</span>);
<span class="linenr">935: </span>  <span class="org-keyword">if</span> (testnext(ls, <span class="org-string">','</span>)) {  <span class="org-comment-delimiter">/* </span><span class="org-comment">assignment -&gt; `,' primaryexp assignment</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">936: </span>    <span class="org-keyword">struct</span> <span class="org-type">LHS_assign</span> <span class="org-variable-name">nv</span>;
<span class="linenr">937: </span>    nv.prev = lh;
<span class="linenr">938: </span>    primaryexp(ls, &amp;nv.v);
<span class="linenr">939: </span>    <span class="org-keyword">if</span> (nv.v.k == VLOCAL)
<span class="linenr">940: </span>      check_conflict(ls, lh, &amp;nv.v);
<span class="linenr">941: </span>    luaY_checklimit(ls-&gt;fs, nvars, LUAI_MAXCCALLS - ls-&gt;L-&gt;nCcalls,
<span class="linenr">942: </span>                    <span class="org-string">"variables in assignment"</span>);
<span class="linenr">943: </span>    assignment(ls, &amp;nv, nvars+1);
<span class="linenr">944: </span>  }
<span class="linenr">945: </span>  <span class="org-keyword">else</span> {  <span class="org-comment-delimiter">/* </span><span class="org-comment">assignment -&gt; `=' explist1</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">946: </span>    <span class="org-type">int</span> <span class="org-variable-name">nexps</span>;
<span class="linenr">947: </span>    checknext(ls, <span class="org-string">'='</span>);
<span class="linenr">948: </span>    nexps = explist1(ls, &amp;e);
<span class="linenr">949: </span>    <span class="org-keyword">if</span> (nexps != nvars) {
<span class="linenr">950: </span>      adjust_assign(ls, nvars, nexps, &amp;e);
<span class="linenr">951: </span>      <span class="org-keyword">if</span> (nexps &gt; nvars)
<span class="linenr">952: </span>        ls-&gt;fs-&gt;freereg -= nexps - nvars;  <span class="org-comment-delimiter">/* </span><span class="org-comment">remove extra values</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">953: </span>    }
<span class="linenr">954: </span>    <span class="org-keyword">else</span> {
<span class="linenr">955: </span>      luaK_setoneret(ls-&gt;fs, &amp;e);  <span class="org-comment-delimiter">/* </span><span class="org-comment">close last expression</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">956: </span>      luaK_storevar(ls-&gt;fs, &amp;lh-&gt;v, &amp;e);
<span class="linenr">957: </span>      <span class="org-keyword">return</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">avoid default</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">958: </span>    }
<span class="linenr">959: </span>  }
<span class="linenr">960: </span>  init_exp(&amp;e, VNONRELOC, ls-&gt;fs-&gt;freereg-1);  <span class="org-comment-delimiter">/* </span><span class="org-comment">default assignment</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">961: </span>  luaK_storevar(ls-&gt;fs, &amp;lh-&gt;v, &amp;e);
<span class="linenr">962: </span>}
</pre>
</div>

<p>
在遇到 <code>=</code> 之前，执行 if 语句块，递归调用 primaryexp 分析变量；
遇到 <code>=</code> 之后，执行 else 语句块，分析表达式。
在递归的终点，将表达式得到的值赋值给变量。
</p>

<p>
因为示例代码中变量都很简单，primaryexp 主要调用 prefixexp 进行分析。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 20: </span>lparser.c</label><pre class="src src-c"><span class="linenr">667: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">prefixexp</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">v</span>) {
<span class="linenr">668: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">prefixexp -&gt; NAME | '(' expr ')'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">669: </span>  <span class="org-keyword">switch</span> (ls-&gt;t.token) {
<span class="linenr">670: </span>    <span class="org-keyword">case</span> <span class="org-string">'('</span>: {
<span class="linenr">671: </span>      <span class="org-type">int</span> <span class="org-variable-name">line</span> = ls-&gt;linenumber;
<span class="linenr">672: </span>      luaX_next(ls);
<span class="linenr">673: </span>      expr(ls, v);
<span class="linenr">674: </span>      check_match(ls, <span class="org-string">')'</span>, <span class="org-string">'('</span>, line);
<span class="linenr">675: </span>      luaK_dischargevars(ls-&gt;fs, v);
<span class="linenr">676: </span>      <span class="org-keyword">return</span>;
<span class="linenr">677: </span>    }
<span class="linenr">678: </span>    <span class="org-keyword">case</span> TK_NAME: {
<span class="linenr">679: </span>      singlevar(ls, v);
<span class="linenr">680: </span>      <span class="org-keyword">return</span>;
<span class="linenr">681: </span>    }
<span class="linenr">682: </span>    <span class="org-keyword">default</span>: {
<span class="linenr">683: </span>      luaX_syntaxerror(ls, <span class="org-string">"unexpected symbol"</span>);
<span class="linenr">684: </span>      <span class="org-keyword">return</span>;
<span class="linenr">685: </span>    }
<span class="linenr">686: </span>  }
<span class="linenr">687: </span>}
</pre>
</div>

<p>
对应其中的 <code>TK_NAME</code> 类型，调用 singlevar 确定变量的类型，内容调用 singlevaraux 来实现。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 21: </span>lparser.c</label><pre class="src src-c"><span class="linenr">224: </span><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">singlevaraux</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">TString</span> *<span class="org-variable-name">n</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">var</span>, <span class="org-type">int</span> <span class="org-variable-name">base</span>) {
<span class="linenr">225: </span>  <span class="org-keyword">if</span> (fs == <span class="org-constant">NULL</span>) {  <span class="org-comment-delimiter">/* </span><span class="org-comment">no more levels?</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">226: </span>    init_exp(var, VGLOBAL, NO_REG);  <span class="org-comment-delimiter">/* </span><span class="org-comment">default is global variable</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">227: </span>    <span class="org-keyword">return</span> VGLOBAL;
<span class="linenr">228: </span>  }
<span class="linenr">229: </span>  <span class="org-keyword">else</span> {
<span class="linenr">230: </span>    <span class="org-type">int</span> <span class="org-variable-name">v</span> = searchvar(fs, n);  <span class="org-comment-delimiter">/* </span><span class="org-comment">look up at current level</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">231: </span>    <span class="org-keyword">if</span> (v &gt;= 0) {
<span class="linenr">232: </span>      init_exp(var, VLOCAL, v);
<span class="linenr">233: </span>      <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>base)
<span class="linenr">234: </span>        markupval(fs, v);  <span class="org-comment-delimiter">/* </span><span class="org-comment">local will be used as an upval</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">235: </span>      <span class="org-keyword">return</span> VLOCAL;
<span class="linenr">236: </span>    }
<span class="linenr">237: </span>    <span class="org-keyword">else</span> {  <span class="org-comment-delimiter">/* </span><span class="org-comment">not found at current level; try upper one</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">238: </span>      <span class="org-keyword">if</span> (singlevaraux(fs-&gt;prev, n, var, 0) == VGLOBAL)
<span class="linenr">239: </span>        <span class="org-keyword">return</span> VGLOBAL;
<span class="linenr">240: </span>      var-&gt;u.s.info = indexupvalue(fs, n, var);  <span class="org-comment-delimiter">/* </span><span class="org-comment">else was LOCAL or UPVAL</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">241: </span>      var-&gt;k = VUPVAL;  <span class="org-comment-delimiter">/* </span><span class="org-comment">upvalue in this level</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">242: </span>      <span class="org-keyword">return</span> VUPVAL;
<span class="linenr">243: </span>    }
<span class="linenr">244: </span>  }
<span class="linenr">245: </span>}
<span class="linenr">246: </span>
<span class="linenr">247: </span>
<span class="linenr">248: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">singlevar</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">var</span>) {
<span class="linenr">249: </span>  <span class="org-type">TString</span> *<span class="org-variable-name">varname</span> = str_checkname(ls);
<span class="linenr">250: </span>  <span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span> = ls-&gt;fs;
<span class="linenr">251: </span>  <span class="org-keyword">if</span> (singlevaraux(fs, varname, var, 1) == VGLOBAL)
<span class="linenr">252: </span>    var-&gt;u.s.info = luaK_stringK(fs, varname);  <span class="org-comment-delimiter">/* </span><span class="org-comment">info points to global name</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">253: </span>}
</pre>
</div>

<p>
singlevaraux 是非常关键的过程，回忆之前在分析过程中，关于嵌套的 function 定义和 fs-&gt;prev 的链条，
singlevaraux 就顺着 fs-&gt;prev 不断向上层作用域寻找变量。
</p>

<p>
如果 <code>fs == NULL</code> ，说明已经到顶层，变量只能为 global 类型；
如果在当前作用域可找到，说明是 local 变量；其它为 upval 变量。
</p>

<p>
示例中 a b c 都为全局变量，所以 singlevaraux 返回 VGLOBAL，
将相应 expdesc 类型赋值为 VGLOBAL，且 info 存储了变量名对应的 k 表索引。
</p>

<p>
表达式分析阶段，将 10 20 30 加入 k 表，同时载入寄存器。
</p>

<p>
最终赋值阶段，在每个递归层次，用 luaK<sub>storevar</sub> 来存储。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 22: </span>lcode.c</label><pre class="src src-c"><span class="linenr">472: </span><span class="org-type">void</span> <span class="org-function-name">luaK_storevar</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">var</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">ex</span>) {
<span class="linenr">473: </span>  <span class="org-keyword">switch</span> (var-&gt;k) {
<span class="linenr">474: </span>    <span class="org-keyword">case</span> VLOCAL: {
<span class="linenr">475: </span>      freeexp(fs, ex);
<span class="linenr">476: </span>      exp2reg(fs, ex, var-&gt;u.s.info);
<span class="linenr">477: </span>      <span class="org-keyword">return</span>;
<span class="linenr">478: </span>    }
<span class="linenr">479: </span>    <span class="org-keyword">case</span> VUPVAL: {
<span class="linenr">480: </span>      <span class="org-type">int</span> <span class="org-variable-name">e</span> = luaK_exp2anyreg(fs, ex);
<span class="linenr">481: </span>      luaK_codeABC(fs, OP_SETUPVAL, e, var-&gt;u.s.info, 0);
<span class="linenr">482: </span>      <span class="org-keyword">break</span>;
<span class="linenr">483: </span>    }
<span class="linenr">484: </span>    <span class="org-keyword">case</span> VGLOBAL: {
<span class="linenr">485: </span>      <span class="org-type">int</span> <span class="org-variable-name">e</span> = luaK_exp2anyreg(fs, ex);
<span class="linenr">486: </span>      luaK_codeABx(fs, OP_SETGLOBAL, e, var-&gt;u.s.info);
<span class="linenr">487: </span>      <span class="org-keyword">break</span>;
<span class="linenr">488: </span>    }
<span class="linenr">489: </span>    <span class="org-keyword">case</span> VINDEXED: {
<span class="linenr">490: </span>      <span class="org-type">int</span> <span class="org-variable-name">e</span> = luaK_exp2RK(fs, ex);
<span class="linenr">491: </span>      luaK_codeABC(fs, OP_SETTABLE, var-&gt;u.s.info, var-&gt;u.s.aux, e);
<span class="linenr">492: </span>      <span class="org-keyword">break</span>;
<span class="linenr">493: </span>    }
<span class="linenr">494: </span>    <span class="org-keyword">default</span>: {
<span class="linenr">495: </span>      lua_assert(0);  <span class="org-comment-delimiter">/* </span><span class="org-comment">invalid var kind to store</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">496: </span>      <span class="org-keyword">break</span>;
<span class="linenr">497: </span>    }
<span class="linenr">498: </span>  }
<span class="linenr">499: </span>  freeexp(fs, ex);
<span class="linenr">500: </span>}
</pre>
</div>

<p>
对应 case VGLOBAL，生成 setglobal 指令。
</p>
</div>
</div>

<div id="outline-container-org3333234" class="outline-4">
<h4 id="org3333234"><span class="section-number-4">4.4.2</span> upvalue</h4>
<div class="outline-text-4" id="text-4-4-2">
<p>
分析如下代码，
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">a</span>

<span class="org-keyword">function</span> <span class="org-function-name">f</span>()
  a = 10
<span class="org-keyword">end</span>
</pre>
</div>

<pre class="example" id="org29b2a5f">
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  "a"  ; 0
.const  "f"  ; 0

  ; function [0] definition (level 2)
  ; 1 upvalues, 0 params, 0 is_vararg, 2 stacks
  .function  1 0 0 2
  .upvalue  "a"  ; 0
  .const  10  ; 0
  [1] loadk      0   0        ; 10
  [2] setupval   0   0        ; a
  [3] return     0   1      
  ; end of function

[1] closure    1   0        ; 1 upvalues
[2] move       0   0      
[3] setglobal  1   0        ; f
[4] return     0   1      
; end of function
</pre>

<p>
对于外层函数，a 是 local 变量，而对应内层函数，a 为 upval 变量。
</p>

<p>
基本过程同 global，不过 singlevaraux 搜索得到 VUPVAL，生成 setupval 指令。
</p>
</div>
</div>

<div id="outline-container-orgd350c5f" class="outline-4">
<h4 id="orgd350c5f"><span class="section-number-4">4.4.3</span> local</h4>
<div class="outline-text-4" id="text-4-4-3">
<div class="org-src-container">
<pre class="src src-lua"><span class="linenr">1: </span><span class="org-keyword">local</span> <span class="org-variable-name">a</span> = 1
<span class="linenr">2: </span>
<span class="linenr">3: </span><span class="org-keyword">local</span> <span class="org-variable-name">b</span>
<span class="linenr">4: </span>b = 1
</pre>
</div>

<p>
line 1 为 local 赋值语句，而 line 4 为普通赋值语句，不过恰巧赋值给 local 变量。
</p>

<p>
分析如下示例，
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>

b = 10
</pre>
</div>

<pre class="example" id="org3f98a9d">
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  "a"  ; 0
.local  "b"  ; 1
.const  10  ; 0
[1] loadk      1   0        ; 10
[2] return     0   1      
; end of function
</pre>

<p>
分析过程与上相同，singlevaraux 确定为 VLOCAL，针对寄存器位置，直接生成 loadk。
</p>
</div>
</div>

<div id="outline-container-orgcc86fa7" class="outline-4">
<h4 id="orgcc86fa7"><span class="section-number-4">4.4.4</span> indexed</h4>
<div class="outline-text-4" id="text-4-4-4">
<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">t</span> = {}

t[<span class="org-string">'a'</span>] = 10
</pre>
</div>

<pre class="example" id="org83685fc">
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  "t"  ; 0
.const  "a"  ; 0
.const  10  ; 1
[1] newtable   0   0   0    ; array=0, hash=0
[2] settable   0   256 257  ; "a" 10
[3] return     0   1      
; end of function
</pre>

<p>
VINDEXED 的分析分为两部分，singlevar 分析 t 为 local 变量，
同时在 primaryexp 中继续分析 'a' 为字符串值，存储在 k 表直接引用。
最终使用 <code>luaK_indexed</code> 确定 expdesc 的类型及相关数据。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 23: </span>lcode.c</label><pre class="src src-c"><span class="linenr">621: </span><span class="org-type">void</span> <span class="org-function-name">luaK_indexed</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">t</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">k</span>) {
<span class="linenr">622: </span>  t-&gt;u.s.aux = luaK_exp2RK(fs, k);
<span class="linenr">623: </span>  t-&gt;k = VINDEXED;
<span class="linenr">624: </span>}
</pre>
</div>

<p>
在最终赋值时，生成 gettable 指令。
</p>

<p>
之所以使用 RK(C) 作为索引，是因为索引值未必是常数，也可能是一个表，一个函数等其它值，
这里由 table 的特性决定的，这种通用的值只能由寄存器存储。
</p>
</div>
</div>
</div>


<div id="outline-container-org9bb0e19" class="outline-3">
<h3 id="org9bb0e19"><span class="section-number-3">4.5</span> function</h3>
<div class="outline-text-3" id="text-4-5">
<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-keyword">function</span> <span class="org-function-name">f</span>()
<span class="org-keyword">end</span>

<span class="org-keyword">local</span> <span class="org-function-name">f</span> = <span class="org-keyword">function</span> ()
<span class="org-keyword">end</span>
</pre>
</div>


<p>
compile time
</p>

<p>
enf 结构
</p>

<p>
body 方便定义匿名函数
</p>

<p>
func 有同名和匿名两种
从 ebnf 中可以看出，两者只差在 NAME
几乎全部由 body 处理
包含了参数，函数体等全部
动态类型，名称与值的绑定，所以由 body 来处理全部
</p>

<p>
body 过程不过是参数和 chunk 的递归过程
</p>
</div>

<div id="outline-container-org783c94b" class="outline-4">
<h4 id="org783c94b"><span class="section-number-4">4.5.1</span> upval</h4>
<div class="outline-text-4" id="text-4-5-1">
<p>
和 closure 同一级的变量被引用，使用 move 指令
&gt;= 级的变量，使用 getupval 指令
</p>


<p>
move A B
</p>

<p>
A 无用，B 指代 local 的 active 栈索引
</p>

<p>
getupval A B
</p>

<p>
A 无用，B 指代上层 closure 中 upval 表的序号
</p>

<p>
getupval 一直向上链，总会找到 local 对应的位置
</p>


<p>
Q: f 没有明显引用 a，但是但 a 却存在于 f 的 upval 数组中？
</p>

<p>
A:
</p>

<p>
singlevar
singlevaraux
</p>

<p>
从底层向上寻找，从 f 向上找到 a，调用 indexupvalue (lparser.c:183)
作为 upval 使用，而非 local，在 index upval 的过程中，
添加到 f 的 upval 表中
</p>

<p>
新增 upval 并返回 upval 对应的索引
</p>
</div>
</div>

<div id="outline-container-org7601e9d" class="outline-4">
<h4 id="org7601e9d"><span class="section-number-4">4.5.2</span> vararg</h4>
<div class="outline-text-4" id="text-4-5-2">
<p>
lobject.h:256
</p>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">4</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">NEEDSARG</td>
<td class="org-right">ISVARARG</td>
<td class="org-right">HASARG</td>
</tr>
</tbody>
</table>


<p>
在 lua5.0 中，没有 &#x2026; 的表达式，只能在参数定义时使用
</p>

<p>
而在内部引用 vararg 时，通过变量 arg 来使用
</p>

<p>
arg 是一个 table，内部以数组形式存储了 vararg
</p>

<p>
arg.n 是数组的长度
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">function</span> <span class="org-function-name">foo</span>(<span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>, ...)
  <span class="org-keyword">local</span> <span class="org-variable-name">arg</span> = {...}
  arg.n = <span class="org-builtin">select</span>(<span class="org-string">"#"</span>, ...)
<span class="org-keyword">end</span>
</pre>
</div>


<p>
lua5.1 默认有对上面形式的兼容性
</p>

<p>
NEEDSARG 表明是否在内部构造 arg 的值
</p>

<p>
ldo.c:215
</p>

<p>
lua5.1 判断，如果内部出现了 &#x2026; exp，就不使用 arg，
NEEDSARG = 0
</p>

<p>
lparser.c:756
</p>

<p>
HASARG 用于在计算 nparam 时很方便，直接使用 &amp; 运算就可以
</p>

<p>
lparser.c:571
</p>

<p>
ISVARARG 和 HASARG 应该是相同的？
chunk main func 只有 ISVARARG 标志
</p>


<p>
无即是 0
chunk func 是 2
不引用 arg 是 3
引用 arg 是 7
</p>


<p>
存储在 proto
</p>
<ul class="org-ul">
<li>numparams，vararg 不算一个参数</li>
<li>is<sub>vararg</sub></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org04a8aaa" class="outline-3">
<h3 id="org04a8aaa"><span class="section-number-3">4.6</span> do</h3>
<div class="outline-text-3" id="text-4-6">
<ul class="org-ul">
<li>block vs chunk
<ul class="org-ul">
<li>整体文件按照 chunk 来解析，chunk 是入口</li>
<li>block ::= chunk，但具体使用方式要根据语句的类型来分析
并非所有引用 chunk 的地方都会像 function 结构使用 chunk 会影响 fs 结构，
更多依赖 chunk 递归处理语句的便利</li>
</ul></li>
<li>分类
<ul class="org-ul">
<li>loop 中</li>
<li>非 loop 中</li>
</ul></li>
</ul>

<p>
blockCnt
</p>
<ul class="org-ul">
<li>previous</li>
<li>nactvar，进入 block 前 nactvar 的个数</li>
<li>isbreakable，是否用在循环中，从 bnf 中可看到</li>
<li>breaklist，chain of jump out of the loop，在 while 时深入</li>
<li>upval，bool，当前作用域中是否有 local var 作为 upval，在 for 时深入</li>
</ul>

<p>
明显的作用域分隔作用
</p>

<p>
enterblock
leaveblock
</p>

<p>
在进入时，nactvar 记录 active local var 的数量，
block 内新的 local var 会在离开时，全部释放
符合作用域的原则
内部使用，销毁，不污染外部
</p>

<p>
作用域记录在 fs 中，最终要体现到 f 中
最终在 do 之外，使用 b，会顺着 a 0 的顺序向后，b 1
说明前面的所有变量已回收
</p>

<p>
虽然有多个 block 相隔，但是在最内层进行变量查找的时候，上层的所有 act local var 都
属于同一个 fs，查找 a 的时候，a 的类型为 local，直接进行了修改
a 并不是 upval，可见 upval 只针对 function 而言
</p>

<p>
非 loop 只有 nactvar 起作用
</p>

<p>
loop 情况，到 while for 具体分析。
</p>
</div>
</div>

<div id="outline-container-org2aa5a4d" class="outline-3">
<h3 id="org2aa5a4d"><span class="section-number-3">4.7</span> if</h3>
<div class="outline-text-3" id="text-4-7">
<p>
顺序解析的难题之一
分支
</p>

<ul class="org-ul">
<li>jump chain resolve</li>
</ul>

<p>
concat
</p>

<p>
patch
</p>

<p>
patch to here, concat
</p>

<p>
patch to list, discharge right now to target
</p>

<p>
they are the same
</p>

<p>
dischargejpc
</p>




<p>
luaK<sub>jump</sub> 时，使用 jpc 重置的技巧，防止在生成 jump 时，触发 dischargejpc
</p>
</div>

<div id="outline-container-org78a5ece" class="outline-4">
<h4 id="org78a5ece"><span class="section-number-4">4.7.1</span> if</h4>
<div class="outline-text-4" id="text-4-7-1">
<p>
dischargejpc
负责从当前 pc 解析 jump chain
</p>

<p>
隐藏在 luaK<sub>code</sub> 中
</p>


<p>
问题添加 return 0 1 的原因
</p>
</div>
</div>

<div id="outline-container-org6dc2c8e" class="outline-4">
<h4 id="org6dc2c8e"><span class="section-number-4">4.7.2</span> if else</h4>
<div class="outline-text-4" id="text-4-7-2">
</div>
</div>

<div id="outline-container-org722ad33" class="outline-4">
<h4 id="org722ad33"><span class="section-number-4">4.7.3</span> if elseif</h4>
<div class="outline-text-4" id="text-4-7-3">
</div>
</div>

<div id="outline-container-org76aa6fa" class="outline-4">
<h4 id="org76aa6fa"><span class="section-number-4">4.7.4</span> if elseif else</h4>
<div class="outline-text-4" id="text-4-7-4">
</div>
</div>
</div>

<div id="outline-container-orgd22754c" class="outline-3">
<h3 id="orgd22754c"><span class="section-number-3">4.8</span> while</h3>
<div class="outline-text-3" id="text-4-8">
<p>
block
</p>

<p>
breakable  1
这样其中才可以生成 break 语句
</p>

<p>
breaklist
用于记录 break 语句，chain 到 block 外的第一条语句
</p>

<p>
enterblock 自然生成 0 block
</p>

<p>
相当于有双层 block
</p>
</div>

<div id="outline-container-org4e04970" class="outline-4">
<h4 id="org4e04970"><span class="section-number-4">4.8.1</span> break</h4>
<div class="outline-text-4" id="text-4-8-1">
</div>
</div>
</div>

<div id="outline-container-orga8fc6ee" class="outline-3">
<h3 id="orga8fc6ee"><span class="section-number-3">4.9</span> repeat</h3>
<div class="outline-text-3" id="text-4-9">
<p>
repeat    
</p>

<p>
break 同 while 时的表现相同
</p>


<p>
不过对于 upval，有自己的处理方式
</p>


<p>
因为 while 在 cond 中不能定义新的 local var
而 repeat 的 block 中可能先定义 local var
再被其中的 func 引用，而 i 在不断变化，就需要及时 close
</p>




<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">t</span> = {}

<span class="org-keyword">local</span> <span class="org-variable-name">c</span> = 0

<span class="org-keyword">repeat</span>
   c = c + 1

   <span class="org-keyword">local</span> <span class="org-variable-name">i</span> = c

   t[i] = <span class="org-keyword">function</span> ()
      <span class="org-keyword">return</span> i
   <span class="org-keyword">end</span>
<span class="org-keyword">until</span> i &gt; 10

<span class="org-keyword">for</span> <span class="org-variable-name">i</span>, <span class="org-variable-name">f</span> <span class="org-keyword">in</span> <span class="org-builtin">ipairs</span>(t) <span class="org-keyword">do</span>
   <span class="org-builtin">print</span>(f())
<span class="org-keyword">end</span>
</pre>
</div>

<p>
进行 upval 判断的原因
</p>

<p>
每个 func 记录的都是 i，但是每次 loop 结束都进行了 close，
</p>
</div>
</div>


<div id="outline-container-orgdd98c3b" class="outline-3">
<h3 id="orgdd98c3b"><span class="section-number-3">4.10</span> for</h3>
<div class="outline-text-3" id="text-4-10">
<p>
for loop 特别开发了底层指令来处理，而 repeat 和 while 则没有相应的指令。
依然是通过 jmp 来实现的。
</p>

<p>
分为两种
</p>

<p>
数字迭代 fornum
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">for</span> <span class="org-variable-name">i</span> = 1, 10, 2 <span class="org-keyword">do</span>
  <span class="org-builtin">print</span>(i)
<span class="org-keyword">end</span>
</pre>
</div>

<p>
通用迭代 forlist
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">for</span> <span class="org-variable-name">k</span>, <span class="org-variable-name">v</span> <span class="org-keyword">in</span> <span class="org-builtin">pairs</span>(t) <span class="org-keyword">do</span>
  <span class="org-builtin">print</span>(k, v)
<span class="org-keyword">end</span>
</pre>
</div>
</div>

<div id="outline-container-org0202719" class="outline-4">
<h4 id="org0202719"><span class="section-number-4">4.10.1</span> fornum</h4>
<div class="outline-text-4" id="text-4-10-1">
<p>
隐式生成的变量，用 ( 来标识，是不会与正常 lua 代码中分析得到的 NAME 冲突的
因为 lex 规则的限定
</p>

<pre class="example" id="org8a4f84b">
.local  "(for generator)"  ; 0
.local  "(for state)"  ; 1
.local  "(for control)"  ; 2
</pre>
</div>
</div>

<div id="outline-container-org333e2d9" class="outline-4">
<h4 id="org333e2d9"><span class="section-number-4">4.10.2</span> forlist</h4>
<div class="outline-text-4" id="text-4-10-2">
<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">g</span>, <span class="org-variable-name">s</span> = <span class="org-builtin">pairs</span>({1,2,3})

<span class="org-keyword">for</span> <span class="org-variable-name">k</span>, <span class="org-variable-name">v</span> <span class="org-keyword">in</span> g, s, <span class="org-constant">nil</span> <span class="org-keyword">do</span>
  <span class="org-builtin">print</span>(k, v)
<span class="org-keyword">end</span>
</pre>
</div>

<p>
upvalue 同 fornum
</p>
</div>
</div>
</div>

<div id="outline-container-org48de970" class="outline-3">
<h3 id="org48de970"><span class="section-number-3">4.11</span> function call</h3>
<div class="outline-text-3" id="text-4-11">
<p>
function call
</p>

<p>
func 在栈的底部，参数向上累加
</p>

<p>
调用结果，返回值，从栈的 func 处开始向上覆盖
</p>

<p>
funcargs()
lparser.c:609
</p>

<p>
并不复杂
</p>
</div>

<div id="outline-container-org5a6b901" class="outline-4">
<h4 id="org5a6b901"><span class="section-number-4">4.11.1</span> self</h4>
<div class="outline-text-4" id="text-4-11-1">
<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">o</span> = {}

<span class="org-keyword">function</span> <span class="org-function-name">o.f</span>(<span class="org-builtin">self</span>)
  <span class="org-builtin">print</span>(<span class="org-builtin">self</span>)
<span class="org-keyword">end</span>

<span class="org-keyword">function</span> <span class="org-function-name">o:f</span>()
  <span class="org-builtin">print</span>(<span class="org-builtin">self</span>)
<span class="org-keyword">end</span>

o.f(o)

o:f()
</pre>
</div>

<p>
self 指令，只是一种优化方式
</p>



<p>
luaK<sub>self</sub>()
</p>

<p>
lcode.c:503
</p>

<p>
结合 op self 的语义，并不复杂
</p>

<p>
self 只是为 call 做准备，将对象提前放到相应位置
</p>
</div>
</div>
</div>


<div id="outline-container-org84d3938" class="outline-3">
<h3 id="org84d3938"><span class="section-number-3">4.12</span> ret</h3>
<div class="outline-text-3" id="text-4-12">
<p>
return 在 chunk 中发挥作用
从当前 closure 中返回
</p>

<p>
return 必须是 chunk 的最后一个语句
</p>

<p>
按语句含义返回值，至于有多少值被利用，则根据 opcode 生成过程中决定的
</p>

<p>
opcode 容易理解
</p>

<p>
retstat()
lparser.c:1238
</p>
</div>

<div id="outline-container-org0510e67" class="outline-4">
<h4 id="org0510e67"><span class="section-number-4">4.12.1</span> tailcall</h4>
<div class="outline-text-4" id="text-4-12-1">
<div class="org-src-container">
<pre class="src src-lua"><span class="org-comment-delimiter">-- </span><span class="org-comment">tail call</span>
<span class="org-keyword">return</span> f()
<span class="org-comment-delimiter">-- </span><span class="org-comment">not tail call</span>
<span class="org-keyword">return</span> a, b, f()
</pre>
</div>

<p>
ret 中只有单独的 function call
</p>

<p>
进行栈优化
</p>

<p>
lparser.c:1249
</p>

<p>
tailcall 本身已经有了 return 的语义
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-orgb67fb9c" class="outline-2">
<h2 id="orgb67fb9c"><span class="section-number-2">5</span> practice</h2>
<div class="outline-text-2" id="text-5">
<p>
理想的 vm
独立，lua 实现对 vm 做了协同的妥协
</p>
</div>

<div id="outline-container-org959b5ec" class="outline-3">
<h3 id="org959b5ec"><span class="section-number-3">5.1</span> arithmetic</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>优先级</li>
</ul>

<p>
lua 在进行解析时，没有进行关系运算的实时解析，但是对 constant 算法运算有编译时执行
</p>

<p>
如 `local a = 5 &gt; 2` 和 `local a = 1 + 2` 的区别
</p>

<p>
前者需要生成 jmp 指令，但是后者，直接是 loadk 0 0 ; 3
</p>
</div>
</div>

<div id="outline-container-org5aa406e" class="outline-3">
<h3 id="org5aa406e"><span class="section-number-3">5.2</span> logic</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>and or</li>
</ul>
</div>
</div>

<div id="outline-container-org5da4352" class="outline-3">
<h3 id="org5da4352"><span class="section-number-3">5.3</span> constructor</h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li>setlist always consistent, diff with settable</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p>Updated: 2021-01-13 三 10:21</p>
<p>Created: 2021-01-08 五 11:34</p>
<p>Author: DreamAndDead</p>
<p>Email: <a href="mailto:dreamanddead@foxmail.com">dreamanddead@foxmail.com</a></p>
<script src="https://utteranc.es/client.js" repo="DreamAndDead/DreamAndDead.github.io" issue-term="pathname" label="Comment" theme="github-light" crossorigin="anonymous" async></script>
</div>
</body>
</html>
