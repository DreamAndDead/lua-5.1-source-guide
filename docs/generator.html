<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2021-01-14 四 11:34 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>generator</title>
<meta name="generator" content="Org mode">
<meta name="author" content="DreamAndDead">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link id="theme" rel="stylesheet" type="text/css" href="htmlize.css">
<link rel="stylesheet" type="text/css" href="style.css">
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">generator</h1>
<p>
上一章尝试单独解析语法分析过程，本章关注具体的代码生成过程。
</p>


<div id="org34dba5d" class="figure">
<p><img src="generator-feature.png" alt="generator-feature.png">
</p>
</div>

<div id="outline-container-org85a1b1a" class="outline-2">
<h2 id="org85a1b1a"><span class="section-number-2">1</span> function vs proto vs closure</h2>
<div class="outline-text-2" id="text-1">
<p>
在具体深入代码生成之前，先来区分三个概念，function proto 和 closure。
</p>

<p>
function，是 lua 语言中定义的概念，是 8 种基础类型之一，表示函数，
具体在 lua 代码中用关键字 <code>function</code> 来定义。
</p>

<p>
如同 string 概念在底层由 TString 结构来实现一样，
function 在底层用 Proto 结构来实现，是 function 整体编译之后得到的同语义结构。
</p>

<p>
编译得到的 Proto 是静态的，在实际运行的时候，需要封装为 Closure 结构，交由 vm 来执行。
Closure 为 upvalue 分配了空间，并统一表示了 c function 和 lua function。
</p>

<p>
这也是为什么在 object 章节，提到基础类型对应的实现结构时，用 Closure 而不是用 Proto 来表示 function。
</p>

<p>
所以在编译时期，我们关注 Proto，而在运行时期，才关注 Closure。
</p>
</div>

<div id="outline-container-org3420d32" class="outline-3">
<h3 id="org3420d32"><span class="section-number-3">1.1</span> chunk</h3>
<div class="outline-text-3" id="text-1-1">
<p>
lua 内部使用了一种巧妙的实现，在编译时，将整个文件当做一个匿名 function 来对待。
相当于文件头加了 <code>function ()</code> ，文件尾加了 <code>end</code> 。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>lparser.c</label><pre class="src src-c"><span class="linenr">383: </span><span class="org-type">Proto</span> *<span class="org-function-name">luaY_parser</span> (<span class="org-type">lua_State</span> *<span class="org-variable-name">L</span>, <span class="org-type">ZIO</span> *<span class="org-variable-name">z</span>, <span class="org-type">Mbuffer</span> *<span class="org-variable-name">buff</span>, <span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">name</span>) {
<span class="linenr">384: </span>  <span class="org-keyword">struct</span> <span class="org-type">LexState</span> <span class="org-variable-name">lexstate</span>;
<span class="linenr">385: </span>  <span class="org-keyword">struct</span> <span class="org-type">FuncState</span> <span class="org-variable-name">funcstate</span>;
<span class="linenr">386: </span>  lexstate.buff = buff;
<span class="linenr">387: </span>  luaX_setinput(L, &amp;lexstate, z, luaS_new(L, name));
<span class="linenr">388: </span>  open_func(&amp;lexstate, &amp;funcstate);
<span class="linenr">389: </span>  funcstate.f-&gt;is_vararg = VARARG_ISVARARG;  <span class="org-comment-delimiter">/* </span><span class="org-comment">main func. is always vararg</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">390: </span>  luaX_next(&amp;lexstate);  <span class="org-comment-delimiter">/* </span><span class="org-comment">read first token</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">391: </span>  chunk(&amp;lexstate);
<span class="linenr">392: </span>  check(&amp;lexstate, TK_EOS);
<span class="linenr">393: </span>  close_func(&amp;lexstate);
<span class="linenr">394: </span>  lua_assert(funcstate.prev == <span class="org-constant">NULL</span>);
<span class="linenr">395: </span>  lua_assert(funcstate.f-&gt;nups == 0);
<span class="linenr">396: </span>  lua_assert(lexstate.fs == <span class="org-constant">NULL</span>);
<span class="linenr">397: </span>  <span class="org-keyword">return</span> funcstate.f;
<span class="linenr">398: </span>}
</pre>
</div>

<p>
可以看到， <code>luaY_parser</code> 读取文件，最终生成并返回 <code>Proto *</code> 。
</p>

<p>
因为整体分析的入口是 chunk，lua 又将文件当做匿名函数来对待，
这也是很多 lua 书籍中提到 chunk 的原因，表示文件编译得到的结果。
</p>
</div>
</div>

<div id="outline-container-org984e5f6" class="outline-3">
<h3 id="org984e5f6"><span class="section-number-3">1.2</span> embeded</h3>
<div class="outline-text-3" id="text-1-2">
<p>
如果按照 function 和 Proto 一一对应的关系，会出现函数层级的问题。
</p>

<p>
比如下面的示例代码，
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">function</span> <span class="org-function-name">a</span>()
   <span class="org-keyword">function</span> <span class="org-function-name">b</span>()
   <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

<span class="org-keyword">function</span> <span class="org-function-name">c</span>()
   <span class="org-keyword">function</span> <span class="org-function-name">d</span>()
   <span class="org-keyword">end</span>

   <span class="org-keyword">function</span> <span class="org-function-name">e</span>()
   <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
如果将 lua 代码文件看作 Proto chunk，代码中定义的 a b c d 同样是 function 且编译为 Proto。
但是 function a b c d e 是 lua 代码的一部分，所以其 Proto 也应该被包含在 Proto chunk 中。
</p>

<p>
lua 内部根据 function 定义的位置，来记录这种包含关系。
</p>


<div id="org558099c" class="figure">
<p><img src="generator-function-level.png" alt="generator-function-level.png">
</p>
</div>

<p>
function a c 直接定义在代码文件（顶层匿名函数）中，
b d e 则直接定义在 a 和 c 中。
</p>


<div id="org74e3af0" class="figure">
<p><img src="generator-proto-level.png" alt="generator-proto-level.png">
</p>
</div>

<p>
Proto 结构中使用 struct Proto * 数组 p（Line 235）来记录其直接包含的 Proto。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>lobject.h</label><pre class="src src-C"><span class="linenr">228: </span><span class="org-comment-delimiter">/*</span>
<span class="linenr">229: </span><span class="org-comment">** Function Prototypes</span>
<span class="linenr">230: </span><span class="org-comment-delimiter">*/</span>
<span class="linenr">231: </span><span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">Proto</span> {
<span class="linenr">232: </span>  CommonHeader;
<span class="linenr">233: </span>  <span class="org-type">TValue</span> *<span class="org-variable-name">k</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">constants used by the function</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">234: </span>  <span class="org-type">Instruction</span> *<span class="org-variable-name">code</span>;
<span class="linenr">235: </span>  <span class="org-keyword">struct</span> <span class="org-type">Proto</span> **<span class="org-variable-name">p</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">functions defined inside the function</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">236: </span>  <span class="org-type">int</span> *<span class="org-variable-name">lineinfo</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">map from opcodes to source lines</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">237: </span>  <span class="org-keyword">struct</span> <span class="org-type">LocVar</span> *<span class="org-variable-name">locvars</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">information about local variables</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">238: </span>  <span class="org-type">TString</span> **<span class="org-variable-name">upvalues</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">upvalue names</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">239: </span>  <span class="org-type">TString</span>  *<span class="org-variable-name">source</span>;
<span class="linenr">240: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizeupvalues</span>;
<span class="linenr">241: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizek</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">size of `k'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">242: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizecode</span>;
<span class="linenr">243: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizelineinfo</span>;
<span class="linenr">244: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizep</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">size of `p'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">245: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizelocvars</span>;
<span class="linenr">246: </span>  <span class="org-type">int</span> <span class="org-variable-name">linedefined</span>;
<span class="linenr">247: </span>  <span class="org-type">int</span> <span class="org-variable-name">lastlinedefined</span>;
<span class="linenr">248: </span>  <span class="org-type">GCObject</span> *<span class="org-variable-name">gclist</span>;
<span class="linenr">249: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">nups</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">number of upvalues</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">250: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">numparams</span>;
<span class="linenr">251: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">is_vararg</span>;
<span class="linenr">252: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">maxstacksize</span>;
<span class="linenr">253: </span>} <span class="org-type">Proto</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org5b478ed" class="outline-3">
<h3 id="org5b478ed"><span class="section-number-3">1.3</span> FuncState</h3>
<div class="outline-text-3" id="text-1-3">
<p>
在 lua 的语法分析中，function 解析是一个重要的部分。
</p>

<p>
EBNF 和 regex 的区别在于，EBNF 可以描述一种递归过程，而 regex 则不能。
</p>

<p>
chunk 作为解析 function 的入口，得到 Proto，这个过程在遇到 function 定义时，不断的递归调用，生成 Proto，
并按照层级链接起来。
</p>

<p>
在了解这个过程之前，要先介绍另一个重要的结构 FuncState 。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>lparser.h</label><pre class="src src-c"><span class="linenr">57: </span><span class="org-comment-delimiter">/* </span><span class="org-comment">state needed to generate code for a given function</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">58: </span><span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">FuncState</span> {
<span class="linenr">59: </span>  <span class="org-type">Proto</span> *<span class="org-variable-name">f</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">current function header</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">60: </span>  <span class="org-type">Table</span> *<span class="org-variable-name">h</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">table to find (and reuse) elements in `k'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">61: </span>  <span class="org-keyword">struct</span> <span class="org-type">FuncState</span> *<span class="org-variable-name">prev</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">enclosing function</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">62: </span>  <span class="org-keyword">struct</span> <span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">lexical state</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">63: </span>  <span class="org-keyword">struct</span> <span class="org-type">lua_State</span> *<span class="org-variable-name">L</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">copy of the Lua state</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">64: </span>  <span class="org-keyword">struct</span> <span class="org-type">BlockCnt</span> *<span class="org-variable-name">bl</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">chain of current blocks</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">65: </span>  <span class="org-type">int</span> <span class="org-variable-name">pc</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">next position to code (equivalent to `ncode')</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">66: </span>  <span class="org-type">int</span> <span class="org-variable-name">lasttarget</span>;   <span class="org-comment-delimiter">/* </span><span class="org-comment">`pc' of last `jump target'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">67: </span>  <span class="org-type">int</span> <span class="org-variable-name">jpc</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">list of pending jumps to `pc'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">68: </span>  <span class="org-type">int</span> <span class="org-variable-name">freereg</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">first free register</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">69: </span>  <span class="org-type">int</span> <span class="org-variable-name">nk</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">number of elements in `k'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">70: </span>  <span class="org-type">int</span> <span class="org-variable-name">np</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">number of elements in `p'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">71: </span>  <span class="org-type">short</span> <span class="org-variable-name">nlocvars</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">number of elements in `locvars'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">72: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">nactvar</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">number of active local variables</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">73: </span>  <span class="org-type">upvaldesc</span> <span class="org-variable-name">upvalues</span>[LUAI_MAXUPVALUES];  <span class="org-comment-delimiter">/* </span><span class="org-comment">upvalues</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">74: </span>  <span class="org-type">unsigned</span> <span class="org-type">short</span> <span class="org-variable-name">actvar</span>[LUAI_MAXVARS];  <span class="org-comment-delimiter">/* </span><span class="org-comment">declared-variable stack</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">75: </span>} <span class="org-type">FuncState</span>;
</pre>
</div>

<p>
从名称可以看出，和 LexState 相似，也用于记录中间状态。
FuncState 用于记录 function 分析过程中的状态，和 function 定义一一对应，
每遇到一个 function 定义时，lua 都会新建一个 FuncState，记录当下解析 function 的中间状态。
</p>
</div>
</div>

<div id="outline-container-org6bc1c06" class="outline-3">
<h3 id="org6bc1c06"><span class="section-number-3">1.4</span> big picture</h3>
<div class="outline-text-3" id="text-1-4">
<p>
LexState FuncState Proto 这三者在分析过程中协同生成最终的 Proto。
</p>

<p>
比如解析如下示例代码，
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="linenr">1: </span><span class="org-keyword">function</span> <span class="org-function-name">a</span>()
<span class="linenr">2: </span>   <span class="org-keyword">function</span> <span class="org-function-name">b</span>()
<span class="linenr">3: </span>   <span class="org-keyword">end</span>
<span class="linenr">4: </span><span class="org-keyword">end</span>
</pre>
</div>

<p>
在整体文件分析开始之前，parser 已经准备好 FuncState，通过 LexState.ls 索引，
FuncState.f 指向相应要生成的 Proto。
</p>


<div id="orga4cdbb4" class="figure">
<p><img src="generator-big-picture-0.png" alt="generator-big-picture-0.png">
</p>
</div>

<p>
解析第 1 行之后，需要函数定义 a，parser 生成新的 FuncState，并更新 ls.fs 的指向。
同时，fs a 通过 prev 指向 fs chunk，表示层级关系。
</p>


<div id="orgfd9e71f" class="figure">
<p><img src="generator-big-picture-1.png" alt="generator-big-picture-1.png">
</p>
</div>


<p>
第 2 行，遇到函数 b 定义，同样的，生成 FuncState 并更新 ls.fs 的指向。
</p>


<div id="org30d7063" class="figure">
<p><img src="generator-big-picture-2.png" alt="generator-big-picture-2.png">
</p>
</div>

<p>
第 3 行，函数 b 定义结束，此时 ls.fs 指向 fs b 的 prev，回到上个函数定义层级。
并将函数 b 生成的 Proto 链接到上层函数 a 的 Proto。
</p>

<p>
此时，fs b 已经结束其作用。
</p>


<div id="orgb1c044a" class="figure">
<p><img src="generator-big-picture-3.png" alt="generator-big-picture-3.png">
</p>
</div>


<div id="orgdcd2486" class="figure">
<p><img src="generator-big-picture-4.png" alt="generator-big-picture-4.png">
</p>
</div>

<p>
第 4 行，函数 a 定义结束，同上，更新 ls.fs 指向，并链接 Proto a 到 Proto chunk。
</p>


<div id="orgb18dc17" class="figure">
<p><img src="generator-big-picture-5.png" alt="generator-big-picture-5.png">
</p>
</div>

<p>
最终返回 Proto chunk，ls 和 fs 都已经结束其使命，毕竟它们的作用只用于记录中间状态
</p>

<p>
在 parser 内部，上面描述的过程发生在 <code>open_func() close_func()</code> 中，读者可仔细体会其细节。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>lparser.c</label><pre class="src src-c"><span class="linenr">328: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">open_func</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>, <span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>) {
<span class="linenr">329: </span>  <span class="org-type">lua_State</span> *<span class="org-variable-name">L</span> = ls-&gt;L;
<span class="linenr">330: </span>  <span class="org-type">Proto</span> *<span class="org-variable-name">f</span> = luaF_newproto(L);
<span class="linenr">331: </span>  fs-&gt;f = f;
<span class="linenr">332: </span>  fs-&gt;prev = ls-&gt;fs;  <span class="org-comment-delimiter">/* </span><span class="org-comment">linked list of funcstates</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">333: </span>  fs-&gt;ls = ls;
<span class="linenr">334: </span>  fs-&gt;L = L;
<span class="linenr">335: </span>  ls-&gt;fs = fs;
<span class="linenr">336: </span>  fs-&gt;pc = 0;
<span class="linenr">337: </span>  fs-&gt;lasttarget = -1;
<span class="linenr">338: </span>  fs-&gt;jpc = NO_JUMP;
<span class="linenr">339: </span>  fs-&gt;freereg = 0;
<span class="linenr">340: </span>  fs-&gt;nk = 0;
<span class="linenr">341: </span>  fs-&gt;np = 0;
<span class="linenr">342: </span>  fs-&gt;nlocvars = 0;
<span class="linenr">343: </span>  fs-&gt;nactvar = 0;
<span class="linenr">344: </span>  fs-&gt;bl = <span class="org-constant">NULL</span>;
<span class="linenr">345: </span>  f-&gt;source = ls-&gt;source;
<span class="linenr">346: </span>  f-&gt;maxstacksize = 2;  <span class="org-comment-delimiter">/* </span><span class="org-comment">registers 0/1 are always valid</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">347: </span>  fs-&gt;h = luaH_new(L, 0, 0);
<span class="linenr">348: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">anchor table of constants and prototype (to avoid being collected)</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">349: </span>  sethvalue2s(L, L-&gt;top, fs-&gt;h);
<span class="linenr">350: </span>  incr_top(L);
<span class="linenr">351: </span>  setptvalue2s(L, L-&gt;top, f);
<span class="linenr">352: </span>  incr_top(L);
<span class="linenr">353: </span>}
<span class="linenr">354: </span>
<span class="linenr">355: </span>
<span class="linenr">356: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">close_func</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>) {
<span class="linenr">357: </span>  <span class="org-type">lua_State</span> *<span class="org-variable-name">L</span> = ls-&gt;L;
<span class="linenr">358: </span>  <span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span> = ls-&gt;fs;
<span class="linenr">359: </span>  <span class="org-type">Proto</span> *<span class="org-variable-name">f</span> = fs-&gt;f;
<span class="linenr">360: </span>  removevars(ls, 0);
<span class="linenr">361: </span>  luaK_ret(fs, 0, 0);  <span class="org-comment-delimiter">/* </span><span class="org-comment">final return</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">362: </span>  luaM_reallocvector(L, f-&gt;code, f-&gt;sizecode, fs-&gt;pc, Instruction);
<span class="linenr">363: </span>  f-&gt;sizecode = fs-&gt;pc;
<span class="linenr">364: </span>  luaM_reallocvector(L, f-&gt;lineinfo, f-&gt;sizelineinfo, fs-&gt;pc, <span class="org-type">int</span>);
<span class="linenr">365: </span>  f-&gt;sizelineinfo = fs-&gt;pc;
<span class="linenr">366: </span>  luaM_reallocvector(L, f-&gt;k, f-&gt;sizek, fs-&gt;nk, TValue);
<span class="linenr">367: </span>  f-&gt;sizek = fs-&gt;nk;
<span class="linenr">368: </span>  luaM_reallocvector(L, f-&gt;p, f-&gt;sizep, fs-&gt;np, <span class="org-type">Proto</span> *);
<span class="linenr">369: </span>  f-&gt;sizep = fs-&gt;np;
<span class="linenr">370: </span>  luaM_reallocvector(L, f-&gt;locvars, f-&gt;sizelocvars, fs-&gt;nlocvars, LocVar);
<span class="linenr">371: </span>  f-&gt;sizelocvars = fs-&gt;nlocvars;
<span class="linenr">372: </span>  luaM_reallocvector(L, f-&gt;upvalues, f-&gt;sizeupvalues, f-&gt;nups, <span class="org-type">TString</span> *);
<span class="linenr">373: </span>  f-&gt;sizeupvalues = f-&gt;nups;
<span class="linenr">374: </span>  lua_assert(luaG_checkcode(f));
<span class="linenr">375: </span>  lua_assert(fs-&gt;bl == <span class="org-constant">NULL</span>);
<span class="linenr">376: </span>  ls-&gt;fs = fs-&gt;prev;
<span class="linenr">377: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">last token read was anchored in defunct function; must reanchor it</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">378: </span>  <span class="org-keyword">if</span> (fs) anchor_token(ls);
<span class="linenr">379: </span>  L-&gt;top -= 2;  <span class="org-comment-delimiter">/* </span><span class="org-comment">remove table and prototype from the stack</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">380: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0321ec9" class="outline-3">
<h3 id="org0321ec9"><span class="section-number-3">1.5</span> FuncState vs Proto</h3>
<div class="outline-text-3" id="text-1-5">
<p>
FuncState 和 Proto 作为分析过程中两个最重要的结构，值得详细做一番了解。
</p>

<p>
仔细观察两个结构内部的字段，会发现两者之间有紧密的联系，界限很模糊，
都些许记录了分析过程的结果。
关键的差异在于，Proto 只保留最终结果，而 FuncState 记录中间状态。
</p>

<p>
对应这个原则，来详细探究下两个结构的内部。
</p>

<p>
先来看 Proto。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>lobject.h</label><pre class="src src-C"><span class="linenr">228: </span><span class="org-comment-delimiter">/*</span>
<span class="linenr">229: </span><span class="org-comment">** Function Prototypes</span>
<span class="linenr">230: </span><span class="org-comment-delimiter">*/</span>
<span class="linenr">231: </span><span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">Proto</span> {
<span class="linenr">232: </span>  CommonHeader;
<span class="linenr">233: </span>  <span class="org-type">TValue</span> *<span class="org-variable-name">k</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">constants used by the function</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">234: </span>  <span class="org-type">Instruction</span> *<span class="org-variable-name">code</span>;
<span class="linenr">235: </span>  <span class="org-keyword">struct</span> <span class="org-type">Proto</span> **<span class="org-variable-name">p</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">functions defined inside the function</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">236: </span>  <span class="org-type">int</span> *<span class="org-variable-name">lineinfo</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">map from opcodes to source lines</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">237: </span>  <span class="org-keyword">struct</span> <span class="org-type">LocVar</span> *<span class="org-variable-name">locvars</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">information about local variables</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">238: </span>  <span class="org-type">TString</span> **<span class="org-variable-name">upvalues</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">upvalue names</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">239: </span>  <span class="org-type">TString</span>  *<span class="org-variable-name">source</span>;
<span class="linenr">240: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizeupvalues</span>;
<span class="linenr">241: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizek</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">size of `k'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">242: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizecode</span>;
<span class="linenr">243: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizelineinfo</span>;
<span class="linenr">244: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizep</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">size of `p'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">245: </span>  <span class="org-type">int</span> <span class="org-variable-name">sizelocvars</span>;
<span class="linenr">246: </span>  <span class="org-type">int</span> <span class="org-variable-name">linedefined</span>;
<span class="linenr">247: </span>  <span class="org-type">int</span> <span class="org-variable-name">lastlinedefined</span>;
<span class="linenr">248: </span>  <span class="org-type">GCObject</span> *<span class="org-variable-name">gclist</span>;
<span class="linenr">249: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">nups</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">number of upvalues</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">250: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">numparams</span>;
<span class="linenr">251: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">is_vararg</span>;
<span class="linenr">252: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">maxstacksize</span>;
<span class="linenr">253: </span>} <span class="org-type">Proto</span>;
</pre>
</div>

<p>
其中字段分为 3 部分来看
</p>

<p>
暂不讨论
</p>
<ul class="org-ul">
<li><code>int *lineinfo</code></li>
<li><code>TString *source</code></li>
<li><code>int linedefined</code></li>
<li><code>int lastlinedefined</code></li>
<li><code>GCObject *gclist</code></li>
</ul>

<p>
元信息
</p>
<ul class="org-ul">
<li><code>lu_byte numparams</code> ，函数的固定参数个数</li>
<li><code>lu_byte is_vararg</code> ，函数的可变参数</li>
<li><code>lu_byte maxstacksize</code> ，函数运行时，最大使用的栈空间</li>
</ul>

<p>
数组结果
</p>
<ul class="org-ul">
<li><code>TValue *k</code> ，常量表</li>
<li><code>Instruction *code</code> ，字节码</li>
<li><code>struct Proto **p</code> ，内部其它函数定义</li>
<li><code>struct LocVar *locvars</code> ，局部变量信息</li>
<li><code>TString **upvalues</code> ，upvalue 信息</li>
<li>与 len size 相关的字段</li>
</ul>

<p>
对照之前对 vm 执行模型的讨论，code 和 k 就与之对应。
</p>

<p>
这里一个有意思的区别，在于 size 和 n。
</p>

<p>
上面提到的 5 个数组，都对应一个 size 字段，用于记录数组的大小。
同时，也对应一个 n 字段，用于记录当前数组已使用的大小（下一个空闲的位置）。
</p>

<p>
在分析的过程中，数组 size 值记录空间总长度，当空间不足时，会继续扩大分配。
而数组 n 值用于时刻标识下一个空闲索引，记录分析结果并自增，它的值比 size 小。
</p>

<p>
当最终分析结束时，将 n 值赋值给相应的 size 值，省略多余不用的空间，此时两者才会相同。
</p>

<p>
如此看来，n 值应该存放在 FuncState 中，但是存在例外的是 <code>lu_byte nups</code> 。
</p>


<div id="org81ddb46" class="figure">
<p><img src="generator-fcode.png" alt="generator-fcode.png">
</p>
</div>


<div id="org04442e8" class="figure">
<p><img src="generator-fk.png" alt="generator-fk.png">
</p>
</div>


<div id="org55d4baa" class="figure">
<p><img src="generator-fp.png" alt="generator-fp.png">
</p>
</div>



<div id="org8392931" class="figure">
<p><img src="generator-fupval.png" alt="generator-fupval.png">
</p>
</div>


<div id="org3284c05" class="figure">
<p><img src="generator-flocvars.png" alt="generator-flocvars.png">
</p>
</div>

<p>
相同的视角，来观察 FuncState。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span>lparser.h</label><pre class="src src-c"><span class="linenr">57: </span><span class="org-comment-delimiter">/* </span><span class="org-comment">state needed to generate code for a given function</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">58: </span><span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">FuncState</span> {
<span class="linenr">59: </span>  <span class="org-type">Proto</span> *<span class="org-variable-name">f</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">current function header</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">60: </span>  <span class="org-type">Table</span> *<span class="org-variable-name">h</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">table to find (and reuse) elements in `k'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">61: </span>  <span class="org-keyword">struct</span> <span class="org-type">FuncState</span> *<span class="org-variable-name">prev</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">enclosing function</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">62: </span>  <span class="org-keyword">struct</span> <span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">lexical state</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">63: </span>  <span class="org-keyword">struct</span> <span class="org-type">lua_State</span> *<span class="org-variable-name">L</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">copy of the Lua state</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">64: </span>  <span class="org-keyword">struct</span> <span class="org-type">BlockCnt</span> *<span class="org-variable-name">bl</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">chain of current blocks</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">65: </span>  <span class="org-type">int</span> <span class="org-variable-name">pc</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">next position to code (equivalent to `ncode')</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">66: </span>  <span class="org-type">int</span> <span class="org-variable-name">lasttarget</span>;   <span class="org-comment-delimiter">/* </span><span class="org-comment">`pc' of last `jump target'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">67: </span>  <span class="org-type">int</span> <span class="org-variable-name">jpc</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">list of pending jumps to `pc'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">68: </span>  <span class="org-type">int</span> <span class="org-variable-name">freereg</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">first free register</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">69: </span>  <span class="org-type">int</span> <span class="org-variable-name">nk</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">number of elements in `k'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">70: </span>  <span class="org-type">int</span> <span class="org-variable-name">np</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">number of elements in `p'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">71: </span>  <span class="org-type">short</span> <span class="org-variable-name">nlocvars</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">number of elements in `locvars'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">72: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">nactvar</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">number of active local variables</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">73: </span>  <span class="org-type">upvaldesc</span> <span class="org-variable-name">upvalues</span>[LUAI_MAXUPVALUES];  <span class="org-comment-delimiter">/* </span><span class="org-comment">upvalues</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">74: </span>  <span class="org-type">unsigned</span> <span class="org-type">short</span> <span class="org-variable-name">actvar</span>[LUAI_MAXVARS];  <span class="org-comment-delimiter">/* </span><span class="org-comment">declared-variable stack</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">75: </span>} <span class="org-type">FuncState</span>;
</pre>
</div>

<p>
暂不讨论
</p>
<ul class="org-ul">
<li><code>Proto *f</code></li>
<li><code>struct FuncState *prev</code></li>
<li><code>struct LexState *ls</code></li>
<li><code>struct lua_State *L</code></li>
</ul>

<p>
后续讨论
</p>
<ul class="org-ul">
<li><code>struct BlockCnt *bl</code></li>
<li><code>int lasttarget</code></li>
<li><code>int jpc</code></li>
<li><code>int freereg</code></li>
</ul>

<p>
中间结果
</p>
<ul class="org-ul">
<li><code>upvaldesc upvalues[LUAI_MAXUPVALUES]</code></li>
<li><code>unsigned short actvar[LUAI_MAXVARS]</code></li>
<li>其它 n 字段</li>
</ul>

<p>
两个数组是定长的，即 size 是固定的， <code>f-&gt;nups</code> <code>fs-&gt;nactvar</code> 用于对应其 n 字段。
</p>


<div id="org9459abd" class="figure">
<p><img src="generator-fsupval.png" alt="generator-fsupval.png">
</p>
</div>


<div id="org161cda7" class="figure">
<p><img src="generator-fsactvar.png" alt="generator-fsactvar.png">
</p>
</div>

<p>
在编译过程中，所得到的结果会不断的存储入上述数组及其它字段中。
</p>
</div>
</div>
</div>

<div id="outline-container-orgda89633" class="outline-2">
<h2 id="orgda89633"><span class="section-number-2">2</span> generate</h2>
<div class="outline-text-2" id="text-2">
<p>
从某种角度看，编译过程就是规则间的同义转换过程。
</p>

<p>
代码生成，最终将符合语法规则的 lua 代码，生成为 vm 可执行的同义字节码，
这个过程是隐藏在语法分析下的艺术。
</p>

<p>
两个规则间可以进行同义转换的连接点，在于对 vm 的共识，
正因为编译器"懂得" vm，知晓字节码的格式与功能，知晓运行时的栈结构，
知晓 k 表 Gbl 表的读取方式，才能生成 vm 可执行的同义字节码。
</p>

<p>
这种共识贯穿在整个代码生成的过程中。
</p>

<p>
但是无论编译器如何了解 vm，编译时和运行时还是存在区别的。
代码生成时，只是想象存在一个假想的 vm，它在执行生成的所有结果。
</p>

<p>
所以代码生成这个过程是最为繁杂的，到 vm 真正运行时反而轻松了，只需要读指令，执行指令就可以了。
</p>

<p>
阅读代码生成相关的代码，笔者还没有精确地把握住其中的原理，只能提供几个原则给读者参考，
</p>
<ul class="org-ul">
<li>总体是语法制导翻译的过程</li>
<li>使用后缀方式的生成顺序，比如 a + b 按照 a b + 的顺序来转换生成</li>
<li>精确模拟 vm 的运行方式，包括栈运算，Gbl 表及其它</li>
</ul>

<p>
章节结束之后，读者可以多使用调试器分析示例代码，探索其中的奥妙。
</p>
</div>
</div>

<div id="outline-container-org64f28c2" class="outline-2">
<h2 id="org64f28c2"><span class="section-number-2">3</span> key concept</h2>
<div class="outline-text-2" id="text-3">
<p>
在仔细探索代码生成之前，先明确几个在生成过程中的重点。
</p>
</div>

<div id="outline-container-org3a7d0dc" class="outline-3">
<h3 id="org3a7d0dc"><span class="section-number-3">3.1</span> variable</h3>
<div class="outline-text-3" id="text-3-1">
<p>
从作用域来看，lua 中的变量有 3 类，分别为 <code>local upvalue global</code> ，
三者在底层的实现方式各不相同。
</p>
</div>

<div id="outline-container-orgba364c4" class="outline-4">
<h4 id="orgba364c4"><span class="section-number-4">3.1.1</span> local</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
local 变量的活动范围（active），开始于在作用域中出现的那一刻，一直到作用域结束，
而作用域是有明显的栈特性的，新开辟作用域时入栈，离开作用域时出栈。
</p>

<p>
在一个作用域内，local 变量按照声明顺序入栈，离开作用域时全部出栈，变为 inactive 状态。
</p>

<p>
利用这个特性，lua 在编译时，在 fs 中用 actvar 和 nactvar 时刻记录着当前 active local 变量的状态。
</p>

<p>
比如如下示例代码，
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">a</span>

<span class="org-keyword">do</span>
   <span class="org-keyword">local</span> <span class="org-variable-name">b</span>
   <span class="org-keyword">do</span>
      <span class="org-keyword">local</span> <span class="org-variable-name">c</span>
   <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

<span class="org-keyword">do</span>
   <span class="org-keyword">local</span> <span class="org-variable-name">d</span>
   <span class="org-keyword">do</span>
      <span class="org-keyword">local</span> <span class="org-variable-name">e</span>
   <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
在代码分析的不同时刻， <code>fs-&gt;actvar</code> 记录的栈状态是这样的，
</p>


<div id="orga919958" class="figure">
<p><img src="generator-active-local-scope.png" alt="generator-active-local-scope.png">
</p>
</div>

<p>
上面只是粗略描述了 active local 变量的栈状态，而实际在 parser 内部，是通过两个数组来存储的。
</p>


<div id="org02973cc" class="figure">
<p><img src="generator-actvar-locvars.png" alt="generator-actvar-locvars.png">
</p>
</div>

<p>
数组 <code>fs-&gt;actvar</code> 的元素是 <code>unsigned short</code> 类型，只用来记录变量的索引。
索引数组 <code>f-&gt;locvars</code> 中的元素，其中元素类型为 <code>struct LocVar *</code> 。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 7: </span>lobject.h</label><pre class="src src-c"><span class="linenr">262: </span><span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">LocVar</span> {
<span class="linenr">263: </span>  <span class="org-type">TString</span> *<span class="org-variable-name">varname</span>;
<span class="linenr">264: </span>  <span class="org-type">int</span> <span class="org-variable-name">startpc</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">first point where variable is active</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">265: </span>  <span class="org-type">int</span> <span class="org-variable-name">endpc</span>;    <span class="org-comment-delimiter">/* </span><span class="org-comment">first point where variable is dead</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">266: </span>} <span class="org-type">LocVar</span>;
</pre>
</div>

<p>
LocVar 主要记录变量的名字， <code>startpc endpc</code> 在字节码层面记录其活动范围。
</p>

<p>
宏 getlocvar 精确描述了图示过程。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 8: </span>lparser.c</label><pre class="src src-c"><span class="linenr">32: </span><span class="org-preprocessor">#define</span> <span class="org-function-name">getlocvar</span>(<span class="org-variable-name">fs</span>, <span class="org-variable-name">i</span>)        ((fs)-&gt;f-&gt;locvars[(fs)-&gt;actvar[i]])
</pre>
</div>
</div>
</div>

<div id="outline-container-org1586eb8" class="outline-4">
<h4 id="org1586eb8"><span class="section-number-4">3.1.2</span> upvalue</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
upvalue 在本文翻译为上值，它即非 local，又不是 global。
直观从代码上看，即引用作用域之外的变量。
</p>

<p>
lua 将 function 作为基础类型之一，可以作为普通变量，参数，返回值，赋值，而四处流转。
又因为 local 变量的作用域限定于词法，这便是 upvalue 机制发挥作用的地方。
</p>

<p>
如下示例代码，
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-keyword">function</span> <span class="org-function-name">outer</span>()
   <span class="org-keyword">local</span> <span class="org-variable-name">a</span> = 0

   <span class="org-keyword">local</span> <span class="org-keyword">function</span> <span class="org-function-name">inner</span>()
      a = a + 1
      <span class="org-builtin">print</span>(a)
   <span class="org-keyword">end</span>

   inner()

   <span class="org-keyword">return</span> inner
<span class="org-keyword">end</span>

<span class="org-keyword">local</span> <span class="org-variable-name">f</span> = outer()

f()
f()
</pre>
</div>

<pre class="example">
1
2
3
</pre>


<p>
内部第 1 次调用 inner() 时，输出 1 。
当调用 outer()，将 inner 赋值与 f，调用两次 f() 得到 2 3 。
</p>

<p>
第 1 次调用 inner() 时，依然在 a 的作用域内，输出 1 是符合直觉的。
</p>

<p>
问题在于调用 f() 时，因为 a 只作用在 outer 的作用域，而 f 在 outer 作用域外部，
已经离开了 a 的作用域，这种情况下为何还可以访问 a ？
</p>

<p>
这便是闭包机制的由来，a 对于 inner 而言是 upvalue 类型。
这也是 lua 中为何 function 不是 function 而是 closure 的原因，function 及 upvalue 组成了 closure，
所有 func 在运行时都封装为 closure 来运行，其中重要的原因就在于单独分配 upvalue 空间并管理。
</p>

<p>
详细的说，第 1 次调用 inner() 时，local a 依然存活，称 upvalue a 为 open 状态。
当离开 outer() 作用域，upvalue a 为 close 状态。
</p>
</div>
</div>

<div id="outline-container-orgd75014a" class="outline-4">
<h4 id="orgd75014a"><span class="section-number-4">3.1.3</span> global</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
如果依然说，global 变量是除 local 变量和 upvalue 变量的变量，读者肯定不信服。
</p>

<p>
之所以存在 upvalue 和 global，隐含的一点是，在 lua 中外层变量对于内层是可见的，
既然是可见的，对于外层变量引用自然有一个查找的过程，变量类型正是在查找的过程中确定的。
</p>

<ul class="org-ul">
<li>在当前作用域中可以找到的，为 local 类型</li>
<li>在当前作用域之外的作用域可以找到的，为 upvalue 类型</li>
<li>所有作用域都无法找到的，为 global 类型</li>
</ul>

<p>
按照这个逻辑，顶层的 chunk 是没有 upvalue 的，在当前作用域中查找不到的变量，
只能是 global 类型。
</p>

<p>
setfenv 影响的就是函数的 global 环境，
设定不同的 global 表，可以影响内部对 global 的引用，
实现不同的运行效果，类似于封装成一个小沙盒，
</p>

<p>
比如如下代码，变量 a 对 outer inner 都是全局变量，所以全部修改都影响到 global a 的值。
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-keyword">function</span> <span class="org-function-name">outer</span>()
  a = 10

  <span class="org-keyword">local</span> <span class="org-keyword">function</span> <span class="org-function-name">inner</span>()
    a = a + 1
    <span class="org-keyword">return</span> a
  <span class="org-keyword">end</span>

  <span class="org-keyword">return</span> inner
<span class="org-keyword">end</span>

<span class="org-keyword">local</span> <span class="org-variable-name">f</span> = outer()

<span class="org-builtin">print</span>(f(), a)
<span class="org-builtin">print</span>(f(), a)
<span class="org-builtin">print</span>(f(), a)
</pre>
</div>

<pre class="example">
11	11
12	12
13	13
</pre>
</div>
</div>
</div>

<div id="outline-container-org817cea7" class="outline-3">
<h3 id="org817cea7"><span class="section-number-3">3.2</span> register</h3>
<div class="outline-text-3" id="text-3-2">
<p>
寄存器的主要作用是，存取 local 变量和存取中间结果。
</p>

<p>
寄存器在编译时是一个抽象的概念，没有具体的分配空间，编译器只知晓存在这块区域，
并且按照自己的需要来使用和调试。
</p>

<p>
而在实际运行时，寄存器存储在 vm 的栈中。
</p>
</div>
</div>
</div>


<div id="outline-container-orge88350e" class="outline-2">
<h2 id="orge88350e"><span class="section-number-2">4</span> statement</h2>
<div class="outline-text-2" id="text-4">
<p>
本节开始从实例具体分析代码生成的过程，和实例一起来探求其中的生成模式。
</p>

<p>
因为语法元素的递归性，其中的组合是无限的，所以本节只挑选讲解部分重要的“原子性”的部分，
至于各种组合的变数读者可自由探索。
</p>
</div>

<div id="outline-container-org0cad10c" class="outline-3">
<h3 id="org0cad10c"><span class="section-number-3">4.1</span> tool</h3>
<div class="outline-text-3" id="text-4-1">
<p>
在开始以实例为基础的探索之前，先详细介绍相应工具的使用。
</p>

<p>
以交互式启动 chunkspy，用于临时检验一些想法。
</p>

<pre class="example" id="org18a4815">
$ make spy
</pre>

<p>
分析特定 lua 文件，输出相应的编译结果。
</p>

<pre class="example" id="orgcb88db0">
$ make -s inspect source=lua_file_path
</pre>

<p>
比如分析如下代码，
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">a</span> = 1
</pre>
</div>

<p>
会输出如下结果，
</p>

<pre class="example" id="org643d6fb">
<span class="linenr">1: </span>; function [0] definition (level 1)
<span class="linenr">2: </span>; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
<span class="linenr">3: </span>.function  0 0 2 2
<span class="linenr">4: </span>.local  "a"  ; 0
<span class="linenr">5: </span>.const  1  ; 0
<span class="linenr">6: </span>[1] loadk      0   0        ; 1
<span class="linenr">7: </span>[2] return     0   1
<span class="linenr">8: </span>; end of function
</pre>

<p>
逐行来看，
</p>

<p>
line 1
</p>

<p>
level 1 指的是第一层级，即 chunk；
function [0] 表明是当前层级的第 1 个函数（以 0 开始索引）
</p>

<p>
line 2
</p>

<p>
函数有 0 个 upvalue，0 个参数，按 <code>0b010</code> 模式接收可变参数，需要分配栈容量 2。
</p>

<p>
line 3
</p>

<p>
意义和 line 2 相同，line 2 是 line 3 的注释
</p>

<p>
line 4 5
</p>

<p>
.local 列出所有局部变量的名称及索引，即 f-&gt;locvars 的内容
.const 列出 k 表的内容及索引
</p>

<p>
line 6 7
</p>

<p>
详细打印 f-&gt;code 指令，最终一行总是默认生成一条 return 指令
</p>

<p>
line 8
</p>

<p>
注释，表明 function 结束
</p>

<p>
读者结合 opcode 章节对各个指令功能的理解，不难理解 lua 代码和字节码的同义关系。
</p>
</div>
</div>

<div id="outline-container-orgdd72d50" class="outline-3">
<h3 id="orgdd72d50"><span class="section-number-3">4.2</span> local</h3>
<div class="outline-text-3" id="text-4-2">
<p>
先来观察 local 语句。
</p>

<p>
语法描述如下，
</p>

<div class="org-src-container">
<pre class="src src-bnf">stat      <span class="org-constant">::=</span> localstat
localstat <span class="org-constant">::=</span> LOCAL NAME {`,' NAME} [`=' explist]
localstat <span class="org-constant">::=</span> LOCAL FUNCTION NAME body
</pre>
</div>

<p>
localstat 可用于定义局部变量和局部函数。
</p>

<p>
函数部分到后面小节再讨论，对于局部变量，根据是否赋值可分为两种情况。
</p>
</div>

<div id="outline-container-org920841f" class="outline-4">
<h4 id="org920841f"><span class="section-number-4">4.2.1</span> no assignment</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
如下简单的代码示例，定义局部变量，无赋值，
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>, <span class="org-variable-name">c</span>
</pre>
</div>

<p>
分析得到如下结果，
</p>

<pre class="example" id="org9a10ff0">
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 3 stacks
.function  0 0 2 3
.local  "a"  ; 0
.local  "b"  ; 1
.local  "c"  ; 2
[1] return     0   1
; end of function
</pre>

<p>
示例代码只是单纯进行了局部变量的声明，最终没有生成任何字节码。
</p>

<p>
分析的过程，就是递归向下的函数过程， <code>chunk -&gt; stat -&gt; localstat</code> 。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 9: </span>lparser.c</label><pre class="src src-C"><span class="linenr">1179: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">localstat</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>) {
<span class="linenr">1180: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">stat -&gt; LOCAL NAME {`,' NAME} [`=' explist1]</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1181: </span>  <span class="org-type">int</span> <span class="org-variable-name">nvars</span> = 0;
<span class="linenr">1182: </span>  <span class="org-type">int</span> <span class="org-variable-name">nexps</span>;
<span class="linenr">1183: </span>  <span class="org-type">expdesc</span> <span class="org-variable-name">e</span>;
<span class="linenr">1184: </span>  <span class="org-keyword">do</span> {
<span id="coderef-new_localvar" class="coderef-off"><span class="linenr">1185: </span>    new_localvar(ls, str_checkname(ls), nvars++);</span>
<span class="linenr">1186: </span>  } <span class="org-keyword">while</span> (testnext(ls, <span class="org-string">','</span>));
<span class="linenr">1187: </span>  <span class="org-keyword">if</span> (testnext(ls, <span class="org-string">'='</span>))
<span class="linenr">1188: </span>    nexps = explist1(ls, &amp;e);
<span class="linenr">1189: </span>  <span class="org-keyword">else</span> {
<span class="linenr">1190: </span>    e.k = VVOID;
<span class="linenr">1191: </span>    nexps = 0;
<span class="linenr">1192: </span>  }
<span class="linenr">1193: </span>  adjust_assign(ls, nvars, nexps, &amp;e);
<span class="linenr">1194: </span>  adjustlocalvars(ls, nvars);
<span class="linenr">1195: </span>}
</pre>
</div>

<p>
关键在于 <a href="#coderef-new_localvar" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-new_localvar');" onmouseout="CodeHighlightOff(this, 'coderef-new_localvar');">new<sub>localvar</sub></a> 函数，在循环中读入 a b c，并进行变量分析。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 10: </span>lparser.c</label><pre class="src src-C"><span class="linenr">160: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">new_localvar</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>, <span class="org-type">TString</span> *<span class="org-variable-name">name</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span>) {
<span class="linenr">161: </span>  <span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span> = ls-&gt;fs;
<span class="linenr">162: </span>  luaY_checklimit(fs, fs-&gt;nactvar+n+1, LUAI_MAXVARS, <span class="org-string">"local variables"</span>);
<span class="linenr">163: </span>  fs-&gt;actvar[fs-&gt;nactvar+n] = cast(<span class="org-type">unsigned</span> <span class="org-type">short</span>, registerlocalvar(ls, name));
<span class="linenr">164: </span>}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 11: </span>lparser.c</label><pre class="src src-C"><span class="linenr">143: </span><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">registerlocalvar</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>, <span class="org-type">TString</span> *<span class="org-variable-name">varname</span>) {
<span class="linenr">144: </span>  <span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span> = ls-&gt;fs;
<span class="linenr">145: </span>  <span class="org-type">Proto</span> *<span class="org-variable-name">f</span> = fs-&gt;f;
<span class="linenr">146: </span>  <span class="org-type">int</span> <span class="org-variable-name">oldsize</span> = f-&gt;sizelocvars;
<span class="linenr">147: </span>  luaM_growvector(ls-&gt;L, f-&gt;locvars, fs-&gt;nlocvars, f-&gt;sizelocvars,
<span class="linenr">148: </span>                  LocVar, SHRT_MAX, <span class="org-string">"too many local variables"</span>);
<span class="linenr">149: </span>  <span class="org-keyword">while</span> (oldsize &lt; f-&gt;sizelocvars) f-&gt;locvars[oldsize++].varname = <span class="org-constant">NULL</span>;
<span class="linenr">150: </span>  f-&gt;locvars[fs-&gt;nlocvars].varname = varname;
<span class="linenr">151: </span>  luaC_objbarrier(ls-&gt;L, f, varname);
<span class="linenr">152: </span>  <span class="org-keyword">return</span> fs-&gt;nlocvars++;
<span class="linenr">153: </span>}
</pre>
</div>

<p>
其中根据变量出现的顺序，依次使用 registerlocalvar 得到变量索引，再记录到 <code>fs-&gt;actvar</code> 中。
</p>

<p>
这就是前面讨论过的，局部变量的存储方式，使用 <code>fs-&gt;actvar</code> 记录索引， <code>f-&gt;locvars</code> 记录变量名称。
</p>


<div id="orga644afe" class="figure">
<p><img src="generator-local-no-assign.png" alt="generator-local-no-assign.png">
</p>
</div>

<p>
<a href="#coderef-new_localvar" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-new_localvar');" onmouseout="CodeHighlightOff(this, 'coderef-new_localvar');">new<sub>locvar</sub></a> 完成的就是这个过程。
</p>

<p>
这也对应了 chunkspy 分析结果中的 .local 部分。
</p>
</div>
</div>

<div id="outline-container-org96bc860" class="outline-4">
<h4 id="org96bc860"><span class="section-number-4">4.2.2</span> with assignment</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
再来看 local 变量赋值的情况。
</p>

<p>
分析示例代码，得到如下结果，
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>, <span class="org-variable-name">c</span>, <span class="org-variable-name">d</span>, <span class="org-variable-name">e</span> = 10, <span class="org-string">"second"</span>, <span class="org-constant">nil</span>, <span class="org-constant">true</span>, <span class="org-constant">false</span>
</pre>
</div>

<pre class="example" id="orgebefacf">
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 5 stacks
.function  0 0 2 5
.local  "a"  ; 0
.local  "b"  ; 1
.local  "c"  ; 2
.local  "d"  ; 3
.local  "e"  ; 4
.const  10  ; 0
.const  "second"  ; 1
[1] loadk      0   0        ; 10
[2] loadk      1   1        ; "second"
[3] loadnil    2   2
[4] loadbool   3   1   0    ; true
[5] loadbool   4   0   0    ; false
[6] return     0   1
; end of function
</pre>

<p>
除了 .local 条目变多了，也增加了 .const 部分，意味着 k 表多出了 2 项记录。
</p>

<p>
依旧从 localstat 来分析，
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 12: </span>lparser.c</label><pre class="src src-C"><span class="linenr">1179: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">localstat</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>) {
<span class="linenr">1180: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">stat -&gt; LOCAL NAME {`,' NAME} [`=' explist1]</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1181: </span>  <span class="org-type">int</span> <span class="org-variable-name">nvars</span> = 0;
<span class="linenr">1182: </span>  <span class="org-type">int</span> <span class="org-variable-name">nexps</span>;
<span class="linenr">1183: </span>  <span class="org-type">expdesc</span> <span class="org-variable-name">e</span>;
<span class="linenr">1184: </span>  <span class="org-keyword">do</span> {
<span class="linenr">1185: </span>    new_localvar(ls, str_checkname(ls), nvars++);
<span class="linenr">1186: </span>  } <span class="org-keyword">while</span> (testnext(ls, <span class="org-string">','</span>));
<span class="linenr">1187: </span>  <span class="org-keyword">if</span> (testnext(ls, <span class="org-string">'='</span>))
<span id="coderef-localstat_explist" class="coderef-off"><span class="linenr">1188: </span>    nexps = explist1(ls, &amp;e);</span>
<span class="linenr">1189: </span>  <span class="org-keyword">else</span> {
<span class="linenr">1190: </span>    e.k = VVOID;
<span class="linenr">1191: </span>    nexps = 0;
<span class="linenr">1192: </span>  }
<span class="linenr">1193: </span>  adjust_assign(ls, nvars, nexps, &amp;e);
<span class="linenr">1194: </span>  adjustlocalvars(ls, nvars);
<span class="linenr">1195: </span>}
</pre>
</div>

<p>
在记录变量信息之后，遇到 <code>=</code> ，开始分析 <code>=</code> 后的 <a href="#coderef-localstat_explist" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-localstat_explist');" onmouseout="CodeHighlightOff(this, 'coderef-localstat_explist');">表达式列表</a> ，作为变量的赋值内容。
</p>

<p>
后面的表达式都是简单表达式，最终会调用 simpleexp 进行解析。
</p>

<div class="org-src-container">
<pre class="src src-bnf">explist      <span class="org-constant">::=</span> expr {`,' expr}
expr         <span class="org-constant">::=</span> subexpr
subexpr      <span class="org-constant">::=</span> (simpleexp <span class="org-warning">|</span> unop subexpr) {binop subexpr}

simpleexp    <span class="org-constant">::=</span> NUMBER <span class="org-warning">|</span> STRING <span class="org-warning">|</span> NIL <span class="org-warning">|</span> TRUE <span class="org-warning">|</span> FALSE <span class="org-warning">|</span> DOTS <span class="org-warning">|</span>
                 constructor <span class="org-warning">|</span> FUNCTION body <span class="org-warning">|</span> primaryexp
</pre>
</div>

<p>
下面有趣的地方来了，字节码和 k 表中的元素是何时生成的？
这就和代码生成的方式紧密相关了。
</p>

<p>
parser 模块中代码生成的强大在于，它是流式生成的。
意思即一边读入 token，分析状态，就直接生成代码！
</p>

<p>
从代码具体来看，
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="linenr">596: </span><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">explist1</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">v</span>) {
<span class="linenr">597: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">explist1 -&gt; expr { `,' expr }</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">598: </span>  <span class="org-type">int</span> <span class="org-variable-name">n</span> = 1;  <span class="org-comment-delimiter">/* </span><span class="org-comment">at least one expression</span><span class="org-comment-delimiter"> */</span>
<span id="coderef-fir_exp" class="coderef-off"><span class="linenr">599: </span>  expr(ls, v);</span>
<span class="linenr">600: </span>  <span class="org-keyword">while</span> (testnext(ls, <span class="org-string">','</span>)) {
<span id="coderef-fir_gen" class="coderef-off"><span class="linenr">601: </span>    luaK_exp2nextreg(ls-&gt;fs, v);</span>
<span id="coderef-sec_exp" class="coderef-off"><span class="linenr">602: </span>    expr(ls, v);</span>
<span class="linenr">603: </span>    n++;
<span class="linenr">604: </span>  }
<span class="linenr">605: </span>  <span class="org-keyword">return</span> n;
<span class="linenr">606: </span>}
</pre>
</div>

<p>
在<a href="#coderef-fir_exp" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-fir_exp');" onmouseout="CodeHighlightOff(this, 'coderef-fir_exp');">第 1 次分析表达式</a> 时，读入并分析了 10，并在 <a href="#coderef-sec_exp" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-sec_exp');" onmouseout="CodeHighlightOff(this, 'coderef-sec_exp');">第 2 次分析表达式 "second"</a> 之前，已经<a href="#coderef-fir_gen" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-fir_gen');" onmouseout="CodeHighlightOff(this, 'coderef-fir_gen');">生成代码并更新了 k 表</a>。
</p>

<p>
先来看 expr()，由于分析的是简单表达式，最终会调用 simpleexp 进行分析，
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="linenr">727: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">simpleexp</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">v</span>) {
<span class="linenr">728: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">simpleexp -&gt; NUMBER | STRING | NIL | true | false | ... |</span>
<span class="linenr">729: </span><span class="org-comment">                  constructor | FUNCTION body | primaryexp</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">730: </span>  <span class="org-keyword">switch</span> (ls-&gt;t.token) {
<span class="linenr">731: </span>    <span class="org-keyword">case</span> TK_NUMBER: {
<span class="linenr">732: </span>      init_exp(v, VKNUM, 0);
<span class="linenr">733: </span>      v-&gt;u.nval = ls-&gt;t.seminfo.r;
<span class="linenr">734: </span>      <span class="org-keyword">break</span>;
<span class="linenr">735: </span>    }
<span class="linenr">736: </span>    <span class="org-keyword">case</span> TK_STRING: {
<span class="linenr">737: </span>      codestring(ls, v, ls-&gt;t.seminfo.ts);
<span class="linenr">738: </span>      <span class="org-keyword">break</span>;
<span class="linenr">739: </span>    }
<span class="linenr">740: </span>    <span class="org-keyword">case</span> TK_NIL: {
<span class="linenr">741: </span>      init_exp(v, VNIL, 0);
<span class="linenr">742: </span>      <span class="org-keyword">break</span>;
<span class="linenr">743: </span>    }
<span class="linenr">744: </span>    <span class="org-keyword">case</span> TK_TRUE: {
<span class="linenr">745: </span>      init_exp(v, VTRUE, 0);
<span class="linenr">746: </span>      <span class="org-keyword">break</span>;
<span class="linenr">747: </span>    }
<span class="linenr">748: </span>    <span class="org-keyword">case</span> TK_FALSE: {
<span class="linenr">749: </span>      init_exp(v, VFALSE, 0);
<span class="linenr">750: </span>      <span class="org-keyword">break</span>;
<span class="linenr">751: </span>    }
<span class="linenr">752: </span>    <span class="org-keyword">case</span> TK_DOTS: {  <span class="org-comment-delimiter">/* </span><span class="org-comment">vararg</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">753: </span>      <span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span> = ls-&gt;fs;
<span class="linenr">754: </span>      check_condition(ls, fs-&gt;f-&gt;is_vararg,
<span class="linenr">755: </span>                      <span class="org-string">"cannot use "</span> LUA_QL(<span class="org-string">"..."</span>) <span class="org-string">" outside a vararg function"</span>);
<span class="linenr">756: </span>      fs-&gt;f-&gt;is_vararg &amp;= ~VARARG_NEEDSARG;  <span class="org-comment-delimiter">/* </span><span class="org-comment">don't need 'arg'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">757: </span>      init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 1, 0));
<span class="linenr">758: </span>      <span class="org-keyword">break</span>;
<span class="linenr">759: </span>    }
<span class="linenr">760: </span>    <span class="org-keyword">case</span> <span class="org-string">'{'</span>: {  <span class="org-comment-delimiter">/* </span><span class="org-comment">constructor</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">761: </span>      constructor(ls, v);
<span class="linenr">762: </span>      <span class="org-keyword">return</span>;
<span class="linenr">763: </span>    }
<span class="linenr">764: </span>    <span class="org-keyword">case</span> TK_FUNCTION: {
<span class="linenr">765: </span>      luaX_next(ls);
<span class="linenr">766: </span>      body(ls, v, 0, ls-&gt;linenumber);
<span class="linenr">767: </span>      <span class="org-keyword">return</span>;
<span class="linenr">768: </span>    }
<span class="linenr">769: </span>    <span class="org-keyword">default</span>: {
<span class="linenr">770: </span>      primaryexp(ls, v);
<span class="linenr">771: </span>      <span class="org-keyword">return</span>;
<span class="linenr">772: </span>    }
<span class="linenr">773: </span>  }
<span class="linenr">774: </span>  luaX_next(ls);
<span class="linenr">775: </span>}
</pre>
</div>

<p>
第 1 次分析 10 时，token 类型是 <code>TK_NUMBER</code> ，直接填充 expdesc 即可，
然后调用 luaK<sub>exp2nextreg</sub> 生成代码。
</p>

<p>
luaK<sub>exp2nextreg</sub> 是一个综合过程，由更基础的几个函数组成。
</p>

<p>
深入分析之前，先来补充之前 FuncState 未描述的一个字段，freereg。
</p>

<p>
字节码被 vm 运行时，vm 维持一个栈，来存放寄存器和中间结果。
编译器只知晓这个栈的存在，但是在编译时，这个栈并没有真实存在，
只能凭借想象去操作它。
</p>

<p>
freereg 就是用来记录栈顶的变量。
</p>

<p>
当存储新的寄存器值时，freereg 就会自增，为寄存器开出空间；
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 13: </span>lcode.c</label><pre class="src src-c"><span class="linenr">209: </span><span class="org-type">void</span> <span class="org-function-name">luaK_reserveregs</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span>) {
<span class="linenr">210: </span>  luaK_checkstack(fs, n);
<span class="linenr">211: </span>  fs-&gt;freereg += n;
<span class="linenr">212: </span>}
</pre>
</div>

<p>
相应的，如果寄存器不再使用，freereg 会自减，回收相应的空间。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 14: </span>lcode.c</label><pre class="src src-c"><span class="linenr">215: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">freereg</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">int</span> <span class="org-variable-name">reg</span>) {
<span class="linenr">216: </span>  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>ISK(reg) &amp;&amp; reg &gt;= fs-&gt;nactvar) {
<span class="linenr">217: </span>    fs-&gt;freereg--;
<span class="linenr">218: </span>    lua_assert(reg == fs-&gt;freereg);
<span class="linenr">219: </span>  }
<span class="linenr">220: </span>}
</pre>
</div>

<p>
从中可以看出，freereg 将栈分为两部分，在栈底为 local 变量保留空间（reg &gt;= fs-&gt;nactvar），
上层用于计算中间结果。
</p>


<div id="org8cd5a39" class="figure">
<p><img src="generator-freereg-stack.png" alt="generator-freereg-stack.png">
</p>
</div>


<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 15: </span>lcode.c</label><pre class="src src-c"><span class="linenr">414: </span><span class="org-type">void</span> <span class="org-function-name">luaK_exp2nextreg</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">e</span>) {
<span class="linenr">415: </span>  luaK_dischargevars(fs, e);
<span class="linenr">416: </span>  freeexp(fs, e);
<span class="linenr">417: </span>  luaK_reserveregs(fs, 1);
<span class="linenr">418: </span>  exp2reg(fs, e, fs-&gt;freereg - 1);
<span class="linenr">419: </span>}
</pre>
</div>

<p>
在 luaK<sub>exp2nextreg</sub> 中，先找出下一个可用的栈/寄存器空间，然后将表达式的值解析到寄存器中，
即生成字节码。
</p>

<p>
最终在 discharge2reg 函数生成相应指令 loadk。
</p>

<p>
这里出现了第二个重点，对 k 表的操作。
</p>

<p>
因为其类型为数字，所以调用的是 luaK<sub>numberK</sub>。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 16: </span>lcode.c</label><pre class="src src-c"><span class="linenr">229: </span><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">addk</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">TValue</span> *<span class="org-variable-name">k</span>, <span class="org-type">TValue</span> *<span class="org-variable-name">v</span>) {
<span class="linenr">230: </span>  <span class="org-type">lua_State</span> *<span class="org-variable-name">L</span> = fs-&gt;L;
<span class="linenr">231: </span>  <span class="org-type">TValue</span> *<span class="org-variable-name">idx</span> = luaH_set(L, fs-&gt;h, k);
<span class="linenr">232: </span>  <span class="org-type">Proto</span> *<span class="org-variable-name">f</span> = fs-&gt;f;
<span class="linenr">233: </span>  <span class="org-type">int</span> <span class="org-variable-name">oldsize</span> = f-&gt;sizek;
<span class="linenr">234: </span>  <span class="org-keyword">if</span> (ttisnumber(idx)) {
<span class="linenr">235: </span>    lua_assert(luaO_rawequalObj(&amp;fs-&gt;f-&gt;k[cast_int(nvalue(idx))], v));
<span class="linenr">236: </span>    <span class="org-keyword">return</span> cast_int(nvalue(idx));
<span class="linenr">237: </span>  }
<span class="linenr">238: </span>  <span class="org-keyword">else</span> {  <span class="org-comment-delimiter">/* </span><span class="org-comment">constant not found; create a new entry</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">239: </span>    setnvalue(idx, cast_num(fs-&gt;nk));
<span class="linenr">240: </span>    luaM_growvector(L, f-&gt;k, fs-&gt;nk, f-&gt;sizek, TValue,
<span class="linenr">241: </span>                    MAXARG_Bx, <span class="org-string">"constant table overflow"</span>);
<span class="linenr">242: </span>    <span class="org-keyword">while</span> (oldsize &lt; f-&gt;sizek) setnilvalue(&amp;f-&gt;k[oldsize++]);
<span class="linenr">243: </span>    setobj(L, &amp;f-&gt;k[fs-&gt;nk], v);
<span class="linenr">244: </span>    luaC_barrier(L, f, v);
<span class="linenr">245: </span>    <span class="org-keyword">return</span> fs-&gt;nk++;
<span class="linenr">246: </span>  }
<span class="linenr">247: </span>}
<span class="linenr">248: </span>
<span class="linenr">249: </span>
<span class="linenr">250: </span><span class="org-type">int</span> <span class="org-function-name">luaK_stringK</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">TString</span> *<span class="org-variable-name">s</span>) {
<span class="linenr">251: </span>  <span class="org-type">TValue</span> <span class="org-variable-name">o</span>;
<span class="linenr">252: </span>  setsvalue(fs-&gt;L, &amp;o, s);
<span class="linenr">253: </span>  <span class="org-keyword">return</span> addk(fs, &amp;o, &amp;o);
<span class="linenr">254: </span>}
<span class="linenr">255: </span>
<span class="linenr">256: </span>
<span class="linenr">257: </span><span class="org-type">int</span> <span class="org-function-name">luaK_numberK</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">lua_Number</span> <span class="org-variable-name">r</span>) {
<span class="linenr">258: </span>  <span class="org-type">TValue</span> <span class="org-variable-name">o</span>;
<span class="linenr">259: </span>  setnvalue(&amp;o, r);
<span class="linenr">260: </span>  <span class="org-keyword">return</span> addk(fs, &amp;o, &amp;o);
<span class="linenr">261: </span>}
<span class="linenr">262: </span>
<span class="linenr">263: </span>
<span class="linenr">264: </span><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">boolK</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span>) {
<span class="linenr">265: </span>  <span class="org-type">TValue</span> <span class="org-variable-name">o</span>;
<span class="linenr">266: </span>  setbvalue(&amp;o, b);
<span class="linenr">267: </span>  <span class="org-keyword">return</span> addk(fs, &amp;o, &amp;o);
<span class="linenr">268: </span>}
<span class="linenr">269: </span>
<span class="linenr">270: </span>
<span class="linenr">271: </span><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">nilK</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>) {
<span class="linenr">272: </span>  <span class="org-type">TValue</span> <span class="org-variable-name">k</span>, <span class="org-variable-name">v</span>;
<span class="linenr">273: </span>  setnilvalue(&amp;v);
<span class="linenr">274: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">cannot use nil as key; instead use table itself to represent nil</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">275: </span>  sethvalue(fs-&gt;L, &amp;k, fs-&gt;h);
<span class="linenr">276: </span>  <span class="org-keyword">return</span> addk(fs, &amp;k, &amp;v);
<span class="linenr">277: </span>}
</pre>
</div>

<p>
所有操作 k 表的方法，最终都使用 addk 操作，其作用也很简单，
在 k 表中搜索，如果存在，则直接返回相应索引，其中使用 table fs-&gt;h 做 k 表元素的反向索引，加快搜索过程；
若不存在，则自增，并返回相应的索引。
</p>


<div id="org344e2cf" class="figure">
<p><img src="generator-numberk-10.png" alt="generator-numberk-10.png">
</p>
</div>

<p>
将数字 10 存储入 k 表之后，生成 loadk 指令，将 freereg 和 k 索引作为其操作数。
</p>

<p>
至此，parser 只读入了 token 10，便已经完成了操作 k 表，记录常数，并生成对应的指令，令人惊奇。
</p>

<p>
对于第 2 个表达式 "second"，在 simpleexp 时，提前调用 codestring 加入了 k 表，
将其作为 VK 类型来对待。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 17: </span>lparser.c</label><pre class="src src-c"><span class="linenr">133: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">codestring</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">e</span>, <span class="org-type">TString</span> *<span class="org-variable-name">s</span>) {
<span class="linenr">134: </span>  init_exp(e, VK, luaK_stringK(ls-&gt;fs, s));
<span class="linenr">135: </span>}
</pre>
</div>


<div id="org15db107" class="figure">
<p><img src="generator-stringk-second.png" alt="generator-stringk-second.png">
</p>
</div>

<p>
同样的生成 loadk 指令。
</p>

<p>
回到 localstat()，前面对变量和表达式进行解析之后，记录了 <code>=</code> 两边的数量 nvars nexps，
<code>adjust_assign()</code> 进行左右数量的调整，多余的 var 空间置为 nil，多余的 exp 则省略。
</p>

<p>
最终调用 <code>adjustlocalvars()</code> 调整 fs-&gt;nactvar 的值。
</p>
</div>
</div>
</div>


<div id="outline-container-orgacae4b5" class="outline-3">
<h3 id="orgacae4b5"><span class="section-number-3">4.3</span> expdesc</h3>
<div class="outline-text-3" id="text-4-3">
<p>
从 localstat 的示例中，已经看到代码生成的逻辑是别具一格的。
</p>

<p>
结合递归下降，语法制导，后缀顺序，vm opcode 语义，得以以线性顺序生成字节码。
</p>

<p>
其中 expdesc 的作用是非常重要的，将一些属性附加到文法符号上，辅助代码生成过程。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 18: </span>lparser.h</label><pre class="src src-c"><span class="org-comment-delimiter">/*</span>
<span class="org-comment">** Expression descriptor</span>
<span class="org-comment-delimiter">*/</span>

<span class="org-keyword">typedef</span> <span class="org-keyword">enum</span> {
  <span class="org-variable-name">VVOID</span>,        <span class="org-comment-delimiter">/* </span><span class="org-comment">no value</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VNIL</span>,
  <span class="org-variable-name">VTRUE</span>,
  <span class="org-variable-name">VFALSE</span>,
  <span class="org-variable-name">VK</span>,           <span class="org-comment-delimiter">/* </span><span class="org-comment">info = index of constant in `k'</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VKNUM</span>,        <span class="org-comment-delimiter">/* </span><span class="org-comment">nval = numerical value</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VLOCAL</span>,       <span class="org-comment-delimiter">/* </span><span class="org-comment">info = local register</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VUPVAL</span>,       <span class="org-comment-delimiter">/* </span><span class="org-comment">info = index of upvalue in `upvalues'</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VGLOBAL</span>,      <span class="org-comment-delimiter">/* </span><span class="org-comment">info = index of table; aux = index of global name in `k'</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VINDEXED</span>,     <span class="org-comment-delimiter">/* </span><span class="org-comment">info = table register; aux = index register (or `k')</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VJMP</span>,         <span class="org-comment-delimiter">/* </span><span class="org-comment">info = instruction pc</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VRELOCABLE</span>,   <span class="org-comment-delimiter">/* </span><span class="org-comment">info = instruction pc</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VNONRELOC</span>,    <span class="org-comment-delimiter">/* </span><span class="org-comment">info = result register</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VCALL</span>,        <span class="org-comment-delimiter">/* </span><span class="org-comment">info = instruction pc</span><span class="org-comment-delimiter"> */</span>
  <span class="org-variable-name">VVARARG</span>       <span class="org-comment-delimiter">/* </span><span class="org-comment">info = instruction pc</span><span class="org-comment-delimiter"> */</span>
} <span class="org-type">expkind</span>;

<span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">expdesc</span> {
  <span class="org-type">expkind</span> <span class="org-variable-name">k</span>;
  <span class="org-keyword">union</span> {
    <span class="org-keyword">struct</span> { <span class="org-type">int</span> <span class="org-variable-name">info</span>, <span class="org-variable-name">aux</span>; } <span class="org-variable-name">s</span>;
    <span class="org-type">lua_Number</span> <span class="org-variable-name">nval</span>;
  } <span class="org-variable-name">u</span>;
  <span class="org-type">int</span> <span class="org-variable-name">t</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">patch list of `exit when true'</span><span class="org-comment-delimiter"> */</span>
  <span class="org-type">int</span> <span class="org-variable-name">f</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">patch list of `exit when false'</span><span class="org-comment-delimiter"> */</span>
} <span class="org-type">expdesc</span>;
</pre>
</div>

<p>
expdesc 用于记录 exp 表达式的相关信息。
</p>

<p>
和 token 类型类似，expdesc 内部有字段记录类型，其它字段记录附加信息。
</p>

<p>
所有类型用 enum expkind 表示，相应类型后的注释描述了对应其它字段需要记录的信息。
</p>

<p>
其中重点的函数是 discharge2reg 和 dischargevars，用于解析相应的 expdesc，生成代码并更新状态。
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">expkind</th>
<th scope="col" class="org-left">u</th>
<th scope="col" class="org-left">discharge</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">VVOID</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">VNIL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">生成指令 loadnil，重置为 VNONRELOC</td>
</tr>

<tr>
<td class="org-left">VTRUE</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">生成指令 loadbool，重置为 VNONRELOC</td>
</tr>

<tr>
<td class="org-left">VFALSE</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">生成指令 loadbool，重置为 VNONRELOC</td>
</tr>

<tr>
<td class="org-left">VK</td>
<td class="org-left">info 记录 k 表索引</td>
<td class="org-left">生成指令 loadk，重置为 VNONRELOC</td>
</tr>

<tr>
<td class="org-left">VKNUM</td>
<td class="org-left">nval 记录数值</td>
<td class="org-left">生成指令 loadk，重置为 VNONRELOC</td>
</tr>

<tr>
<td class="org-left">VLOCAL</td>
<td class="org-left">info 记录寄存器索引</td>
<td class="org-left">重置为 VNONRELOC</td>
</tr>

<tr>
<td class="org-left">VUPVAL</td>
<td class="org-left">info 记录 upvalues 数组中的索引</td>
<td class="org-left">生成指令 GETUPVAL, 重置为 VRELOCABLE，info 记录指令索引</td>
</tr>

<tr>
<td class="org-left">VGLOBAL</td>
<td class="org-left">info 全局表的索引，aux 全局名称的 k 表索引</td>
<td class="org-left">生成指令 GETGLOBAL, 重置为 VRELOCABLE，info 记录指令索引</td>
</tr>

<tr>
<td class="org-left">VINDEXED</td>
<td class="org-left">info table 所在寄存器的索引，aux 索引值的 RK 值</td>
<td class="org-left">生成指令 GETTABLE, 重置为 VRELOCABLE，info 记录指令索引</td>
</tr>

<tr>
<td class="org-left">VJMP</td>
<td class="org-left">info 当前指令索引</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">VRELOCABLE</td>
<td class="org-left">info 当前指令索引</td>
<td class="org-left">定位到指令位置，修改 A 参数为 reg</td>
</tr>

<tr>
<td class="org-left">VNONRELOC</td>
<td class="org-left">info 最终解析得到的寄存器位置</td>
<td class="org-left">如果当前寄存器位置与目标位置不同，则生成 move 指令；相同则什么都不做</td>
</tr>

<tr>
<td class="org-left">VCALL</td>
<td class="org-left">info 当前指令索引</td>
<td class="org-left">重置为 VNONRELOC，info 记录指令的 A 参数</td>
</tr>

<tr>
<td class="org-left">VVARARG</td>
<td class="org-left">info 当前指令索引</td>
<td class="org-left">重置为 VRELOCABLE</td>
</tr>
</tbody>
</table>

<p>
具体如此设计的原因及作用，还需要读者在不同情况下再尝试领会。
</p>
</div>
</div>

<div id="outline-container-org0b27cc4" class="outline-3">
<h3 id="org0b27cc4"><span class="section-number-3">4.4</span> assign</h3>
<div class="outline-text-3" id="text-4-4">
<p>
本节来探讨赋值语句
</p>

<div class="org-src-container">
<pre class="src src-bnf">stat         <span class="org-constant">::=</span> exprstat
exprstat     <span class="org-constant">::=</span> assignstat

assignstat   <span class="org-constant">::=</span> (prefixexp <span class="org-warning">|</span> primaryexp (`.' NAME <span class="org-warning">|</span> `[' expr `]')) assignment
assignment   <span class="org-constant">::=</span> `,' assignstat <span class="org-warning">|</span> `=' explist

primaryexp   <span class="org-constant">::=</span> prefixexp {`.' NAME <span class="org-warning">|</span> `[' expr `]' <span class="org-warning">|</span> `:' NAME funcargs <span class="org-warning">|</span> funcargs}
prefixexp    <span class="org-constant">::=</span> NAME <span class="org-warning">|</span> `(' expr `)'
</pre>
</div>

<p>
赋值语句根据变量的类型不同，分为 global upvalue local indexed 几种情况，
对应 expdesc 中的 VGLOBAL VUPVAL VLOCAL VINDEXED。
</p>
</div>

<div id="outline-container-org89d4702" class="outline-4">
<h4 id="org89d4702"><span class="section-number-4">4.4.1</span> global</h4>
<div class="outline-text-4" id="text-4-4-1">
<p>
先来看 global 的赋值情况。
</p>

<p>
分析如下代码，
</p>

<div class="org-src-container">
<pre class="src src-lua">a, b, c = 10, 20, 30
</pre>
</div>

<pre class="example" id="org6fc4cc8">
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 3 stacks
.function  0 0 2 3
.const  "a"  ; 0
.const  "b"  ; 1
.const  "c"  ; 2
.const  10  ; 3
.const  20  ; 4
.const  30  ; 5
[1] loadk      0   3        ; 10
[2] loadk      1   4        ; 20
[3] loadk      2   5        ; 30
[4] setglobal  2   2        ; c
[5] setglobal  1   1        ; b
[6] setglobal  0   0        ; a
[7] return     0   1
; end of function
</pre>

<p>
从 chunk 递归向下，最终到达 assignment 函数。
</p>

<p>
从 ebnf 描述中可以看出，assignment 是一个递归的过程。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 19: </span>lparser.c</label><pre class="src src-c"><span class="linenr">931: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">assignment</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>, <span class="org-keyword">struct</span> <span class="org-type">LHS_assign</span> *<span class="org-variable-name">lh</span>, <span class="org-type">int</span> <span class="org-variable-name">nvars</span>) {
<span class="linenr">932: </span>  <span class="org-type">expdesc</span> <span class="org-variable-name">e</span>;
<span class="linenr">933: </span>  check_condition(ls, VLOCAL &lt;= lh-&gt;v.k &amp;&amp; lh-&gt;v.k &lt;= VINDEXED,
<span class="linenr">934: </span>                      <span class="org-string">"syntax error"</span>);
<span class="linenr">935: </span>  <span class="org-keyword">if</span> (testnext(ls, <span class="org-string">','</span>)) {  <span class="org-comment-delimiter">/* </span><span class="org-comment">assignment -&gt; `,' primaryexp assignment</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">936: </span>    <span class="org-keyword">struct</span> <span class="org-type">LHS_assign</span> <span class="org-variable-name">nv</span>;
<span class="linenr">937: </span>    nv.prev = lh;
<span class="linenr">938: </span>    primaryexp(ls, &amp;nv.v);
<span class="linenr">939: </span>    <span class="org-keyword">if</span> (nv.v.k == VLOCAL)
<span class="linenr">940: </span>      check_conflict(ls, lh, &amp;nv.v);
<span class="linenr">941: </span>    luaY_checklimit(ls-&gt;fs, nvars, LUAI_MAXCCALLS - ls-&gt;L-&gt;nCcalls,
<span class="linenr">942: </span>                    <span class="org-string">"variables in assignment"</span>);
<span class="linenr">943: </span>    assignment(ls, &amp;nv, nvars+1);
<span class="linenr">944: </span>  }
<span class="linenr">945: </span>  <span class="org-keyword">else</span> {  <span class="org-comment-delimiter">/* </span><span class="org-comment">assignment -&gt; `=' explist1</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">946: </span>    <span class="org-type">int</span> <span class="org-variable-name">nexps</span>;
<span class="linenr">947: </span>    checknext(ls, <span class="org-string">'='</span>);
<span class="linenr">948: </span>    nexps = explist1(ls, &amp;e);
<span class="linenr">949: </span>    <span class="org-keyword">if</span> (nexps != nvars) {
<span class="linenr">950: </span>      adjust_assign(ls, nvars, nexps, &amp;e);
<span class="linenr">951: </span>      <span class="org-keyword">if</span> (nexps &gt; nvars)
<span class="linenr">952: </span>        ls-&gt;fs-&gt;freereg -= nexps - nvars;  <span class="org-comment-delimiter">/* </span><span class="org-comment">remove extra values</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">953: </span>    }
<span class="linenr">954: </span>    <span class="org-keyword">else</span> {
<span class="linenr">955: </span>      luaK_setoneret(ls-&gt;fs, &amp;e);  <span class="org-comment-delimiter">/* </span><span class="org-comment">close last expression</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">956: </span>      luaK_storevar(ls-&gt;fs, &amp;lh-&gt;v, &amp;e);
<span class="linenr">957: </span>      <span class="org-keyword">return</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">avoid default</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">958: </span>    }
<span class="linenr">959: </span>  }
<span class="linenr">960: </span>  init_exp(&amp;e, VNONRELOC, ls-&gt;fs-&gt;freereg-1);  <span class="org-comment-delimiter">/* </span><span class="org-comment">default assignment</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">961: </span>  luaK_storevar(ls-&gt;fs, &amp;lh-&gt;v, &amp;e);
<span class="linenr">962: </span>}
</pre>
</div>

<p>
在遇到 <code>=</code> 之前，执行 if 语句块，递归调用 primaryexp 分析变量；
遇到 <code>=</code> 之后，执行 else 语句块，分析表达式。
在递归的终点，将表达式得到的值赋值给变量。
</p>

<p>
因为示例代码中变量都很简单，primaryexp 主要调用 prefixexp 进行分析。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 20: </span>lparser.c</label><pre class="src src-c"><span class="linenr">667: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">prefixexp</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">v</span>) {
<span class="linenr">668: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">prefixexp -&gt; NAME | '(' expr ')'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">669: </span>  <span class="org-keyword">switch</span> (ls-&gt;t.token) {
<span class="linenr">670: </span>    <span class="org-keyword">case</span> <span class="org-string">'('</span>: {
<span class="linenr">671: </span>      <span class="org-type">int</span> <span class="org-variable-name">line</span> = ls-&gt;linenumber;
<span class="linenr">672: </span>      luaX_next(ls);
<span class="linenr">673: </span>      expr(ls, v);
<span class="linenr">674: </span>      check_match(ls, <span class="org-string">')'</span>, <span class="org-string">'('</span>, line);
<span class="linenr">675: </span>      luaK_dischargevars(ls-&gt;fs, v);
<span class="linenr">676: </span>      <span class="org-keyword">return</span>;
<span class="linenr">677: </span>    }
<span class="linenr">678: </span>    <span class="org-keyword">case</span> TK_NAME: {
<span class="linenr">679: </span>      singlevar(ls, v);
<span class="linenr">680: </span>      <span class="org-keyword">return</span>;
<span class="linenr">681: </span>    }
<span class="linenr">682: </span>    <span class="org-keyword">default</span>: {
<span class="linenr">683: </span>      luaX_syntaxerror(ls, <span class="org-string">"unexpected symbol"</span>);
<span class="linenr">684: </span>      <span class="org-keyword">return</span>;
<span class="linenr">685: </span>    }
<span class="linenr">686: </span>  }
<span class="linenr">687: </span>}
</pre>
</div>

<p>
对应其中的 <code>TK_NAME</code> 类型，调用 singlevar 确定变量的类型，内容调用 singlevaraux 来实现。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 21: </span>lparser.c</label><pre class="src src-c"><span class="linenr">224: </span><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">singlevaraux</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">TString</span> *<span class="org-variable-name">n</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">var</span>, <span class="org-type">int</span> <span class="org-variable-name">base</span>) {
<span class="linenr">225: </span>  <span class="org-keyword">if</span> (fs == <span class="org-constant">NULL</span>) {  <span class="org-comment-delimiter">/* </span><span class="org-comment">no more levels?</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">226: </span>    init_exp(var, VGLOBAL, NO_REG);  <span class="org-comment-delimiter">/* </span><span class="org-comment">default is global variable</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">227: </span>    <span class="org-keyword">return</span> VGLOBAL;
<span class="linenr">228: </span>  }
<span class="linenr">229: </span>  <span class="org-keyword">else</span> {
<span class="linenr">230: </span>    <span class="org-type">int</span> <span class="org-variable-name">v</span> = searchvar(fs, n);  <span class="org-comment-delimiter">/* </span><span class="org-comment">look up at current level</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">231: </span>    <span class="org-keyword">if</span> (v &gt;= 0) {
<span class="linenr">232: </span>      init_exp(var, VLOCAL, v);
<span class="linenr">233: </span>      <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>base)
<span class="linenr">234: </span>        markupval(fs, v);  <span class="org-comment-delimiter">/* </span><span class="org-comment">local will be used as an upval</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">235: </span>      <span class="org-keyword">return</span> VLOCAL;
<span class="linenr">236: </span>    }
<span class="linenr">237: </span>    <span class="org-keyword">else</span> {  <span class="org-comment-delimiter">/* </span><span class="org-comment">not found at current level; try upper one</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">238: </span>      <span class="org-keyword">if</span> (singlevaraux(fs-&gt;prev, n, var, 0) == VGLOBAL)
<span class="linenr">239: </span>        <span class="org-keyword">return</span> VGLOBAL;
<span class="linenr">240: </span>      var-&gt;u.s.info = indexupvalue(fs, n, var);  <span class="org-comment-delimiter">/* </span><span class="org-comment">else was LOCAL or UPVAL</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">241: </span>      var-&gt;k = VUPVAL;  <span class="org-comment-delimiter">/* </span><span class="org-comment">upvalue in this level</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">242: </span>      <span class="org-keyword">return</span> VUPVAL;
<span class="linenr">243: </span>    }
<span class="linenr">244: </span>  }
<span class="linenr">245: </span>}
<span class="linenr">246: </span>
<span class="linenr">247: </span>
<span class="linenr">248: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">singlevar</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">var</span>) {
<span class="linenr">249: </span>  <span class="org-type">TString</span> *<span class="org-variable-name">varname</span> = str_checkname(ls);
<span class="linenr">250: </span>  <span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span> = ls-&gt;fs;
<span class="linenr">251: </span>  <span class="org-keyword">if</span> (singlevaraux(fs, varname, var, 1) == VGLOBAL)
<span class="linenr">252: </span>    var-&gt;u.s.info = luaK_stringK(fs, varname);  <span class="org-comment-delimiter">/* </span><span class="org-comment">info points to global name</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">253: </span>}
</pre>
</div>

<p>
singlevaraux 是非常关键的过程，回忆之前在分析过程中，关于嵌套的 function 定义和 fs-&gt;prev 的链条，
singlevaraux 就顺着 fs-&gt;prev 不断向上层作用域寻找变量。
</p>

<p>
如果 <code>fs == NULL</code> ，说明已经到顶层，变量只能为 global 类型；
如果在当前作用域可找到，说明是 local 变量；其它为 upval 变量。
</p>

<p>
示例中 a b c 都为全局变量，所以 singlevaraux 返回 VGLOBAL，
将相应 expdesc 类型赋值为 VGLOBAL，且 info 存储了变量名对应的 k 表索引。
</p>

<p>
表达式分析阶段，将 10 20 30 加入 k 表，同时载入寄存器。
</p>

<p>
最终赋值阶段，在每个递归层次，用 luaK<sub>storevar</sub> 来存储。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 22: </span>lcode.c</label><pre class="src src-c"><span class="linenr">472: </span><span class="org-type">void</span> <span class="org-function-name">luaK_storevar</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">var</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">ex</span>) {
<span class="linenr">473: </span>  <span class="org-keyword">switch</span> (var-&gt;k) {
<span class="linenr">474: </span>    <span class="org-keyword">case</span> VLOCAL: {
<span class="linenr">475: </span>      freeexp(fs, ex);
<span class="linenr">476: </span>      exp2reg(fs, ex, var-&gt;u.s.info);
<span class="linenr">477: </span>      <span class="org-keyword">return</span>;
<span class="linenr">478: </span>    }
<span class="linenr">479: </span>    <span class="org-keyword">case</span> VUPVAL: {
<span class="linenr">480: </span>      <span class="org-type">int</span> <span class="org-variable-name">e</span> = luaK_exp2anyreg(fs, ex);
<span class="linenr">481: </span>      luaK_codeABC(fs, OP_SETUPVAL, e, var-&gt;u.s.info, 0);
<span class="linenr">482: </span>      <span class="org-keyword">break</span>;
<span class="linenr">483: </span>    }
<span class="linenr">484: </span>    <span class="org-keyword">case</span> VGLOBAL: {
<span class="linenr">485: </span>      <span class="org-type">int</span> <span class="org-variable-name">e</span> = luaK_exp2anyreg(fs, ex);
<span class="linenr">486: </span>      luaK_codeABx(fs, OP_SETGLOBAL, e, var-&gt;u.s.info);
<span class="linenr">487: </span>      <span class="org-keyword">break</span>;
<span class="linenr">488: </span>    }
<span class="linenr">489: </span>    <span class="org-keyword">case</span> VINDEXED: {
<span class="linenr">490: </span>      <span class="org-type">int</span> <span class="org-variable-name">e</span> = luaK_exp2RK(fs, ex);
<span class="linenr">491: </span>      luaK_codeABC(fs, OP_SETTABLE, var-&gt;u.s.info, var-&gt;u.s.aux, e);
<span class="linenr">492: </span>      <span class="org-keyword">break</span>;
<span class="linenr">493: </span>    }
<span class="linenr">494: </span>    <span class="org-keyword">default</span>: {
<span class="linenr">495: </span>      lua_assert(0);  <span class="org-comment-delimiter">/* </span><span class="org-comment">invalid var kind to store</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">496: </span>      <span class="org-keyword">break</span>;
<span class="linenr">497: </span>    }
<span class="linenr">498: </span>  }
<span class="linenr">499: </span>  freeexp(fs, ex);
<span class="linenr">500: </span>}
</pre>
</div>

<p>
对应 case VGLOBAL，生成 setglobal 指令。
</p>
</div>
</div>

<div id="outline-container-org63c9e32" class="outline-4">
<h4 id="org63c9e32"><span class="section-number-4">4.4.2</span> upvalue</h4>
<div class="outline-text-4" id="text-4-4-2">
<p>
分析如下代码，
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">a</span>

<span class="org-keyword">function</span> <span class="org-function-name">f</span>()
  a = 10
<span class="org-keyword">end</span>
</pre>
</div>

<pre class="example" id="org7651038">
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  "a"  ; 0
.const  "f"  ; 0

  ; function [0] definition (level 2)
  ; 1 upvalues, 0 params, 0 is_vararg, 2 stacks
  .function  1 0 0 2
  .upvalue  "a"  ; 0
  .const  10  ; 0
  [1] loadk      0   0        ; 10
  [2] setupval   0   0        ; a
  [3] return     0   1
  ; end of function

[1] closure    1   0        ; 1 upvalues
[2] move       0   0
[3] setglobal  1   0        ; f
[4] return     0   1
; end of function
</pre>

<p>
对于外层函数，a 是 local 变量，而对应内层函数，a 为 upval 变量。
</p>

<p>
基本过程同 global，不过 singlevaraux 搜索得到 VUPVAL，生成 setupval 指令。
</p>
</div>
</div>

<div id="outline-container-orgac4e87b" class="outline-4">
<h4 id="orgac4e87b"><span class="section-number-4">4.4.3</span> local</h4>
<div class="outline-text-4" id="text-4-4-3">
<div class="org-src-container">
<pre class="src src-lua"><span class="linenr">1: </span><span class="org-keyword">local</span> <span class="org-variable-name">a</span> = 1
<span class="linenr">2: </span>
<span class="linenr">3: </span><span class="org-keyword">local</span> <span class="org-variable-name">b</span>
<span class="linenr">4: </span>b = 1
</pre>
</div>

<p>
line 1 为 local 赋值语句，而 line 4 为普通赋值语句，不过恰巧赋值给 local 变量。
</p>

<p>
分析如下示例，
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>

b = 10
</pre>
</div>

<pre class="example" id="orgb0cfc4a">
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  "a"  ; 0
.local  "b"  ; 1
.const  10  ; 0
[1] loadk      1   0        ; 10
[2] return     0   1
; end of function
</pre>

<p>
分析过程与上相同，singlevaraux 确定为 VLOCAL，针对寄存器位置，直接生成 loadk。
</p>
</div>
</div>

<div id="outline-container-orgcc86fa7" class="outline-4">
<h4 id="orgcc86fa7"><span class="section-number-4">4.4.4</span> indexed</h4>
<div class="outline-text-4" id="text-4-4-4">
<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">t</span> = {}

t[<span class="org-string">'a'</span>] = 10
</pre>
</div>

<pre class="example" id="org88345e7">
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  "t"  ; 0
.const  "a"  ; 0
.const  10  ; 1
[1] newtable   0   0   0    ; array=0, hash=0
[2] settable   0   256 257  ; "a" 10
[3] return     0   1
; end of function
</pre>

<p>
VINDEXED 的分析分为两部分，singlevar 分析 t 为 local 变量，
同时在 primaryexp 中继续分析 'a' 为字符串值，存储在 k 表直接引用。
最终使用 <code>luaK_indexed</code> 确定 expdesc 的类型及相关数据。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 23: </span>lcode.c</label><pre class="src src-c"><span class="linenr">621: </span><span class="org-type">void</span> <span class="org-function-name">luaK_indexed</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">t</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">k</span>) {
<span class="linenr">622: </span>  t-&gt;u.s.aux = luaK_exp2RK(fs, k);
<span class="linenr">623: </span>  t-&gt;k = VINDEXED;
<span class="linenr">624: </span>}
</pre>
</div>

<p>
在最终赋值时，生成 gettable 指令。
</p>

<p>
之所以使用 RK(C) 作为索引，是因为索引值未必是常数，也可能是一个表，一个函数等其它值，
这里由 table 的特性决定的，这种通用的值只能由寄存器存储。
</p>
</div>
</div>
</div>

<div id="outline-container-org9bb0e19" class="outline-3">
<h3 id="org9bb0e19"><span class="section-number-3">4.5</span> function</h3>
<div class="outline-text-3" id="text-4-5">
<p>
这个小节关注 function 分析的过程。
</p>

<p>
语法描述中，涉及函数定义的地方，主要有 3 处，
</p>

<div class="org-src-container">
<pre class="src src-bnf">funcstat     <span class="org-constant">::=</span> FUNCTION funcname body
funcname     <span class="org-constant">::=</span> NAME {`.' NAME} [`:' NAME]
body         <span class="org-constant">::=</span> `(' parlist `)' chunk END
parlist      <span class="org-constant">::=</span> [ DOTS <span class="org-warning">|</span> NAME {`,' NAME} [`,' DOTS] ]

localstat    <span class="org-constant">::=</span> LOCAL FUNCTION NAME body

simpleexp    <span class="org-constant">::=</span> NUMBER <span class="org-warning">|</span> STRING <span class="org-warning">|</span> NIL <span class="org-warning">|</span> TRUE <span class="org-warning">|</span> FALSE <span class="org-warning">|</span> DOTS <span class="org-warning">|</span>
                 constructor <span class="org-warning">|</span> FUNCTION body <span class="org-warning">|</span> primaryexp
</pre>
</div>

<p>
第 1 种对应全局函数定义，第 2 种对应 local 函数定义，第 3 种对应函数函数定义。
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">function</span> <span class="org-function-name">f</span>()
<span class="org-keyword">end</span>

<span class="org-keyword">local</span> <span class="org-keyword">function</span> <span class="org-function-name">f</span>()
<span class="org-keyword">end</span>

<span class="org-keyword">local</span> <span class="org-function-name">f</span> = <span class="org-keyword">function</span> ()
<span class="org-keyword">end</span>
</pre>
</div>

<p>
但无论哪一种形式，函数分析的核心函数在于 body，通过 chunk 生成 Proto，
最终赋值予 global/local 变量。
</p>
</div>

<div id="outline-container-org017b902" class="outline-4">
<h4 id="org017b902"><span class="section-number-4">4.5.1</span> param</h4>
<div class="outline-text-4" id="text-4-5-1">
<p>
先来看参数部分。
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-keyword">function</span> <span class="org-function-name">f</span>(<span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>, ...)
<span class="org-keyword">end</span>
</pre>
</div>

<pre class="example" id="org15bc540">
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  "f"  ; 0

  ; function [0] definition (level 2)
  ; 0 upvalues, 2 params, 7 is_vararg, 3 stacks
  .function  0 2 7 3
  .local  "a"  ; 0
  .local  "b"  ; 1
  .local  "arg"  ; 2
  [1] return     0   1
  ; end of function

[1] closure    0   0        ; 0 upvalues
[2] return     0   1
; end of function
</pre>

<p>
参数部分由 parlist 处理，分为固定参数和可变参数。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 24: </span>lparser.c</label><pre class="src src-c"><span class="linenr">543: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">parlist</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>) {
<span class="linenr">544: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">parlist -&gt; [ param { `,' param } ]</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">545: </span>  <span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span> = ls-&gt;fs;
<span class="linenr">546: </span>  <span class="org-type">Proto</span> *<span class="org-variable-name">f</span> = fs-&gt;f;
<span class="linenr">547: </span>  <span class="org-type">int</span> <span class="org-variable-name">nparams</span> = 0;
<span class="linenr">548: </span>  f-&gt;is_vararg = 0;
<span class="linenr">549: </span>  <span class="org-keyword">if</span> (ls-&gt;t.token != <span class="org-string">')'</span>) {  <span class="org-comment-delimiter">/* </span><span class="org-comment">is `parlist' not empty?</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">550: </span>    <span class="org-keyword">do</span> {
<span class="linenr">551: </span>      <span class="org-keyword">switch</span> (ls-&gt;t.token) {
<span class="linenr">552: </span>        <span class="org-keyword">case</span> TK_NAME: {  <span class="org-comment-delimiter">/* </span><span class="org-comment">param -&gt; NAME</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">553: </span>          new_localvar(ls, str_checkname(ls), nparams++);
<span class="linenr">554: </span>          <span class="org-keyword">break</span>;
<span class="linenr">555: </span>        }
<span class="linenr">556: </span>        <span class="org-keyword">case</span> TK_DOTS: {  <span class="org-comment-delimiter">/* </span><span class="org-comment">param -&gt; `...'</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">557: </span>          luaX_next(ls);
<span class="linenr">558: </span><span class="org-preprocessor">#if</span> <span class="org-preprocessor">defined</span>(LUA_COMPAT_VARARG)
<span class="linenr">559: </span>          <span class="org-comment-delimiter">/* </span><span class="org-comment">use `arg' as default name</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">560: </span>          new_localvarliteral(ls, <span class="org-string">"arg"</span>, nparams++);
<span class="linenr">561: </span>          f-&gt;is_vararg = VARARG_HASARG | VARARG_NEEDSARG;
<span class="linenr">562: </span><span class="org-preprocessor">#endif</span>
<span class="linenr">563: </span>          f-&gt;is_vararg |= VARARG_ISVARARG;
<span class="linenr">564: </span>          <span class="org-keyword">break</span>;
<span class="linenr">565: </span>        }
<span class="linenr">566: </span>        <span class="org-keyword">default</span>: luaX_syntaxerror(ls, <span class="org-string">"&lt;name&gt; or "</span> LUA_QL(<span class="org-string">"..."</span>) <span class="org-string">" expected"</span>);
<span class="linenr">567: </span>      }
<span class="linenr">568: </span>    } <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>f-&gt;is_vararg &amp;&amp; testnext(ls, <span class="org-string">','</span>));
<span class="linenr">569: </span>  }
<span class="linenr">570: </span>  adjustlocalvars(ls, nparams);
<span class="linenr">571: </span>  f-&gt;numparams = cast_byte(fs-&gt;nactvar - (f-&gt;is_vararg &amp; VARARG_HASARG));
<span class="linenr">572: </span>  luaK_reserveregs(fs, fs-&gt;nactvar);  <span class="org-comment-delimiter">/* </span><span class="org-comment">reserve register for parameters</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">573: </span>}
</pre>
</div>

<p>
固定参数的处理方法，和 local 变量相同，不再赘述。
</p>

<p>
对于可变参数，即参数列表的最后定义中出现 <code>...</code> ，表明函数接收可变数量的参数，
全部收纳入 <code>...</code> 中。
</p>

<p>
在 lua5.0 中，可以在参数定义时使用 <code>...</code> ， 但是没有 <code>...</code> 表达式，
意味着在函数体中使用传入的参数时，通过变量 arg 来引用。
</p>

<p>
arg 是一个 table，以数组形式存储了所有可变参数，同时 arg.n 存储了数组的长度。
</p>

<p>
下面是 lua5.1 的同义描述，
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-keyword">function</span> <span class="org-function-name">f</span>(<span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>, ...)
  <span class="org-keyword">local</span> <span class="org-variable-name">arg</span> = {...}
  arg.n = <span class="org-builtin">select</span>(<span class="org-string">"#"</span>, ...)
<span class="org-keyword">end</span>
</pre>
</div>

<p>
lua5.1 默认提供了对变量 arg 的兼容性，所以才会出现注册 arg 变量的情况。
</p>

<p>
<code>fs-&gt;is_vararg</code> 是用来记录可变参数状态的变量，含义由 3 个二进制位综合表示。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 25: </span>lobject.h</label><pre class="src src-c"><span class="linenr">256: </span><span class="org-comment-delimiter">/* </span><span class="org-comment">masks for new-style vararg</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">257: </span><span class="org-preprocessor">#define</span> <span class="org-variable-name">VARARG_HASARG</span>           1
<span class="linenr">258: </span><span class="org-preprocessor">#define</span> <span class="org-variable-name">VARARG_ISVARARG</span>         2
<span class="linenr">259: </span><span class="org-preprocessor">#define</span> <span class="org-variable-name">VARARG_NEEDSARG</span>         4
</pre>
</div>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">macro</th>
<th scope="col" class="org-left">number</th>
<th scope="col" class="org-left">desc</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>VARARG_HASARG</code></td>
<td class="org-left">0b001</td>
<td class="org-left">方便计算参数数量，直接使用 &amp; 运算就可以</td>
</tr>

<tr>
<td class="org-left"><code>VARARG_ISVARARG</code></td>
<td class="org-left">0b010</td>
<td class="org-left">是否存在可变参数</td>
</tr>

<tr>
<td class="org-left"><code>VARARG_NEEDSARG</code></td>
<td class="org-left">0b100</td>
<td class="org-left">是否需要 arg，当函数内部出现 <code>...</code> 表达式时，置为 0</td>
</tr>
</tbody>
</table>

<p>
内部有如下几种模式
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">cond</th>
<th scope="col" class="org-left"><code>is_vararg</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">无可变参数</td>
<td class="org-left">0b000</td>
</tr>

<tr>
<td class="org-left">chunk</td>
<td class="org-left">0b010</td>
</tr>

<tr>
<td class="org-left">不需要 arg 变量</td>
<td class="org-left">0b011</td>
</tr>

<tr>
<td class="org-left">默认的兼容情况</td>
<td class="org-left">0b111</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org783c94b" class="outline-4">
<h4 id="org783c94b"><span class="section-number-4">4.5.2</span> upval</h4>
<div class="outline-text-4" id="text-4-5-2">
<p>
函数体就是 chunk 过程，作为分析的入口，在内部被递归调用，这里不再多做解释。
</p>

<p>
这里想重点说明的是，函数对 upvalue 的引用过程。
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="linenr"> 1: </span><span class="org-keyword">local</span> <span class="org-variable-name">a</span>
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span class="org-keyword">local</span> <span class="org-keyword">function</span> <span class="org-function-name">f</span>()
<span class="linenr"> 4: </span>   <span class="org-keyword">local</span> <span class="org-variable-name">b</span>
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>   <span class="org-keyword">local</span> <span class="org-keyword">function</span> <span class="org-function-name">g</span>()
<span class="linenr"> 7: </span>      b = 20
<span class="linenr"> 8: </span>      a = 10
<span class="linenr"> 9: </span>   <span class="org-keyword">end</span>
<span class="linenr">10: </span><span class="org-keyword">end</span>
</pre>
</div>

<pre class="example" id="org147c29c">
<span class="linenr"> 1: </span>; function [0] definition (level 1)
<span class="linenr"> 2: </span>; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
<span class="linenr"> 3: </span>.function  0 0 2 2
<span class="linenr"> 4: </span>.local  "a"  ; 0
<span class="linenr"> 5: </span>.local  "f"  ; 1
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>  ; function [0] definition (level 2)
<span class="linenr"> 8: </span>  ; 1 upvalues, 0 params, 0 is_vararg, 2 stacks
<span class="linenr"> 9: </span>  .function  1 0 0 2
<span class="linenr">10: </span>  .local  "b"  ; 0
<span class="linenr">11: </span>  .local  "g"  ; 1
<span class="linenr">12: </span>  .upvalue  "a"  ; 0
<span class="linenr">13: </span>
<span class="linenr">14: </span>    ; function [0] definition (level 3)
<span class="linenr">15: </span>    ; 2 upvalues, 0 params, 0 is_vararg, 2 stacks
<span class="linenr">16: </span>    .function  2 0 0 2
<span class="linenr">17: </span>    .upvalue  "b"  ; 0
<span class="linenr">18: </span>    .upvalue  "a"  ; 1
<span class="linenr">19: </span>    .const  20  ; 0
<span class="linenr">20: </span>    .const  10  ; 1
<span class="linenr">21: </span>    [1] loadk      0   0        ; 20
<span class="linenr">22: </span>    [2] setupval   0   0        ; b
<span class="linenr">23: </span>    [3] loadk      0   1        ; 10
<span class="linenr">24: </span>    [4] setupval   0   1        ; a
<span class="linenr">25: </span>    [5] return     0   1
<span class="linenr">26: </span>    ; end of function
<span class="linenr">27: </span>
<span class="linenr">28: </span>  [1] closure    1   0        ; 2 upvalues
<span class="linenr">29: </span>  [2] move       0   0
<span class="linenr">30: </span>  [3] getupval   0   0        ; a
<span class="linenr">31: </span>  [4] return     0   1
<span class="linenr">32: </span>  ; end of function
<span class="linenr">33: </span>
<span class="linenr">34: </span>[1] closure    1   0        ; 1 upvalues
<span class="linenr">35: </span>[2] move       0   0
<span class="linenr">36: </span>[3] return     0   1
<span class="linenr">37: </span>; end of function
</pre>

<p>
示例代码存在 3 层函数嵌套，chunk f g。
</p>

<p>
g 中引用的变量 a b 对于 g 而言都是 upvalue 类型。
</p>

<p>
当分析到 line 7 时，fs 的链接关系如下，
</p>


<div id="orgf12ef8b" class="figure">
<p><img src="generator-f-g-upval.png" alt="generator-f-g-upval.png">
</p>
</div>

<p>
首先分析变量 b，
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 26: </span>lparser.c</label><pre class="src src-c"><span class="linenr">183: </span><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">singlevaraux</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">TString</span> *<span class="org-variable-name">n</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">var</span>, <span class="org-type">int</span> <span class="org-variable-name">base</span>) {
<span class="linenr">184: </span>  <span class="org-keyword">if</span> (fs == <span class="org-constant">NULL</span>) {  <span class="org-comment-delimiter">/* </span><span class="org-comment">no more levels?</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">185: </span>    init_exp(var, VGLOBAL, NO_REG);  <span class="org-comment-delimiter">/* </span><span class="org-comment">default is global variable</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">186: </span>    <span class="org-keyword">return</span> VGLOBAL;
<span class="linenr">187: </span>  }
<span class="linenr">188: </span>  <span class="org-keyword">else</span> {
<span class="linenr">189: </span>    <span class="org-type">int</span> <span class="org-variable-name">v</span> = searchvar(fs, n);  <span class="org-comment-delimiter">/* </span><span class="org-comment">look up at current level</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">190: </span>    <span class="org-keyword">if</span> (v &gt;= 0) {
<span class="linenr">191: </span>      init_exp(var, VLOCAL, v);
<span class="linenr">192: </span>      <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>base)
<span class="linenr">193: </span>        markupval(fs, v);  <span class="org-comment-delimiter">/* </span><span class="org-comment">local will be used as an upval</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">194: </span>      <span class="org-keyword">return</span> VLOCAL;
<span class="linenr">195: </span>    }
<span class="linenr">196: </span>    <span class="org-keyword">else</span> {  <span class="org-comment-delimiter">/* </span><span class="org-comment">not found at current level; try upper one</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">197: </span>      <span class="org-keyword">if</span> (singlevaraux(fs-&gt;prev, n, var, 0) == VGLOBAL)
<span class="linenr">198: </span>        <span class="org-keyword">return</span> VGLOBAL;
<span class="linenr">199: </span>      var-&gt;u.s.info = indexupvalue(fs, n, var);  <span class="org-comment-delimiter">/* </span><span class="org-comment">else was LOCAL or UPVAL</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">200: </span>      var-&gt;k = VUPVAL;  <span class="org-comment-delimiter">/* </span><span class="org-comment">upvalue in this level</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">201: </span>      <span class="org-keyword">return</span> VUPVAL;
<span class="linenr">202: </span>    }
<span class="linenr">203: </span>  }
<span class="linenr">204: </span>}
</pre>
</div>

<p>
在 fs g() 中搜索无果，搜索上层 fs f()，在 fs f() 的 local 变量中找到 b，
调用 indexupvalue，然后标识为 VUPVAL 类型返回。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 27: </span>lparser.c</label><pre class="src src-c"><span class="linenr">183: </span><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">indexupvalue</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">TString</span> *<span class="org-variable-name">name</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">v</span>) {
<span class="linenr">184: </span>  <span class="org-type">int</span> <span class="org-variable-name">i</span>;
<span class="linenr">185: </span>  <span class="org-type">Proto</span> *<span class="org-variable-name">f</span> = fs-&gt;f;
<span class="linenr">186: </span>  <span class="org-type">int</span> <span class="org-variable-name">oldsize</span> = f-&gt;sizeupvalues;
<span class="linenr">187: </span>  <span class="org-keyword">for</span> (i=0; i&lt;f-&gt;nups; i++) {
<span class="linenr">188: </span>    <span class="org-keyword">if</span> (fs-&gt;upvalues[i].k == v-&gt;k &amp;&amp; fs-&gt;upvalues[i].info == v-&gt;u.s.info) {
<span class="linenr">189: </span>      lua_assert(f-&gt;upvalues[i] == name);
<span class="linenr">190: </span>      <span class="org-keyword">return</span> i;
<span class="linenr">191: </span>    }
<span class="linenr">192: </span>  }
<span class="linenr">193: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">new one</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">194: </span>  luaY_checklimit(fs, f-&gt;nups + 1, LUAI_MAXUPVALUES, <span class="org-string">"upvalues"</span>);
<span class="linenr">195: </span>  luaM_growvector(fs-&gt;L, f-&gt;upvalues, f-&gt;nups, f-&gt;sizeupvalues,
<span class="linenr">196: </span>                  <span class="org-type">TString</span> *, MAX_INT, <span class="org-string">""</span>);
<span class="linenr">197: </span>  <span class="org-keyword">while</span> (oldsize &lt; f-&gt;sizeupvalues) f-&gt;upvalues[oldsize++] = <span class="org-constant">NULL</span>;
<span class="linenr">198: </span>  f-&gt;upvalues[f-&gt;nups] = name;
<span class="linenr">199: </span>  luaC_objbarrier(fs-&gt;L, f, name);
<span class="linenr">200: </span>  lua_assert(v-&gt;k == VLOCAL || v-&gt;k == VUPVAL);
<span class="linenr">201: </span>  fs-&gt;upvalues[f-&gt;nups].k = cast_byte(v-&gt;k);
<span class="linenr">202: </span>  fs-&gt;upvalues[f-&gt;nups].info = cast_byte(v-&gt;u.s.info);
<span class="linenr">203: </span>  <span class="org-keyword">return</span> f-&gt;nups++;
<span class="linenr">204: </span>}
</pre>
</div>

<p>
在 indexupvalue 中，先搜索是否已经存在 upvalue b，若没有则存储到 upvalues 数组中。
</p>

<p>
f-&gt;upvalues 记录变量名，fs-&gt;upvalues 记录 upval 信息。
</p>


<div id="orgab2ab3e" class="figure">
<p><img src="generator-f-g-upvalues-0.png" alt="generator-f-g-upvalues-0.png">
</p>
</div>


<div id="org8a325f5" class="figure">
<p><img src="generator-f-g-upvalues-1.png" alt="generator-f-g-upvalues-1.png">
</p>
</div>

<p>
upvalue 其实可分为两种情况，一种是 VLOCAL，一种是 VUPVAL。
</p>

<p>
b 属于 VLOCAL 的情况，因为 b 和 g() 在一个层级，g() 内部只需要向上查找一个层级便可定位 b。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 28: </span>lparser.h</label><pre class="src src-c"><span class="linenr">48: </span><span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">upvaldesc</span> {
<span class="linenr">49: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">k</span>;
<span class="linenr">50: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">info</span>;
<span class="linenr">51: </span>} <span class="org-type">upvaldesc</span>;
</pre>
</div>

<p>
fs-&gt;upvalues 在记录 VLOCAL 的同时，也记录其对应的寄存器位置。
</p>


<p>
再来搜索变量 a，不存在于 g()，也不存在于 f() 中，在 chunk() 中找到。
</p>

<p>
此时 upvalues 数组的情况如下。
</p>


<div id="org478fdf0" class="figure">
<p><img src="generator-f-g-upvalues-2.png" alt="generator-f-g-upvalues-2.png">
</p>
</div>



<div id="orgea37355" class="figure">
<p><img src="generator-f-g-upvalues-3.png" alt="generator-f-g-upvalues-3.png">
</p>
</div>

<p>
a 对于 g() 属于 VUPVAL 的情况，对于 f() 属于 VLOCAL 的情况。
</p>

<p>
值得注意，在搜索变量 a 的时候，indexupvalue 调用了两次，一次从 fs g() 出发，一次从 fs f() 出发。
这也解释了，为什么 f() 没有直接使用 a，但是其 upvalues 表中依然记录了 a。
</p>

<p>
当函数 g() 解析结束之后，将 Proto 结果链接到上层。
</p>


<div id="org8716c43" class="figure">
<p><img src="generator-f-g-upvalues-4.png" alt="generator-f-g-upvalues-4.png">
</p>
</div>

<p>
得到 Proto 之后，生成 closure 指令将其赋值予变量 g。
</p>

<p>
同时在 closure 指令之后，生成了额外的两条指令，按顺序表明当前 closure 的 upvalue 的类型和索引信息。
</p>

<pre class="example" id="orgefb60c2">
[2] move       0   0
[3] getupval   0   0        ; a
</pre>

<p>
move 指令此时不表示普通的 move 含义，参数 A 无用，参数 B 指代 VLOCAL 的栈索引。
表示新建的 closure 第 1 个 upvalue 是 VLOCAL 类型，
指向当前作用域索引为 0 的寄存器。
</p>

<p>
getupval 指令同样，参数 A 无用，参数 B 表示上层 closure 中 upvalues 表中的序号。
表示第 2 个 upvalue 是 VUPVAL 类型，指向上个作用域索引为 0 的 upvalue。
</p>

<p>
使用这种方式，将 upvalue 的类型和索引存储到 code 中，
所以 f-&gt;upvalues 只需要单纯记录变量名称就足够了。
</p>

<p>
vm 在执行的时候，自然会理会其中的含义并做出相应处理。
</p>
</div>
</div>
</div>

<div id="outline-container-org04a8aaa" class="outline-3">
<h3 id="org04a8aaa"><span class="section-number-3">4.6</span> do</h3>
<div class="outline-text-3" id="text-4-6">
<p>
相信很多人都对 ebnf 描述中的 block 和 chunk 有疑问。
</p>

<div class="org-src-container">
<pre class="src src-bnf">stat         <span class="org-constant">::=</span> dostat
dostat       <span class="org-constant">::=</span> DO block END

block        <span class="org-constant">::=</span> chunk
</pre>
</div>

<p>
chunk 已经是分析的入口，为什么 block 又生成 chunk，这样看来 block
不是应该在 chunk 上层吗？
</p>

<p>
其实这个问题可以这样看，chunk 可以看作是分析语句列表的方法，
block 调用 chunk，是为了分析 block 中的语句列表，并不是要生成新的 FuncState。
</p>

<p>
实际上，block 有其自己的一套逻辑。
</p>

<p>
do 语句是最纯粹调用 block 的语句。
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">a</span>

<span class="org-keyword">do</span>
   <span class="org-keyword">local</span> <span class="org-variable-name">b</span>
   <span class="org-keyword">local</span> <span class="org-variable-name">c</span>
   <span class="org-keyword">do</span>
      <span class="org-keyword">local</span> <span class="org-variable-name">d</span>

      a = 10
   <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>

<pre class="example" id="org62f69f8">
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 4 stacks
.function  0 0 2 4
.local  "a"  ; 0
.local  "b"  ; 1
.local  "c"  ; 2
.local  "d"  ; 3
.const  10  ; 0
[1] loadk      0   0        ; 10
[2] return     0   1
; end of function
</pre>

<p>
从结果中，好像什么都看不到，和正常声明变量，进行赋值，是一样的效果。
</p>

<p>
实际上，do 语句的作用主要在于描述块作用域。
</p>

<p>
在 block() 方法中，
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 29: </span>lparser.c</label><pre class="src src-c"><span class="linenr">881: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">block</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>) {
<span class="linenr">882: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">block -&gt; chunk</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">883: </span>  <span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span> = ls-&gt;fs;
<span class="linenr">884: </span>  <span class="org-type">BlockCnt</span> <span class="org-variable-name">bl</span>;
<span class="linenr">885: </span>  enterblock(fs, &amp;bl, 0);
<span class="linenr">886: </span>  chunk(ls);
<span class="linenr">887: </span>  lua_assert(bl.breaklist == NO_JUMP);
<span class="linenr">888: </span>  leaveblock(fs);
<span class="linenr">889: </span>}
</pre>
</div>

<p>
先后调用 enterblock 和 leaveblock 方法，操作 fs-&gt;bl。
</p>

<p>
这里也说明了，虽然同样调用 chunk，但是在函数定义时，其使用 <code>open_func</code> <code>close_func</code> 来操作
fs-&gt;prev 形成链状结构，所以 block() 的行为主要是由 enterblock leaveblock 决定的。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 30: </span>lparser.c</label><pre class="src src-c"><span class="linenr">37: </span><span class="org-comment-delimiter">/*</span>
<span class="linenr">38: </span><span class="org-comment">** nodes for block list (list of active blocks)</span>
<span class="linenr">39: </span><span class="org-comment-delimiter">*/</span>
<span class="linenr">40: </span><span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">BlockCnt</span> {
<span class="linenr">41: </span>  <span class="org-keyword">struct</span> <span class="org-type">BlockCnt</span> *<span class="org-variable-name">previous</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">chain</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">42: </span>  <span class="org-type">int</span> <span class="org-variable-name">breaklist</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">list of jumps out of this loop</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">43: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">nactvar</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment"># active locals outside the breakable structure</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">44: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">upval</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">true if some variable in the block is an upvalue</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">45: </span>  <span class="org-type">lu_byte</span> <span class="org-variable-name">isbreakable</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">true if `block' is a loop</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">46: </span>} <span class="org-type">BlockCnt</span>;
</pre>
</div>

<p>
BlockCnt 的结构并不复杂，
</p>
<ul class="org-ul">
<li><code>struct BlockCnt *previous</code> ，指向父 block</li>
<li><code>int breaklist</code> ，在 while 章节讲解</li>
<li><code>lu_byte nactvar</code> ，进入 block 前保存 nactvar</li>
<li><code>lu_byte upval</code> ，当前块作用域中是否有 local 变量用作 upvalue，在 repeat 章节讲解</li>
<li><code>lu_byte isbreakable</code> ，是否是一个循环语句块，在 while 章节讲解。</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 31: </span>lparser.c</label><pre class="src src-c"><span class="linenr">285: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">enterblock</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">BlockCnt</span> *<span class="org-variable-name">bl</span>, <span class="org-type">lu_byte</span> <span class="org-variable-name">isbreakable</span>) {
<span class="linenr">286: </span>  bl-&gt;breaklist = NO_JUMP;
<span class="linenr">287: </span>  bl-&gt;isbreakable = isbreakable;
<span class="linenr">288: </span>  bl-&gt;nactvar = fs-&gt;nactvar;
<span class="linenr">289: </span>  bl-&gt;upval = 0;
<span class="linenr">290: </span>  bl-&gt;previous = fs-&gt;bl;
<span class="linenr">291: </span>  fs-&gt;bl = bl;
<span class="linenr">292: </span>  lua_assert(fs-&gt;freereg == fs-&gt;nactvar);
<span class="linenr">293: </span>}
<span class="linenr">294: </span>
<span class="linenr">295: </span>
<span class="linenr">296: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">leaveblock</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>) {
<span class="linenr">297: </span>  <span class="org-type">BlockCnt</span> *<span class="org-variable-name">bl</span> = fs-&gt;bl;
<span class="linenr">298: </span>  fs-&gt;bl = bl-&gt;previous;
<span class="linenr">299: </span>  removevars(fs-&gt;ls, bl-&gt;nactvar);
<span class="linenr">300: </span>  <span class="org-keyword">if</span> (bl-&gt;upval)
<span class="linenr">301: </span>    luaK_codeABC(fs, OP_CLOSE, bl-&gt;nactvar, 0, 0);
<span class="linenr">302: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">a block either controls scope or breaks (never both)</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">303: </span>  lua_assert(<span class="org-negation-char">!</span>bl-&gt;isbreakable || <span class="org-negation-char">!</span>bl-&gt;upval);
<span class="linenr">304: </span>  lua_assert(bl-&gt;nactvar == fs-&gt;nactvar);
<span class="linenr">305: </span>  fs-&gt;freereg = fs-&gt;nactvar;  <span class="org-comment-delimiter">/* </span><span class="org-comment">free registers</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">306: </span>  luaK_patchtohere(fs, bl-&gt;breaklist);
<span class="linenr">307: </span>}
</pre>
</div>

<p>
enterblock 新建 BlockCnt，指向父 block，并记录当前 nactvar。
leaveblock 则相反，删除顶层 block，将 fs-&gt;freereg 重置回原来的 nactvar。
</p>

<p>
明显地起到了作用域分隔的作用。
</p>


<div id="org40f8737" class="figure">
<p><img src="generator-do-block.png" alt="generator-do-block.png">
</p>
</div>

<p>
在第 1 次进入 do block 时，外部只定义了 local a，只有一个局部变量，
此时保存 nactvar 为 1。
</p>

<p>
第 2 次进入 do block 时，增加了定义 local b c，新的 BlockCnt 链接到父 block，
保存 nactvar 为 3。
</p>

<p>
在内部，修改 a = 10，这个 a 正是最外层的 local a 而不是 upvalue，因为 upvalue
只作用于不同函数之间，目前 local a b c d 是属于一个函数作用域的。
</p>

<p>
离开内层 do block 时，恢复 freereg 到 nactvar=3 且重置了 fs-&gt;nactvar，相当于回收了变量 d。
</p>

<p>
至于 block 在循环中的作用，到循环语句章节再讲解。
</p>
</div>
</div>

<div id="outline-container-orgc242cee" class="outline-3">
<h3 id="orgc242cee"><span class="section-number-3">4.7</span> if</h3>
<div class="outline-text-3" id="text-4-7">
<p>
本节来分析，在代码生成过程中是如何处理 if 语句的。
</p>

<div class="org-src-container">
<pre class="src src-bnf">stat         <span class="org-constant">::=</span> ifstat

ifstat       <span class="org-constant">::=</span> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END
cond         <span class="org-constant">::=</span> expr
block        <span class="org-constant">::=</span> chunk
</pre>
</div>

<p>
前面已经提到过，整体的分析过程是从左至右，从前至后的，
而 if 是分支结构，不同于分析过程的线性结构。
</p>

<p>
lua 内部使用一种精巧的方式解决这个问题。
</p>
</div>

<div id="outline-container-orgd2bce0e" class="outline-4">
<h4 id="orgd2bce0e"><span class="section-number-4">4.7.1</span> if</h4>
<div class="outline-text-4" id="text-4-7-1">
<p>
首先来看示例代码，
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>

<span class="org-keyword">if</span> b <span class="org-keyword">then</span>
   a = 1
<span class="org-keyword">end</span>
</pre>
</div>

<pre class="example" id="org4d3d860">
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  "a"  ; 0
.local  "b"  ; 1
.const  1  ; 0
[1] test       1       0    ; to [3] if true
[2] jmp        1            ; to [4]
[3] loadk      0   0        ; 1
[4] return     0   1
; end of function
</pre>

<p>
整体流程的示意如下，TRUE 表示条件为真所执行的字节码，这里为 loadk。
</p>


<div id="orgce32087" class="figure">
<p><img src="generator-if.png" alt="generator-if.png">
</p>
</div>

<p>
在分支结构中扮演重要角色的是两种指令，test 和 jmp。
</p>

<p>
在 vm 的执行过程中，pc 问题默认自增的，即执行完当前指令后，pc++，
对于 test 和 jmp 也不例外。
</p>

<p>
jmp 指令有一个参数，即跳转的距离，可正可负，意味着可以向前跳转，也可以向后。
</p>

<p>
根据 pc++ 的原则，
</p>
<ul class="org-ul">
<li>指令 <code>jmp -1</code> 表示循环执行当前的 jmp 指令，因为 jmp 跳转到自身</li>
<li>指令 <code>jmp 0</code>  表示跳转到下一条指令，即正常执行</li>
<li>指令 <code>jmp 1</code>  表示略过下一条指令，跳转到下下一条指令</li>
</ul>

<p>
jmp 是无条件跳转，而 test 指令不同，需要针对 True 和 False 跳转到不同的地方。
lua 使用了一种简洁的模式来安排。
</p>

<p>
（假设参数 <code>C = 0</code> ）test 指令之后固定接着一条 jmp 指令，用于执行 False 跳转。
jmp 指令之后紧接着 True 语句块。
</p>

<p>
在这种安排下，
</p>
<ul class="org-ul">
<li>如果为 False，正常执行下一条指令，下一条 jmp 跳转到 False 语句块</li>
<li>如果为 True，vm 执行 pc++ ++，跳过 test 后的 jmp 指令，执行 True 语句块</li>
</ul>

<p>
这样就不用使得 test 指令过于复杂。
</p>


<p>
对照示例代码，内部使用 ifstat() 来分析 if 语句。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 32: </span>lparser.c</label><pre class="src src-c"><span class="linenr">1130: </span><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">test_then_block</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>) {
<span class="linenr">1131: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">test_then_block -&gt; [IF | ELSEIF] cond THEN block</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1132: </span>  <span class="org-type">int</span> <span class="org-variable-name">condexit</span>;
<span class="linenr">1133: </span>  luaX_next(ls);  <span class="org-comment-delimiter">/* </span><span class="org-comment">skip IF or ELSEIF</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1134: </span>  condexit = cond(ls);
<span class="linenr">1135: </span>  checknext(ls, TK_THEN);
<span class="linenr">1136: </span>  block(ls);  <span class="org-comment-delimiter">/* </span><span class="org-comment">`then' part</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1137: </span>  <span class="org-keyword">return</span> condexit;
<span class="linenr">1138: </span>}
<span class="linenr">1139: </span>
<span class="linenr">1140: </span>
<span class="linenr">1141: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">ifstat</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>, <span class="org-type">int</span> <span class="org-variable-name">line</span>) {
<span class="linenr">1142: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">ifstat -&gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1143: </span>  <span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span> = ls-&gt;fs;
<span class="linenr">1144: </span>  <span class="org-type">int</span> <span class="org-variable-name">flist</span>;
<span class="linenr">1145: </span>  <span class="org-type">int</span> <span class="org-variable-name">escapelist</span> = NO_JUMP;
<span class="linenr">1146: </span>  flist = test_then_block(ls);  <span class="org-comment-delimiter">/* </span><span class="org-comment">IF cond THEN block</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1147: </span>  <span class="org-keyword">while</span> (ls-&gt;t.token == TK_ELSEIF) {
<span class="linenr">1148: </span>    luaK_concat(fs, &amp;escapelist, luaK_jump(fs));
<span class="linenr">1149: </span>    luaK_patchtohere(fs, flist);
<span class="linenr">1150: </span>    flist = test_then_block(ls);  <span class="org-comment-delimiter">/* </span><span class="org-comment">ELSEIF cond THEN block</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1151: </span>  }
<span class="linenr">1152: </span>  <span class="org-keyword">if</span> (ls-&gt;t.token == TK_ELSE) {
<span class="linenr">1153: </span>    luaK_concat(fs, &amp;escapelist, luaK_jump(fs));
<span class="linenr">1154: </span>    luaK_patchtohere(fs, flist);
<span class="linenr">1155: </span>    luaX_next(ls);  <span class="org-comment-delimiter">/* </span><span class="org-comment">skip ELSE (after patch, for correct line info)</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1156: </span>    block(ls);  <span class="org-comment-delimiter">/* </span><span class="org-comment">`else' part</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1157: </span>  }
<span class="linenr">1158: </span>  <span class="org-keyword">else</span>
<span class="linenr">1159: </span>    luaK_concat(fs, &amp;escapelist, flist);
<span class="linenr">1160: </span>  luaK_patchtohere(fs, escapelist);
<span class="linenr">1161: </span>  check_match(ls, TK_END, TK_IF, line);
<span class="linenr">1162: </span>}
</pre>
</div>

<p>
使用 <code>test_then_block()</code> 分析 <code>IF cond THEN block</code> 的部分，
使用 cond() 分析条件部分，
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 33: </span>lparser.c</label><pre class="src src-c"><span class="linenr">965: </span><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">cond</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>) {
<span class="linenr">966: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">cond -&gt; exp</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">967: </span>  <span class="org-type">expdesc</span> <span class="org-variable-name">v</span>;
<span class="linenr">968: </span>  expr(ls, &amp;v);  <span class="org-comment-delimiter">/* </span><span class="org-comment">read condition</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">969: </span>  <span class="org-keyword">if</span> (v.k == VNIL) v.k = VFALSE;  <span class="org-comment-delimiter">/* </span><span class="org-comment">`falses' are all equal here</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">970: </span>  luaK_goiftrue(ls-&gt;fs, &amp;v);
<span class="linenr">971: </span>  <span class="org-keyword">return</span> v.f;
<span class="linenr">972: </span>}
</pre>
</div>

<p>
进入 <code>luaK_goiftrue()</code> ，调用 <code>jumponcond</code> 和 <code>condjump</code> ，生成了 test 指令和 jmp 指令，
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 34: </span>lcode.c</label><pre class="src src-c"><span class="linenr">524: </span><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">jumponcond</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">e</span>, <span class="org-type">int</span> <span class="org-variable-name">cond</span>) {
<span class="linenr">525: </span>  <span class="org-keyword">if</span> (e-&gt;k == VRELOCABLE) {
<span class="linenr">526: </span>    <span class="org-type">Instruction</span> <span class="org-variable-name">ie</span> = getcode(fs, e);
<span class="linenr">527: </span>    <span class="org-keyword">if</span> (GET_OPCODE(ie) == OP_NOT) {
<span class="linenr">528: </span>      fs-&gt;pc--;  <span class="org-comment-delimiter">/* </span><span class="org-comment">remove previous OP_NOT</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">529: </span>      <span class="org-keyword">return</span> condjump(fs, OP_TEST, GETARG_B(ie), 0, <span class="org-negation-char">!</span>cond);
<span class="linenr">530: </span>    }
<span class="linenr">531: </span>    <span class="org-comment-delimiter">/* </span><span class="org-comment">else go through</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">532: </span>  }
<span class="linenr">533: </span>  discharge2anyreg(fs, e);
<span class="linenr">534: </span>  freeexp(fs, e);
<span class="linenr">535: </span>  <span class="org-keyword">return</span> condjump(fs, OP_TESTSET, NO_REG, e-&gt;u.s.info, cond);
<span class="linenr">536: </span>}
<span class="linenr">537: </span>
<span class="linenr">538: </span>
<span class="linenr">539: </span><span class="org-type">void</span> <span class="org-function-name">luaK_goiftrue</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">expdesc</span> *<span class="org-variable-name">e</span>) {
<span class="linenr">540: </span>  <span class="org-type">int</span> <span class="org-variable-name">pc</span>;  <span class="org-comment-delimiter">/* </span><span class="org-comment">pc of last jump</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">541: </span>  luaK_dischargevars(fs, e);
<span class="linenr">542: </span>  <span class="org-keyword">switch</span> (e-&gt;k) {
<span class="linenr">543: </span>    <span class="org-keyword">case</span> VK: <span class="org-keyword">case</span> VKNUM: <span class="org-keyword">case</span> VTRUE: {
<span class="linenr">544: </span>      pc = NO_JUMP;  <span class="org-comment-delimiter">/* </span><span class="org-comment">always true; do nothing</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">545: </span>      <span class="org-keyword">break</span>;
<span class="linenr">546: </span>    }
<span class="linenr">547: </span>    <span class="org-keyword">case</span> VJMP: {
<span class="linenr">548: </span>      invertjump(fs, e);
<span class="linenr">549: </span>      pc = e-&gt;u.s.info;
<span class="linenr">550: </span>      <span class="org-keyword">break</span>;
<span class="linenr">551: </span>    }
<span class="linenr">552: </span>    <span class="org-keyword">default</span>: {
<span class="linenr">553: </span>      pc = jumponcond(fs, e, 0);
<span class="linenr">554: </span>      <span class="org-keyword">break</span>;
<span class="linenr">555: </span>    }
<span class="linenr">556: </span>  }
<span class="linenr">557: </span>  luaK_concat(fs, &amp;e-&gt;f, pc);  <span class="org-comment-delimiter">/* </span><span class="org-comment">insert last jump in `f' list</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">558: </span>  luaK_patchtohere(fs, e-&gt;t);
<span class="linenr">559: </span>  e-&gt;t = NO_JUMP;
<span class="linenr">560: </span>}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 35: </span>lcode.c</label><pre class="src src-c"><span class="linenr">74: </span><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">condjump</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">OpCode</span> <span class="org-variable-name">op</span>, <span class="org-type">int</span> <span class="org-variable-name">A</span>, <span class="org-type">int</span> <span class="org-variable-name">B</span>, <span class="org-type">int</span> <span class="org-variable-name">C</span>) {
<span class="linenr">75: </span>  luaK_codeABC(fs, op, A, B, C);
<span class="linenr">76: </span>  <span class="org-keyword">return</span> luaK_jump(fs);
<span class="linenr">77: </span>}
</pre>
</div>

<p>
最终 <code>cond()</code> 返回 jmp 指令的索引，在 ifstat() 中由 flist 保存。
</p>


<p>
下面就是关键的地方，lua 如何确定跳转的位置，其中有几个关键的过程，concat，patch 和 dischargejpc。
</p>

<p>
在 <code>test_then_block()</code> 之后，解析了 cond 和 true block，并保留了 jmp 指令的索引。
</p>


<div id="org05fdc3c" class="figure">
<p><img src="generator-if-test-then-block.png" alt="generator-if-test-then-block.png">
</p>
</div>

<p>
因为其后没有 else/elseif 语句，直接执行 line 1159，
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 36: </span>lcode.c</label><pre class="src src-c"><span class="linenr">185: </span><span class="org-type">void</span> <span class="org-function-name">luaK_concat</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">int</span> *<span class="org-variable-name">l1</span>, <span class="org-type">int</span> <span class="org-variable-name">l2</span>) {
<span class="linenr">186: </span>  <span class="org-keyword">if</span> (l2 == NO_JUMP) <span class="org-keyword">return</span>;
<span class="linenr">187: </span>  <span class="org-keyword">else</span> <span class="org-keyword">if</span> (*l1 == NO_JUMP)
<span class="linenr">188: </span>    *l1 = l2;
<span class="linenr">189: </span>  <span class="org-keyword">else</span> {
<span class="linenr">190: </span>    <span class="org-type">int</span> <span class="org-variable-name">list</span> = *l1;
<span class="linenr">191: </span>    <span class="org-type">int</span> <span class="org-variable-name">next</span>;
<span class="linenr">192: </span>    <span class="org-keyword">while</span> ((next = getjump(fs, list)) != NO_JUMP)  <span class="org-comment-delimiter">/* </span><span class="org-comment">find last element</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">193: </span>      list = next;
<span class="linenr">194: </span>    fixjump(fs, list, l2);
<span class="linenr">195: </span>  }
<span class="linenr">196: </span>}
</pre>
</div>

<p>
将 flist 链接到 escapelist 上，
</p>


<div id="org3e488e0" class="figure">
<p><img src="generator-if-test-then-block-1.png" alt="generator-if-test-then-block-1.png">
</p>
</div>

<p>
其后执行 line 1160，执行 patch 过程，
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 37: </span>lcode.c</label><pre class="src src-c"><span class="linenr">179: </span><span class="org-type">void</span> <span class="org-function-name">luaK_patchtohere</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">int</span> <span class="org-variable-name">list</span>) {
<span class="linenr">180: </span>  luaK_getlabel(fs);
<span class="linenr">181: </span>  luaK_concat(fs, &amp;fs-&gt;jpc, list);
<span class="linenr">182: </span>}
</pre>
</div>

<p>
将 escapelist 链接到 fs-&gt;jpc 上，
</p>


<div id="org6a70c44" class="figure">
<p><img src="generator-if-test-then-block-2.png" alt="generator-if-test-then-block-2.png">
</p>
</div>

<p>
最终在生成 TRUE 之后的语句时，执行 dischargejpc 过程，
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 38: </span>lcode.c</label><pre class="src src-c"><span class="linenr">789: </span><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">luaK_code</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">Instruction</span> <span class="org-variable-name">i</span>, <span class="org-type">int</span> <span class="org-variable-name">line</span>) {
<span class="linenr">790: </span>  <span class="org-type">Proto</span> *<span class="org-variable-name">f</span> = fs-&gt;f;
<span class="linenr">791: </span>  dischargejpc(fs);  <span class="org-comment-delimiter">/* </span><span class="org-comment">`pc' will change</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">792: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">put new instruction in code array</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">793: </span>  luaM_growvector(fs-&gt;L, f-&gt;code, fs-&gt;pc, f-&gt;sizecode, Instruction,
<span class="linenr">794: </span>                  MAX_INT, <span class="org-string">"code size overflow"</span>);
<span class="linenr">795: </span>  f-&gt;code[fs-&gt;pc] = i;
<span class="linenr">796: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">save corresponding line information</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">797: </span>  luaM_growvector(fs-&gt;L, f-&gt;lineinfo, fs-&gt;pc, f-&gt;sizelineinfo, <span class="org-type">int</span>,
<span class="linenr">798: </span>                  MAX_INT, <span class="org-string">"code size overflow"</span>);
<span class="linenr">799: </span>  f-&gt;lineinfo[fs-&gt;pc] = line;
<span class="linenr">800: </span>  <span class="org-keyword">return</span> fs-&gt;pc++;
<span class="linenr">801: </span>}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 39: </span>lcode.c</label><pre class="src src-c"><span class="linenr">150: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">patchlistaux</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>, <span class="org-type">int</span> <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">vtarget</span>, <span class="org-type">int</span> <span class="org-variable-name">reg</span>,
<span class="linenr">151: </span>                          <span class="org-type">int</span> <span class="org-variable-name">dtarget</span>) {
<span class="linenr">152: </span>  <span class="org-keyword">while</span> (list != NO_JUMP) {
<span class="linenr">153: </span>    <span class="org-type">int</span> <span class="org-variable-name">next</span> = getjump(fs, list);
<span class="linenr">154: </span>    <span class="org-keyword">if</span> (patchtestreg(fs, list, reg))
<span class="linenr">155: </span>      fixjump(fs, list, vtarget);
<span class="linenr">156: </span>    <span class="org-keyword">else</span>
<span class="linenr">157: </span>      fixjump(fs, list, dtarget);  <span class="org-comment-delimiter">/* </span><span class="org-comment">jump to default target</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">158: </span>    list = next;
<span class="linenr">159: </span>  }
<span class="linenr">160: </span>}
<span class="linenr">161: </span>
<span class="linenr">162: </span>
<span class="linenr">163: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">dischargejpc</span> (<span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span>) {
<span class="linenr">164: </span>  patchlistaux(fs, fs-&gt;jpc, fs-&gt;pc, NO_REG, fs-&gt;pc);
<span class="linenr">165: </span>  fs-&gt;jpc = NO_JUMP;
<span class="linenr">166: </span>}
</pre>
</div>


<div id="orgb1a8e23" class="figure">
<p><img src="generator-if-3.png" alt="generator-if-3.png">
</p>
</div>

<p>
此时已经在 TRUE 语句块之外，也明确当前的指令索引和 jmp 指令索引，
直接计算距离的差值，修改 jmp 指令的参数，跳转到此位置。
</p>

<p>
综合来看，concat 将需要重新定位的 jmp 指令链接起来，最终链接到 jpc 上，
由 dischargejpc 过程，调整所有链接的 jmp 指令，使其跳转到当前位置。
</p>

<p>
单纯的 if 语句比较简单，读者或许还体会不到这种方法的作用，下面来看更复杂的语句。
</p>
</div>
</div>

<div id="outline-container-org6dc2c8e" class="outline-4">
<h4 id="org6dc2c8e"><span class="section-number-4">4.7.2</span> if else</h4>
<div class="outline-text-4" id="text-4-7-2">
<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>

<span class="org-keyword">if</span> b <span class="org-keyword">then</span>
   a = 1
<span class="org-keyword">else</span>
   a = 0
<span class="org-keyword">end</span>
</pre>
</div>

<pre class="example" id="org73c0651">
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  "a"  ; 0
.local  "b"  ; 1
.const  1  ; 0
.const  0  ; 1
[1] test       1       0    ; to [3] if true
[2] jmp        2            ; to [5]
[3] loadk      0   0        ; 1
[4] jmp        1            ; to [6]
[5] loadk      0   1        ; 0
[6] return     0   1
; end of function
</pre>


<div id="orge814206" class="figure">
<p><img src="generator-if-else-0.png" alt="generator-if-else-0.png">
</p>
</div>


<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 40: </span>lparser.c</label><pre class="src src-c"><span class="linenr">1141: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">ifstat</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>, <span class="org-type">int</span> <span class="org-variable-name">line</span>) {
<span class="linenr">1142: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">ifstat -&gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1143: </span>  <span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span> = ls-&gt;fs;
<span class="linenr">1144: </span>  <span class="org-type">int</span> <span class="org-variable-name">flist</span>;
<span class="linenr">1145: </span>  <span class="org-type">int</span> <span class="org-variable-name">escapelist</span> = NO_JUMP;
<span class="linenr">1146: </span>  flist = test_then_block(ls);  <span class="org-comment-delimiter">/* </span><span class="org-comment">IF cond THEN block</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1147: </span>  <span class="org-keyword">while</span> (ls-&gt;t.token == TK_ELSEIF) {
<span class="linenr">1148: </span>    luaK_concat(fs, &amp;escapelist, luaK_jump(fs));
<span class="linenr">1149: </span>    luaK_patchtohere(fs, flist);
<span class="linenr">1150: </span>    flist = test_then_block(ls);  <span class="org-comment-delimiter">/* </span><span class="org-comment">ELSEIF cond THEN block</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1151: </span>  }
<span class="linenr">1152: </span>  <span class="org-keyword">if</span> (ls-&gt;t.token == TK_ELSE) {
<span class="linenr">1153: </span>    luaK_concat(fs, &amp;escapelist, luaK_jump(fs));
<span class="linenr">1154: </span>    luaK_patchtohere(fs, flist);
<span class="linenr">1155: </span>    luaX_next(ls);  <span class="org-comment-delimiter">/* </span><span class="org-comment">skip ELSE (after patch, for correct line info)</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1156: </span>    block(ls);  <span class="org-comment-delimiter">/* </span><span class="org-comment">`else' part</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1157: </span>  }
<span class="linenr">1158: </span>  <span class="org-keyword">else</span>
<span class="linenr">1159: </span>    luaK_concat(fs, &amp;escapelist, flist);
<span class="linenr">1160: </span>  luaK_patchtohere(fs, escapelist);
<span class="linenr">1161: </span>  check_match(ls, TK_END, TK_IF, line);
<span class="linenr">1162: </span>}
</pre>
</div>

<p>
在 if else 语句中，解析 cond 和 true block 之后，要继续解析 else false block 部分。
</p>

<p>
false block 生成字节码也遵循一定的模式，先生成 jmp 指令，用于跳出 true block，
其次再生成 false block。
</p>

<p>
其中将这个 jmp 链接到 escapelist 上，因为分析到 false block 的起始位置，
所以重定向 test 部分的 jmp 到这个位置。
</p>


<div id="org74303d3" class="figure">
<p><img src="generator-if-else-1.png" alt="generator-if-else-1.png">
</p>
</div>


<p>
最终将 escapelist 链接到 jpc 上，进行 dischargejpc 操作。
</p>


<div id="org09406c6" class="figure">
<p><img src="generator-if-else-2.png" alt="generator-if-else-2.png">
</p>
</div>

<p>
由这种模式可以看出，flist 表示 false list，escapelist 表示跳出 true list。
</p>

<p>
discharge 的过程就是先将目标链接到 fs-&gt;jpc 上，然后从 fs-&gt;jpc 开始，重新定位所有 jmp 的目标位置。
</p>
</div>
</div>

<div id="outline-container-org722ad33" class="outline-4">
<h4 id="org722ad33"><span class="section-number-4">4.7.3</span> if elseif</h4>
<div class="outline-text-4" id="text-4-7-3">
<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>, <span class="org-variable-name">c</span>

<span class="org-keyword">if</span> b <span class="org-keyword">then</span>
   a = 1
<span class="org-keyword">elseif</span> c <span class="org-keyword">then</span>
   a = 2
<span class="org-keyword">end</span>
</pre>
</div>

<pre class="example" id="org883eba6">
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 3 stacks
.function  0 0 2 3
.local  "a"  ; 0
.local  "b"  ; 1
.local  "c"  ; 2
.const  1  ; 0
.const  2  ; 1
[1] test       1       0    ; to [3] if true
[2] jmp        2            ; to [5]
[3] loadk      0   0        ; 1
[4] jmp        3            ; to [8]
[5] test       2       0    ; to [7] if true
[6] jmp        1            ; to [8]
[7] loadk      0   1        ; 2
[8] return     0   1
; end of function
</pre>


<div id="orga977db4" class="figure">
<p><img src="generator-if-else-if-0.png" alt="generator-if-else-if-0.png">
</p>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 41: </span>lparser.c</label><pre class="src src-c"><span class="linenr">1141: </span><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">ifstat</span> (<span class="org-type">LexState</span> *<span class="org-variable-name">ls</span>, <span class="org-type">int</span> <span class="org-variable-name">line</span>) {
<span class="linenr">1142: </span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">ifstat -&gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1143: </span>  <span class="org-type">FuncState</span> *<span class="org-variable-name">fs</span> = ls-&gt;fs;
<span class="linenr">1144: </span>  <span class="org-type">int</span> <span class="org-variable-name">flist</span>;
<span class="linenr">1145: </span>  <span class="org-type">int</span> <span class="org-variable-name">escapelist</span> = NO_JUMP;
<span class="linenr">1146: </span>  flist = test_then_block(ls);  <span class="org-comment-delimiter">/* </span><span class="org-comment">IF cond THEN block</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1147: </span>  <span class="org-keyword">while</span> (ls-&gt;t.token == TK_ELSEIF) {
<span class="linenr">1148: </span>    luaK_concat(fs, &amp;escapelist, luaK_jump(fs));
<span class="linenr">1149: </span>    luaK_patchtohere(fs, flist);
<span class="linenr">1150: </span>    flist = test_then_block(ls);  <span class="org-comment-delimiter">/* </span><span class="org-comment">ELSEIF cond THEN block</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1151: </span>  }
<span class="linenr">1152: </span>  <span class="org-keyword">if</span> (ls-&gt;t.token == TK_ELSE) {
<span class="linenr">1153: </span>    luaK_concat(fs, &amp;escapelist, luaK_jump(fs));
<span class="linenr">1154: </span>    luaK_patchtohere(fs, flist);
<span class="linenr">1155: </span>    luaX_next(ls);  <span class="org-comment-delimiter">/* </span><span class="org-comment">skip ELSE (after patch, for correct line info)</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1156: </span>    block(ls);  <span class="org-comment-delimiter">/* </span><span class="org-comment">`else' part</span><span class="org-comment-delimiter"> */</span>
<span class="linenr">1157: </span>  }
<span class="linenr">1158: </span>  <span class="org-keyword">else</span>
<span class="linenr">1159: </span>    luaK_concat(fs, &amp;escapelist, flist);
<span class="linenr">1160: </span>  luaK_patchtohere(fs, escapelist);
<span class="linenr">1161: </span>  check_match(ls, TK_END, TK_IF, line);
<span class="linenr">1162: </span>}
</pre>
</div>

<p>
elseif 结构是不限数量的，相比之下，if 和 else 只能有一个，
所以这里用 while 循环来重复检测所有 elseif 块。
</p>

<p>
对于一个 elseif 块，先生成 jmp 指令，再重新调用 <code>test_then_block</code> ，当做一个 if 块来处理。
</p>

<p>
示例代码中只有一个 elseif 块，所以在执行到 line 1151 时，生成字节码如下，
</p>


<div id="orgaa314db" class="figure">
<p><img src="generator-if-else-if-1.png" alt="generator-if-else-if-1.png">
</p>
</div>

<p>
在生成最终的 return 之前，在 line 1159 将 flist 链接到 escapelist 上，因为它们有同样的终点。
</p>

<p>
其中将 4 jmp 指令，跳转到 6 jmp，相当于将 jmp 链接起来，以 escapelist 为索引链的开始。
</p>


<div id="orgd7557e4" class="figure">
<p><img src="generator-if-else-if-2.png" alt="generator-if-else-if-2.png">
</p>
</div>

<p>
最终在 discharge 的时候，只需要顺着 escapelist 往下，就可以访问到所有需要重定位的 jmp 指令，
并进行相应参数的修改。
</p>
</div>
</div>

<div id="outline-container-org76aa6fa" class="outline-4">
<h4 id="org76aa6fa"><span class="section-number-4">4.7.4</span> if elseif else</h4>
<div class="outline-text-4" id="text-4-7-4">
<p>
嵌套的过程，读者可使用上述方法，自主探索，在此不再赘述。
</p>
</div>
</div>
</div>


<div id="outline-container-orgd22754c" class="outline-3">
<h3 id="orgd22754c"><span class="section-number-3">4.8</span> while</h3>
<div class="outline-text-3" id="text-4-8">
<p>
block
</p>

<p>
breakable  1
这样其中才可以生成 break 语句
</p>

<p>
breaklist
用于记录 break 语句，chain 到 block 外的第一条语句
</p>

<p>
enterblock 自然生成 0 block
</p>

<p>
相当于有双层 block
</p>
</div>

<div id="outline-container-org4e04970" class="outline-4">
<h4 id="org4e04970"><span class="section-number-4">4.8.1</span> break</h4>
<div class="outline-text-4" id="text-4-8-1">
</div>
</div>
</div>

<div id="outline-container-orga8fc6ee" class="outline-3">
<h3 id="orga8fc6ee"><span class="section-number-3">4.9</span> repeat</h3>
<div class="outline-text-3" id="text-4-9">
<p>
repeat
</p>

<p>
break 同 while 时的表现相同
</p>


<p>
不过对于 upval，有自己的处理方式
</p>


<p>
因为 while 在 cond 中不能定义新的 local var
而 repeat 的 block 中可能先定义 local var
再被其中的 func 引用，而 i 在不断变化，就需要及时 close
</p>




<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">t</span> = {}

<span class="org-keyword">local</span> <span class="org-variable-name">c</span> = 0

<span class="org-keyword">repeat</span>
   c = c + 1

   <span class="org-keyword">local</span> <span class="org-variable-name">i</span> = c

   t[i] = <span class="org-keyword">function</span> ()
      <span class="org-keyword">return</span> i
   <span class="org-keyword">end</span>
<span class="org-keyword">until</span> i &gt; 10

<span class="org-keyword">for</span> <span class="org-variable-name">i</span>, <span class="org-variable-name">f</span> <span class="org-keyword">in</span> <span class="org-builtin">ipairs</span>(t) <span class="org-keyword">do</span>
   <span class="org-builtin">print</span>(f())
<span class="org-keyword">end</span>
</pre>
</div>

<p>
进行 upval 判断的原因
</p>

<p>
每个 func 记录的都是 i，但是每次 loop 结束都进行了 close，
</p>
</div>
</div>


<div id="outline-container-orgdd98c3b" class="outline-3">
<h3 id="orgdd98c3b"><span class="section-number-3">4.10</span> for</h3>
<div class="outline-text-3" id="text-4-10">
<p>
for loop 特别开发了底层指令来处理，而 repeat 和 while 则没有相应的指令。
依然是通过 jmp 来实现的。
</p>

<p>
分为两种
</p>

<p>
数字迭代 fornum
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">for</span> <span class="org-variable-name">i</span> = 1, 10, 2 <span class="org-keyword">do</span>
  <span class="org-builtin">print</span>(i)
<span class="org-keyword">end</span>
</pre>
</div>

<p>
通用迭代 forlist
</p>

<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">for</span> <span class="org-variable-name">k</span>, <span class="org-variable-name">v</span> <span class="org-keyword">in</span> <span class="org-builtin">pairs</span>(t) <span class="org-keyword">do</span>
  <span class="org-builtin">print</span>(k, v)
<span class="org-keyword">end</span>
</pre>
</div>
</div>

<div id="outline-container-org0202719" class="outline-4">
<h4 id="org0202719"><span class="section-number-4">4.10.1</span> fornum</h4>
<div class="outline-text-4" id="text-4-10-1">
<p>
隐式生成的变量，用 ( 来标识，是不会与正常 lua 代码中分析得到的 NAME 冲突的
因为 lex 规则的限定
</p>

<pre class="example" id="org168d596">
.local  "(for generator)"  ; 0
.local  "(for state)"  ; 1
.local  "(for control)"  ; 2
</pre>
</div>
</div>

<div id="outline-container-org333e2d9" class="outline-4">
<h4 id="org333e2d9"><span class="section-number-4">4.10.2</span> forlist</h4>
<div class="outline-text-4" id="text-4-10-2">
<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">g</span>, <span class="org-variable-name">s</span> = <span class="org-builtin">pairs</span>({1,2,3})

<span class="org-keyword">for</span> <span class="org-variable-name">k</span>, <span class="org-variable-name">v</span> <span class="org-keyword">in</span> g, s, <span class="org-constant">nil</span> <span class="org-keyword">do</span>
  <span class="org-builtin">print</span>(k, v)
<span class="org-keyword">end</span>
</pre>
</div>

<p>
upvalue 同 fornum
</p>
</div>
</div>
</div>

<div id="outline-container-org48de970" class="outline-3">
<h3 id="org48de970"><span class="section-number-3">4.11</span> function call</h3>
<div class="outline-text-3" id="text-4-11">
<p>
function call
</p>

<p>
func 在栈的底部，参数向上累加
</p>

<p>
调用结果，返回值，从栈的 func 处开始向上覆盖
</p>

<p>
funcargs()
lparser.c:609
</p>

<p>
并不复杂
</p>
</div>

<div id="outline-container-org5a6b901" class="outline-4">
<h4 id="org5a6b901"><span class="section-number-4">4.11.1</span> self</h4>
<div class="outline-text-4" id="text-4-11-1">
<div class="org-src-container">
<pre class="src src-lua"><span class="org-keyword">local</span> <span class="org-variable-name">o</span> = {}

<span class="org-keyword">function</span> <span class="org-function-name">o.f</span>(<span class="org-builtin">self</span>)
  <span class="org-builtin">print</span>(<span class="org-builtin">self</span>)
<span class="org-keyword">end</span>

<span class="org-keyword">function</span> <span class="org-function-name">o:f</span>()
  <span class="org-builtin">print</span>(<span class="org-builtin">self</span>)
<span class="org-keyword">end</span>

o.f(o)

o:f()
</pre>
</div>

<p>
self 指令，只是一种优化方式
</p>



<p>
luaK<sub>self</sub>()
</p>

<p>
lcode.c:503
</p>

<p>
结合 op self 的语义，并不复杂
</p>

<p>
self 只是为 call 做准备，将对象提前放到相应位置
</p>
</div>
</div>
</div>


<div id="outline-container-org84d3938" class="outline-3">
<h3 id="org84d3938"><span class="section-number-3">4.12</span> ret</h3>
<div class="outline-text-3" id="text-4-12">
<p>
return 在 chunk 中发挥作用
从当前 closure 中返回
</p>

<p>
return 必须是 chunk 的最后一个语句
</p>

<p>
按语句含义返回值，至于有多少值被利用，则根据 opcode 生成过程中决定的
</p>

<p>
opcode 容易理解
</p>

<p>
retstat()
lparser.c:1238
</p>
</div>

<div id="outline-container-org0510e67" class="outline-4">
<h4 id="org0510e67"><span class="section-number-4">4.12.1</span> tailcall</h4>
<div class="outline-text-4" id="text-4-12-1">
<div class="org-src-container">
<pre class="src src-lua"><span class="org-comment-delimiter">-- </span><span class="org-comment">tail call</span>
<span class="org-keyword">return</span> f()
<span class="org-comment-delimiter">-- </span><span class="org-comment">not tail call</span>
<span class="org-keyword">return</span> a, b, f()
</pre>
</div>

<p>
ret 中只有单独的 function call
</p>

<p>
进行栈优化
</p>

<p>
lparser.c:1249
</p>

<p>
tailcall 本身已经有了 return 的语义
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-orgb67fb9c" class="outline-2">
<h2 id="orgb67fb9c"><span class="section-number-2">5</span> practice</h2>
<div class="outline-text-2" id="text-5">
<p>
理想的 vm
独立，lua 实现对 vm 做了协同的妥协
</p>
</div>

<div id="outline-container-org959b5ec" class="outline-3">
<h3 id="org959b5ec"><span class="section-number-3">5.1</span> arithmetic</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>优先级</li>
</ul>

<p>
lua 在进行解析时，没有进行关系运算的实时解析，但是对 constant 算法运算有编译时执行
</p>

<p>
如 `local a = 5 &gt; 2` 和 `local a = 1 + 2` 的区别
</p>

<p>
前者需要生成 jmp 指令，但是后者，直接是 loadk 0 0 ; 3
</p>
</div>
</div>

<div id="outline-container-org5aa406e" class="outline-3">
<h3 id="org5aa406e"><span class="section-number-3">5.2</span> logic</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>and or</li>
</ul>
</div>
</div>

<div id="outline-container-org5da4352" class="outline-3">
<h3 id="org5da4352"><span class="section-number-3">5.3</span> constructor</h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li>setlist always consistent, diff with settable</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<p>Updated: 2021-01-14 四 11:34</p>
<p>Created: 2021-01-08 五 11:34</p>
<p>Author: DreamAndDead</p>
<p>Email: <a href="mailto:dreamanddead@foxmail.com">dreamanddead@foxmail.com</a></p>
<script src="https://utteranc.es/client.js" repo="DreamAndDead/DreamAndDead.github.io" issue-term="pathname" label="Comment" theme="github-light" crossorigin="anonymous" async></script>
</div>
</body>
</html>
