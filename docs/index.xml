<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docs on lua 5.1 source guide</title><link>https://dreamanddead.github.io/lua-5.1-source-guide/docs/</link><description>Recent content in Docs on lua 5.1 source guide</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 19 Jan 2021 15:16:00 +0800</lastBuildDate><atom:link href="https://dreamanddead.github.io/lua-5.1-source-guide/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>gc</title><link>https://dreamanddead.github.io/lua-5.1-source-guide/docs/gc/</link><pubDate>Tue, 19 Jan 2021 15:16:00 +0800</pubDate><guid>https://dreamanddead.github.io/lua-5.1-source-guide/docs/gc/</guid><description>本章来讲解 Lua 内部实现的 gc 机制。
algo # gc 算法有很多种，Lua 采用一种增量式三色标记清除算法来实现 gc 机制。
之所以说一种，是因为采用的 gc 算法与其说是一个算法，不如说是一类算法， 大体的思想是相同的，不过在实现细节有些许不同。
mark &amp;amp; sweep # 双色标记清除算法是最经典的算法。
初始阶段，所有对象标记为白色；
标记阶段，将所有从 root 可达的对象标记为黑色；
回收阶段，将所有白色对象回收，同时将所有黑色对象重新标记回白色；
gc 的过程，就在这些阶段中循环进行，所有对象在两种颜色间完成标记和清理。
不过在传统的标记清除算法中，gc 过程是一个整体，主程序在这期间需要暂停。 如果需要处理的对象过多，则主程序需要暂停过长时间。
tri color incremental mark &amp;amp; sweep # 三色标记清除算法是对上述算法的改进。
引入了第三种颜色灰色，使 gc 过程可以增量式的运行， 即 gc 过程可以分成短时间的小段穿插在主程序间执行。
改进后的 gc 过程如下：
初始阶段，所有对象标识为白色；
标记阶段的开始，将所有从 root 可达的对象标记为灰色；
标记阶段，逐个取出灰色对象，将其所有可达的白色对象标记为灰色，最后将自身标记为黑色；
清除阶段，当不存在灰色对象时，开始清除白色对象，将所有黑色对象标记回白色。
改进后的算法，标记阶段可以增量式的运行，随时暂停和继续。</description></item><item><title>std lib</title><link>https://dreamanddead.github.io/lua-5.1-source-guide/docs/stdlib/</link><pubDate>Mon, 18 Jan 2021 16:08:00 +0800</pubDate><guid>https://dreamanddead.github.io/lua-5.1-source-guide/docs/stdlib/</guid><description>在 lex 章节提到，require next 之类不是关键字而是函数， 在 api 章节提到 api 也用于内部作用， 它们描述的都是 lua 标准库。
本章节就来讲解 lua 内部是如何处理标准库的。
register # 标准库可以说是多种功能函数的集合，在被使用之前，必须先被注册。
18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #define LUA_COLIBNAME &amp;#34;coroutine&amp;#34; LUALIB_API int (luaopen_base) (lua_State *L); #define LUA_TABLIBNAME &amp;#34;table&amp;#34; LUALIB_API int (luaopen_table) (lua_State *L); #define LUA_IOLIBNAME &amp;#34;io&amp;#34; LUALIB_API int (luaopen_io) (lua_State *L); #define LUA_OSLIBNAME &amp;#34;os&amp;#34; LUALIB_API int (luaopen_os) (lua_State *L); #define LUA_STRLIBNAME &amp;#34;string&amp;#34; LUALIB_API int (luaopen_string) (lua_State *L); #define LUA_MATHLIBNAME &amp;#34;math&amp;#34; LUALIB_API int (luaopen_math) (lua_State *L); #define LUA_DBLIBNAME &amp;#34;debug&amp;#34; LUALIB_API int (luaopen_debug) (lua_State *L); #define LUA_LOADLIBNAME &amp;#34;package&amp;#34; LUALIB_API int (luaopen_package) (lua_State *L); /* open all previous libraries */ LUALIB_API void (luaL_openlibs) (lua_State *L); Code Snippet 1: lualib.</description></item><item><title>c api</title><link>https://dreamanddead.github.io/lua-5.1-source-guide/docs/api/</link><pubDate>Fri, 15 Jan 2021 17:48:00 +0800</pubDate><guid>https://dreamanddead.github.io/lua-5.1-source-guide/docs/api/</guid><description>Lua 的一个杰出的特性是，非常易于与 C 程序集成。
一个原因是 Lua 本身是用 C 语言实现的， 另一个原因则是 Lua 内部在 vm 层面设计提供了相应的 api。
design # 从之前的视角来看，代码编译为 Proto，vm 开启线程，封装为 Closure 并按指令执行。
从另一个角度来看 Lua 代码的运行过程。
如果反过来看，vm 本身是静态不动的，程序的运行由输入的 Proto 而驱动。 之所以产生这样的视角，是因为 vm 必须有指令输入，告诉其应该执行什么， 否则 vm 本身也只是空转而已。
api 层提供的功能就是如此，控制 vm 应该如何执行。
如此来看，Lua 代码和 api 都是在操作 lua_State ，vm 的运行时状态。 只不过一个是编译为 opcode 由 vm 主动执行，一个是通过 c 函数接口来直接控制。
值得注意的时，api 不仅提供与语言外部使用，也在内部发挥着重要作用。
api 在外部使用，可以将 Lua 作为 C lib 来使用； 同时 api 在内部，实现了诸多 Lua 语言标准库的功能。</description></item><item><title>vm</title><link>https://dreamanddead.github.io/lua-5.1-source-guide/docs/vm/</link><pubDate>Thu, 14 Jan 2021 17:50:00 +0800</pubDate><guid>https://dreamanddead.github.io/lua-5.1-source-guide/docs/vm/</guid><description>代码生成完成之后，整个文件分析成为一个单独的 Proto，交由 vm 来执行。
和 parser 相比，vm 更容易琢磨，因为它只会从 Proto 中取出字节码， 并按照指令的含义一行一行来执行。
所以各种指令的执行过程不是本章的重点，只需要参考 opcode 相应的注释就不难理解， 本章更关注 vm 内部各个组件的协同过程。
model # 之前在 opcode 章节简单提到了 vm 内部的模型，这里来详细讨论各个部分。
code # vm 所执行的代码来自 parser，即存储在 Proto 中。
228 229 230 231 232 233 234 235 236 237 /* ** Function Prototypes */ typedef struct Proto { CommonHeader; TValue *k; /* constants used by the function */ Instruction *code; struct Proto **p; /* functions defined inside the function */ int *lineinfo; /* map from opcodes to source lines */ struct LocVar *locvars; /* information about local variables */ Code Snippet 1: lobject.</description></item><item><title>generator</title><link>https://dreamanddead.github.io/lua-5.1-source-guide/docs/generator/</link><pubDate>Fri, 08 Jan 2021 11:34:00 +0800</pubDate><guid>https://dreamanddead.github.io/lua-5.1-source-guide/docs/generator/</guid><description>上一章尝试单独解析语法分析过程，本章关注具体的代码生成过程。
function vs proto vs closure # 在具体深入代码生成之前，先来区分三个概念，function proto 和 closure。
function，是 lua 语言中定义的概念，是 8 种基础类型之一，表示函数， 具体在 lua 代码中用关键字 function 来定义。
如同 string 概念在底层由 TString 结构来实现一样， function 在底层用 Proto 结构来实现，是 function 整体编译之后得到的同语义结构。
编译得到的 Proto 是静态的，在实际运行的时候，需要封装为 Closure 结构，交由 vm 来执行。 Closure 为 upvalue 分配了空间，并统一表示了 c function 和 lua function。
这也是为什么在 object 章节，提到基础类型对应的实现结构时，用 Closure 而不是用 Proto 来表示 function。
所以在编译时期，我们关注 Proto，而在运行时期，才关注 Closure。
chunk # lua 内部使用了一种巧妙的实现，在编译时，将整个文件当做一个匿名 function 来对待。 相当于文件头加了 function () ，文件尾加了 end 。</description></item><item><title>parser</title><link>https://dreamanddead.github.io/lua-5.1-source-guide/docs/parser/</link><pubDate>Thu, 07 Jan 2021 15:46:00 +0800</pubDate><guid>https://dreamanddead.github.io/lua-5.1-source-guide/docs/parser/</guid><description>在 lexer 章节提到，lua 为了效率，将语法分析到代码生成的所有功能封装在 parser 模块中。 在过程中，没有 AST IR 等中间产物，直接从 token 到 opcode，一步到位。 相对的，这部分代码就相对难以理解。
虽然在代码实现没有明显的步骤划分，但是对于读者， 在理解代码过程中，还是先找出不同步骤的影子，最后再串联在一起。
这个章节，就是尝试从代码中“分离”出语法分析的部分，先对模块做初步的理解。
grammar # 模块以语法分析作为入口，整体是一个语法制导翻译的过程。
官方文档1使用上下文无关文法来描述 lua 语法，但是省略了一些细节。 笔者结合 parser 代码中的实现过程和相关注释，重新整理语法描述如下，使用 EBNF 描述。
chunk ::= { stat [ `;&amp;#39; ] } stat ::= ifstat | whilestat | dostat | forstat | repeatstat | funcstat | localstat | retstat | breakstat | exprstat ifstat ::= IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END cond ::= expr block ::= chunk whilestat ::= WHILE cond DO block END dostat ::= DO block END forstat ::= FOR (fornum | forlist) END fornum ::= NAME = expr `,&amp;#39; expr [`,&amp;#39; expr] forbody forlist ::= NAME {`,&amp;#39; NAME} IN explist forbody forbody ::= DO block repeatstat ::= REPEAT block UNTIL cond funcstat ::= FUNCTION funcname body funcname ::= NAME {`.</description></item><item><title>opcode</title><link>https://dreamanddead.github.io/lua-5.1-source-guide/docs/opcode/</link><pubDate>Wed, 06 Jan 2021 16:12:00 +0800</pubDate><guid>https://dreamanddead.github.io/lua-5.1-source-guide/docs/opcode/</guid><description>按顺序，本章应该讲解 parser 相关的内容。
之前提到，parser 模块将语法分析与代码生成揉合在一起，为了更容易理解 parser 的功能， 先对最终生成的代码 opcode 做一些了解，到时就可以带着目的去阅读。
opcode 字节码，是编译阶段的最终结果。 类比来看，C 编译为机器码，由机器执行；lua 编译为 opcode 由 vm 执行。
可以说，opcode 是上层 lua 代码与 vm 的中间层，是语义的约定。 本章关注 opcode 的表示方式及含义。
format # 所有 opcode 都是定长的，4 bytes 32 bits，单个指令用 unsigned int 表示。
84 85 86 87 88 /* ** type for virtual-machine instructions ** must be an unsigned with (at least) 4 bytes (see details in lopcodes.h) */ typedef lu_int32 Instruction; Code Snippet 1: llimits.</description></item><item><title>lexer</title><link>https://dreamanddead.github.io/lua-5.1-source-guide/docs/lexer/</link><pubDate>Tue, 05 Jan 2021 16:40:00 +0800</pubDate><guid>https://dreamanddead.github.io/lua-5.1-source-guide/docs/lexer/</guid><description>之前的章节，关注的是内部的一些实现，为后续打基础。
后续的章节关注 lua 是如何从文本代码到最终实际运行起来的。
本章关注 lua 中的词法分析部分，即 lexer，这通常是编译过程的第一步。
lexer # 传统的编译过程大家都不陌生。
lua 是解释型语言，但同样存在从源码到字节码的编译过程，区别在于其运行在 VM 上。
经过历史的演变，lua 的内部实现为了效率，遵从如下的过程。
AST 使用虚线表示，是因为内部没有显式的 AST 结构。
综合来看，lexer 完成了从 code 到 token 的过程， parser 孤身一人完成了从 token 到 opcode 的过程。
单纯从从文件角度看，lua 代码只是文本文件，由字符组成。 文本形式的编程语言由机器理解并执行，需要经过一系列组件的处理过程。 不同组件有明确的分工，不同的组件有不同的输入和输出，组成上下游关系。
lexer 通常是第一个组件，将源代码转换为 token，将字符流转化为 token 流，作为后续 parser 的输入。
Token # 简单的说，token 就是多个字符组成的有序序列。
lua 内部用 struct 表示 token，
43 44 45 46 47 48 49 50 51 52 typedef union { lua_Number r; TString *ts; } SemInfo; /* semantics information */ typedef struct Token { int token; SemInfo seminfo; } Token; Code Snippet 1: llex.</description></item><item><title>table</title><link>https://dreamanddead.github.io/lua-5.1-source-guide/docs/table/</link><pubDate>Wed, 30 Dec 2020 11:53:00 +0800</pubDate><guid>https://dreamanddead.github.io/lua-5.1-source-guide/docs/table/</guid><description>初次接触 lua 的人都有困惑， 多数动态语言都会内建 dict 和 array 的概念，而 lua 用 table 同时表示这两个概念。
所谓 dict 不过是 kv 存储，从某种角度来看，可以将 array 看作 k 是整数的一种特殊情况。
本章就来从源码角度认识 lua 中的 table。
structure # 338 339 340 341 342 343 344 345 346 347 348 typedef struct Table { CommonHeader; lu_byte flags; /* 1&amp;lt;&amp;lt;p means tagmethod(p) is not present */ lu_byte lsizenode; /* log2 of size of `node&amp;#39; array */ struct Table *metatable; TValue *array; /* array part */ Node *node; Node *lastfree; /* any free position is before this position */ GCObject *gclist; int sizearray; /* size of `array&amp;#39; array */ } Table; table 的结构并不复杂，除去 CommonHeader 和 gclist，剩余的字段可分为 3 部分。</description></item><item><title>string</title><link>https://dreamanddead.github.io/lua-5.1-source-guide/docs/string/</link><pubDate>Tue, 29 Dec 2020 11:57:00 +0800</pubDate><guid>https://dreamanddead.github.io/lua-5.1-source-guide/docs/string/</guid><description>string 是多数编程语言内建的类型，lua 也不例外。
lua 代码中使用字符串是非常方便的，呼之即来，使用后也可以不闻不问。 因为 string 在底层自动新建，并由 gc 自动回收，极大方便了上层使用者。
更重要的是，string 同时也在 lua 的底层实现发挥着重要的作用。
本章就来讲解 lua 中的 string。
structure # 在 object 章节中已经提到，string 类型在 GCObject 中用 TString ts 表示。
196 197 198 199 200 201 202 203 204 205 206 207 /* ** String headers for string table */ typedef union TString { L_Umaxalign dummy; /* ensures maximum alignment for strings */ struct { CommonHeader; lu_byte reserved; unsigned int hash; size_t len; } tsv; } TString; Code Snippet 1: lobject.</description></item><item><title>memory</title><link>https://dreamanddead.github.io/lua-5.1-source-guide/docs/memory/</link><pubDate>Wed, 23 Dec 2020 11:59:00 +0800</pubDate><guid>https://dreamanddead.github.io/lua-5.1-source-guide/docs/memory/</guid><description>内存管理对所有程序都很关键，对于动态语言更是如此。
lua 是单线程程序，即使在内部实现了协程，但内存还是统一管理的。
内存回收使用 gc 算法，是非常重要的模块，而相对地，内存分配就显得非常简单。
本章就讲解 lua 源码中关于内存分配的内容。
core api # 内存分配，无外乎涉及 3 个基础 api
malloc realloc free 对于了解操作系统和 C 语言的大家都不陌生。
lua 内部将其简化为 1 个 api，定义原型为 lua_Alloc
63 64 65 66 /* ** prototype for memory-allocation functions */ typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize); Code Snippet 1: lua.h 这是一个函数指针，规定其行为需遵从如下约定
23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* ** About the realloc function: ** void * frealloc (void *ud, void *ptr, size_t osize, size_t nsize); ** (`osize&amp;#39; is the old size, `nsize&amp;#39; is the new size) ** ** Lua ensures that (ptr == NULL) iff (osize == 0).</description></item><item><title>object</title><link>https://dreamanddead.github.io/lua-5.1-source-guide/docs/object/</link><pubDate>Wed, 23 Dec 2020 11:59:00 +0800</pubDate><guid>https://dreamanddead.github.io/lua-5.1-source-guide/docs/object/</guid><description>lua 是一种动态类型语言，类型不存在于变量中，而存在于值本身。
语言中定义了 8 种类型的值
nil bool number string table function userdata thread 虽然章节名称为 object，和源代码的名称相同。 但是通常都翻译为“对象”，容易与 OOP 中的对象概念混杂在一起。 在本章，更乐意将其译为“值”。
从某种角度而言，程序就是“数据”与“操作数据的方法”。 所以第一步，先来了解 lua 中的值。
tagged value # 章节开始就提到，类型存在于值本身。 在 lua 内部，用 TValue（tagged value）结构表示值的概念。
67 68 69 70 71 72 73 74 75 /* ** Tagged Values */ #define TValuefields Value value; int tt typedef struct lua_TValue { TValuefields; } TValue; Code Snippet 1: lobject.h tt 表示值的类型，value 表示值的数据。 明显地，类型是值的一部分。</description></item><item><title>overview</title><link>https://dreamanddead.github.io/lua-5.1-source-guide/docs/overview/</link><pubDate>Mon, 21 Dec 2020 10:40:00 +0800</pubDate><guid>https://dreamanddead.github.io/lua-5.1-source-guide/docs/overview/</guid><description>project # file structure # file/dir desc lua-5.1.5/ lua 源代码 install/ 编译 lua 源代码的结果，安装当前目录 tool/ 一些第三方辅助工具 draft/ 本书草稿 book/ 本书发布内容，org 格式 docs/ 本书发布内容，html 格式 opcode/ 关于 opcode 的测试代码 statement/ 关于 statement 的测试代码 test/ 关于其它功能的测试代码 helper.py gdb 脚本，辅助打印数据结构 init.gdb gdb 脚本，用作调试入口 lex.</description></item></channel></rss>