#+SETUPFILE: setup.org

#+TITLE: generator
#+DATE: <2021-01-08 五 11:34>

上一章尝试单独解析语法分析过程，本章关注具体的代码生成过程。

#+begin_src dot :file generator-feature.png
digraph {
	rankdir = TB;
	node[shape=box];

	lua[label="Lua Code"];
	tk[label="Token"];

	subgraph cluster_0 {
	ast[label="AST", style="dotted"];
	op[label="Opcode"];
	style=filled;
	color=lightblue;
}
	vm[label="VM"];

	lua -> tk[label="lex"];
	tk -> ast[label="parse"];
	ast -> op[label="generate"];
	op -> vm[label="executed"];
}
#+end_src

#+RESULTS:
[[file:generator-feature.png]]

* function vs proto vs closure

在具体深入代码生成之前，先来区分三个概念，function proto 和 closure。

function，是 lua 语言中定义的概念，是 8 种基础类型之一，表示函数，
具体在 lua 代码中用关键字 =function= 来定义。

如同 string 概念在底层由 TString 结构来实现一样，
function 在底层用 Proto 结构来实现，是 function 整体编译之后得到的同语义结构。

编译得到的 Proto 是静态的，在实际运行的时候，需要封装为 Closure 结构，交由 vm 来执行。
Closure 为 upvalue 分配了空间，并统一表示了 c function 和 lua function。

这也是为什么在 object 章节，提到基础类型对应的实现结构时，用 Closure 而不是用 Proto 来表示 function。

所以在编译时期，我们关注 Proto，而在运行时期，才关注 Closure。

** chunk

lua 内部使用了一种巧妙的实现，在编译时，将整个文件当做一个匿名 function 来对待。
相当于文件头加了 =function ()= ，文件尾加了 =end= 。

#+caption: lparser.c
#+INCLUDE: ../lua-5.1.5/src/lparser.c src c -n 383 :lines "383-399"

可以看到， =luaY_parser= 读取文件，最终生成并返回 =Proto *= 。

因为整体分析的入口是 chunk，lua 又将文件当做匿名函数来对待，
这也是很多 lua 书籍中提到 chunk 的原因，表示文件编译得到的结果。

** embeded

如果按照 function 和 Proto 一一对应的关系，会出现函数层级的问题。

比如下面的示例代码，

#+begin_src lua
function a()
   function b()
   end
end

function c()
   function d()
   end

   function e()
   end
end
#+end_src

如果将 lua 代码文件看作 Proto chunk，代码中定义的 a b c d 同样是 function 且编译为 Proto。
但是 function a b c d e 是 lua 代码的一部分，所以其 Proto 也应该被包含在 Proto chunk 中。

lua 内部根据 function 定义的位置，来记录这种包含关系。

#+begin_src dot :file generator-function-level.png
digraph {
	node[shape=box];
	
	subgraph cluster_0 {
		label="chunk()";

		subgraph cluster_2 {
			label="c()";

			e[label="e()"];
			d[label="d()"];
		}

		subgraph cluster_1 {
			label="a()";

			b[label="b()"];
		}
	}
}
#+end_src

#+RESULTS:
[[file:generator-function-level.png]]

function a c 直接定义在代码文件（顶层匿名函数）中，
b d e 则直接定义在 a 和 c 中。

#+begin_src dot :file generator-proto-level.png
digraph {
	node[shape=box];

	rankdir = LR;

	ac[shape=record, label=" <a> a | <c> c "];
	de[shape=record, label=" <d> d | <e> e "];

	chunk -> ac:a[label="p"];
	ac:a -> b[label="p"];
	ac:c -> de:d[label="p"];
}
#+end_src

#+RESULTS:
[[file:generator-proto-level.png]]

Proto 结构中使用 struct Proto * 数组 p（Line 235）来记录其直接包含的 Proto。

#+caption: lobject.h
#+INCLUDE: ../lua-5.1.5/src/lobject.h src C -n 228 :lines "228-254"

** FuncState

在 lua 的语法分析中，function 解析是一个重要的部分。

EBNF 和 regex 的区别在于，EBNF 可以描述一种递归过程，而 regex 则不能。

chunk 作为解析 function 的入口，得到 Proto，这个过程在遇到 function 定义时，不断的递归调用，生成 Proto，
并按照层级链接起来。

在了解这个过程之前，要先介绍另一个重要的结构 FuncState 。

#+caption: lparser.h
#+INCLUDE: ../lua-5.1.5/src/lparser.h src c -n 57 :lines "57-76"

从名称可以看出，和 LexState 相似，也用于记录中间状态。
FuncState 用于记录 function 分析过程中的状态，和 function 定义一一对应，
每遇到一个 function 定义时，lua 都会新建一个 FuncState，记录当下解析 function 的中间状态。

** big picture

LexState FuncState Proto 这三者在分析过程中协同生成最终的 Proto。

比如解析如下示例代码，

#+begin_src lua -n 1
function a()
   function b()
   end
end
#+end_src

在整体文件分析开始之前，parser 已经准备好 FuncState，通过 LexState.ls 索引，
FuncState.f 指向相应要生成的 Proto。

#+CAPTION: ls fs f big picture
#+begin_src dot :file generator-big-picture-0.png
digraph {
	node[shape=box];
	rankdir=LR;

	ls;
	c[label="fs"];
	cp[label="f"];

	ls -> c -> cp;
}
#+end_src


#+RESULTS:
[[file:generator-big-picture-0.png]]

解析第 1 行之后，需要函数定义 a，parser 生成新的 FuncState，并更新 ls.fs 的指向。
同时，fs a 通过 prev 指向 fs chunk，表示层级关系。

#+begin_src dot :file generator-big-picture-1.png
digraph {
	node[shape=box];
	rankdir=LR;

	ls;
	c[label="fs"];
	cp[label="f"];

	f[label="fs"];
	fp[label="f"];

	ls -> f;
	c -> cp;

	f -> fp;
	f -> c[label="prev"];

	{rank=same; c; f;}
}
#+end_src

#+RESULTS:
[[file:generator-big-picture-1.png]]


第 2 行，遇到函数 b 定义，同样的，生成 FuncState 并更新 ls.fs 的指向。

#+begin_src dot :file generator-big-picture-2.png
digraph {
	node[shape=box];
	rankdir=LR;

	ls;
	c[label="fs"];
	cp[label="f"];

	f[label="fs"];
	fp[label="f"];

	g[label="fs"];
	gp[label="f"];

	ls -> g;
	c -> cp;

	f -> fp;
	f -> c[label="prev"];

	g -> gp;
	g -> f[label="prev"];

	{rank=same; c; f; g;}
}
#+end_src

#+RESULTS:
[[file:generator-big-picture-2.png]]

第 3 行，函数 b 定义结束，此时 ls.fs 指向 fs b 的 prev，回到上个函数定义层级。
并将函数 b 生成的 Proto 链接到上层函数 a 的 Proto。

此时，fs b 已经结束其作用。

#+begin_src dot :file generator-big-picture-3.png
digraph {
	node[shape=box];
	rankdir=LR;

	ls;
	c[label="fs"];
	cp[label="f"];

	f[label="fs"];
	fp[label="f"];

	g[label="fs", style=dashed];
	gp[label="f"];

	ls -> f;
	c -> cp;

	f -> fp;
	f -> c[label="prev"];

	g -> gp;
	g -> f[label="prev"];

	{rank=same; c; f; g;}

	fp -> gp[label="p[0]"];
}
#+end_src

#+RESULTS:
[[file:generator-big-picture-3.png]]

#+begin_src dot :file generator-big-picture-4.png
digraph {
	node[shape=box];
	rankdir=LR;

	ls;
	c[label="fs"];
	cp[label="f"];

	f[label="fs", style=dashed];
	fp[label="f"];

	g[label="fs", style=dashed];
	gp[label="f"];

	ls -> c -> cp;

	f -> fp;
	f -> c[label="prev"];

	g -> gp;
	g -> f[label="prev"];

	{rank=same; c; f; g;}

	fp -> gp[label="p[0]"];
	cp -> fp[label="p[0]"];
}
#+end_src

#+RESULTS:
[[file:generator-big-picture-4.png]]

第 4 行，函数 a 定义结束，同上，更新 ls.fs 指向，并链接 Proto a 到 Proto chunk。

#+begin_src dot :file generator-big-picture-5.png
digraph {
	node[shape=box];
	rankdir=LR;

	ls[label="ls", style=dashed];
	c[label="fs", style=dashed];
	cp[label="f", style=filled, color=lightblue];

	f[label="fs", style=dashed];
	fp[label="f"];

	g[label="fs", style=dashed];
	gp[label="f"];

	ls -> c -> cp;

	f -> fp;
	f -> c[label="prev"];

	g -> gp;
	g -> f[label="prev"];

	{rank=same; c; f; g;}

	fp -> gp[label="p[0]"];
	cp -> fp[label="p[0]"];
}
#+end_src

#+RESULTS:
[[file:generator-big-picture-5.png]]

最终返回 Proto chunk，ls 和 fs 都已经结束其使命，毕竟它们的作用只用于记录中间状态

在 parser 内部，上面描述的过程发生在 =open_func() close_func()= 中，读者可仔细体会其细节。

#+caption: lparser.c
#+INCLUDE: ../lua-5.1.5/src/lparser.c src c -n 328 :lines "328-381"

** FuncState vs Proto
   :LOGBOOK:
   - Note taken on [2021-01-11 一 14:06] \\
     为什么 local var 和 active local var 存储在两个部分？
     
     因为相应的索引，在生成 code 之后，相当于信息已经存储于 code 的参数中，不需要另行存储
     且 active 只记录一种状态而已，辅助生成正确的代码，在不同阶段是不同的。
     
     因为 active 状态只能在 parse 过程分辨。
     离开作用域自然不是 active 的。
     而是否 active 对于 bytecode 并不重要。
     active 状态用于辅助 funcstate 生成 bytecode。
   - Note taken on [2021-01-11 一 14:06] \\
     关于 upval 的信息，隐藏在了 code 中
   :END:

FuncState 和 Proto 作为分析过程中两个最重要的结构，值得详细做一番了解。

仔细观察两个结构内部的字段，会发现两者之间有紧密的联系，界限很模糊，
都些许记录了分析过程的结果。
关键的差异在于，Proto 只保留最终结果，而 FuncState 记录中间状态。

对应这个原则，来详细探究下两个结构的内部。

先来看 Proto。

#+caption: lobject.h
#+INCLUDE: ../lua-5.1.5/src/lobject.h src C -n 228 :lines "228-254"

其中字段分为 3 部分来看

暂不讨论
- =int *lineinfo=
- =TString *source=
- =int linedefined=
- =int lastlinedefined=
- =GCObject *gclist=

元信息
- =lu_byte numparams= ，函数的固定参数个数
- =lu_byte is_vararg= ，函数的可变参数
- =lu_byte maxstacksize= ，函数运行时，最大使用的栈空间

数组结果
- =TValue *k= ，常量表
- =Instruction *code= ，字节码
- =struct Proto **p= ，内部其它函数定义
- =struct LocVar *locvars= ，局部变量信息
- =TString **upvalues= ，upvalue 信息
- 与 len size 相关的字段

对照之前对 vm 执行模型的讨论，code 和 k 就与之对应。

这里一个有意思的区别，在于 size 和 n。

上面提到的 5 个数组，都对应一个 size 字段，用于记录数组的大小。
同时，也对应一个 n 字段，用于记录当前数组已使用的大小（下一个空闲的位置）。

在分析的过程中，数组 size 值记录空间总长度，当空间不足时，会继续扩大分配。
而数组 n 值用于时刻标识下一个空闲索引，记录分析结果并自增，它的值比 size 小。

当最终分析结束时，将 n 值赋值给相应的 size 值，省略多余不用的空间，此时两者才会相同。

如此看来，n 值应该存放在 FuncState 中，但是存在例外的是 =lu_byte nups= 。

#+begin_src dot :file generator-fcode.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fcode[shape=record, label="
	      | | | | <n> | | |
	      ", xlabel="f->code"];

	fsizecode[label="f->sizecode", shape=plain];
	
	fspc[label="fs->pc", shape=plain];

	fspc -> fcode:n;
}
#+end_src

#+RESULTS:
[[file:generator-fcode.png]]

#+begin_src dot :file generator-fk.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fk[shape=record, label="
	      | | | | <n> | | |
	      ", xlabel="f->k"];

	fsizek[label="f->sizek", shape=plain];
	
	fsnk[label="fs->nk", shape=plain];

	fsnk -> fk:n;
}
#+end_src

#+RESULTS:
[[file:generator-fk.png]]

#+begin_src dot :file generator-fp.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fp[shape=record, label="
	      | | | | <n> | | |
	      ", xlabel="f->p"];

	fsizep[label="f->sizep", shape=plain];
	
	fsnp[label="fs->np", shape=plain];

	fsnp -> fp:n;
}
#+end_src

#+RESULTS:
[[file:generator-fp.png]]


#+begin_src dot :file generator-fupval.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fupval[shape=record, label="
	      | | | | <n> | | |
	      ", xlabel="f->upvalues"];

	fsizeupval[label="f->sizeupvalues", shape=plain];
	
	fnups[label="f->nups", shape=plain];

	fnups -> fupval:n;
}
#+end_src

#+RESULTS:
[[file:generator-fupval.png]]

#+begin_src dot :file generator-flocvars.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	flocvars[shape=record, label="
	      | | | | <n> | | |
	      ", xlabel="f->locvars"];

	fsizelocvars[label="f->sizelocvars", shape=plain];
	
	fsnlocvars[label="fs->nlocvars", shape=plain];

	fsnlocvars -> flocvars:n;
}
#+end_src

#+RESULTS:
[[file:generator-flocvars.png]]

相同的视角，来观察 FuncState。

#+caption: lparser.h
#+INCLUDE: ../lua-5.1.5/src/lparser.h src c -n 57 :lines "57-76"

暂不讨论
- =Proto *f=
- =struct FuncState *prev=
- =struct LexState *ls=
- =struct lua_State *L=

后续讨论
- =struct BlockCnt *bl=
- =int lasttarget=
- =int jpc=
- =int freereg=

中间结果
- =upvaldesc upvalues[LUAI_MAXUPVALUES]=
- =unsigned short actvar[LUAI_MAXVARS]=
- 其它 n 字段

两个数组是定长的，即 size 是固定的， =f->nups= =fs->nactvar= 用于对应其 n 字段。

#+begin_src dot :file generator-fsupval.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fsupval[shape=record, label="
	      | | | | <n> | | |
	      ", xlabel="fs->upvalues"];

	fssizeupval[label="LUAI_MAXUPVALUES", shape=plain];
	
	fnups[label="f->nups", shape=plain];

	fnups -> fsupval:n;
}
#+end_src

#+RESULTS:
[[file:generator-fsupval.png]]

#+begin_src dot :file generator-fsactvar.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fsactvar[shape=record, label="
	      | | | | <n> | | |
	      ", xlabel="fs->actvar"];

	fssizeactvar[label="LUAI_MAXVARS", shape=plain];
	
	fsnactvar[label="fs->nactvar", shape=plain];

	fsnactvar -> fsactvar:n;
}
#+end_src

#+RESULTS:
[[file:generator-fsactvar.png]]

在编译过程中，所得到的结果会不断的存储入上述数组及其它字段中。

* generate

从某种角度看，编译过程就是规则间的同义转换过程。

代码生成，最终将符合语法规则的 lua 代码，生成为 vm 可执行的同义字节码，
这个过程是隐藏在语法分析下的艺术。

两个规则间可以进行同义转换的连接点，在于对 vm 的共识，
正因为编译器"懂得" vm，知晓字节码的格式与功能，知晓运行时的栈结构，
知晓 k 表 Gbl 表的读取方式，才能生成 vm 可执行的同义字节码。

这种共识贯穿在整个代码生成的过程中。

但是无论编译器如何了解 vm，编译时和运行时还是存在区别的。
代码生成时，只是想象存在一个假想的 vm，它在执行生成的所有结果。

所以代码生成这个过程是最为繁杂的，到 vm 真正运行时反而轻松了，只需要读指令，执行指令就可以了。

阅读代码生成相关的代码，笔者还没有精确地把握住其中的原理，只能提供几个原则给读者参考，
- 总体是语法制导翻译的过程
- 使用后缀方式的生成顺序，比如 a + b 按照 a b + 的顺序来转换生成
- 精确模拟 vm 的运行方式，包括栈运算，Gbl 表及其它

章节结束之后，读者可以多使用调试器分析示例代码，探索其中的奥妙。

* key concept

在仔细探索代码生成之前，先明确几个在生成过程中的重点。
  
** variable

从作用域来看，lua 中的变量有 3 类，分别为 =local upvalue global= ，
三者在底层的实现方式各不相同。

*** local
    :LOGBOOK:
    - Note taken on [2021-01-11 一 17:06] \\
      如何和运行时的栈关联起来？
    - Note taken on [2020-12-15 二 11:14] \\
    变量逆序查找，比如出现 local 覆盖的情况
    searchvar() lparser.c:207
    :END:

local 变量的活动范围（active），开始于在作用域中出现的那一刻，一直到作用域结束，
而作用域是有明显的栈特性的，新开辟作用域时入栈，离开作用域时出栈。

在一个作用域内，local 变量按照声明顺序入栈，离开作用域时全部出栈，变为 inactive 状态。

利用这个特性，lua 在编译时，在 fs 中用 actvar 和 nactvar 时刻记录着当前 active local 变量的状态。

比如如下示例代码，

#+begin_src lua
local a

do
   local b
   do
      local c
   end
end

do
   local d
   do
      local e
   end
end
#+end_src

在代码分析的不同时刻， =fs->actvar= 记录的栈状态是这样的，

#+CAPTION: active local scope & fs->actvar nactvar
#+begin_src dot :file generator-active-local-scope.png
digraph {
	rankdir = LR;
	
	code[shape=none, label=<
	      <table border="0" cellspacing="0">
	        <tr><td align="left" border="1" bgcolor="white">local a</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">do</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">    local b</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">    do</td></tr>
	        <tr><td port="fir" align="left" border="1" bgcolor="white">        local c</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">    end</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">end</td></tr>
	        <tr><td port="sec" align="left" border="1" bgcolor="white"> </td></tr>
	        <tr><td align="left" border="1" bgcolor="white">do</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">    local d</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">    do</td></tr>
	        <tr><td port="trd" align="left" border="1" bgcolor="white">        local e</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">    end</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">end</td></tr>
	      </table>
	     >];

	fir[shape=record, label="
	      |<n>| c | b | a
	      ", xlabel="fs->actvar"];

	sec[shape=record, label="
	      || |<n> | a
	      ", xlabel="fs->actvar"];

	trd[shape=record, label="
	      |<n>| e | d | a
	      ", xlabel="fs->actvar"];

	fir -> code:fir;
	sec -> code:sec;
	trd -> code:trd;

	node[shape=plain];

	n1[label="fs->nactvar = 3"];
	n2[label="fs->nactvar = 1"];
	n3[label="fs->nactvar = 3"];

	n1 -> fir:n;
	n2 -> sec:n;
	n3 -> trd:n;

	nodesep = 1;
}
#+end_src

#+RESULTS:
[[file:generator-active-local-scope.png]]

上面只是粗略描述了 active local 变量的栈状态，而实际在 parser 内部，是通过两个数组来存储的。

#+CAPTION: actvar & locvars
#+begin_src dot :file generator-actvar-locvars.png
digraph {
	rankdir = LR;
	ranksep = 1;

	actvar[shape=record, label="
	      |<n> | <n3> 4 | <n2> 3 | <n1> 0
	      ", xlabel="fs->actvar"];

	node[shape=plain];
	
	n[label="fs->nactvar = 3"];
	nn[label="fs->nlocvars = 5"];

	n -> actvar:n;
	locvars:n -> nn[dir="back"];
	
	locvars[shape=record, label="
               |<n>  | <n3> \"e\" | <n2> \"d\" | \"c\" | \"b\" | <n1> \"a\"
	      ", xlabel="f->locvars"];

	actvar:n1 -> locvars:n1;
	actvar:n2 -> locvars:n2;
	actvar:n3 -> locvars:n3;
}
#+end_src

#+RESULTS:
[[file:generator-actvar-locvars.png]]

数组 =fs->actvar= 的元素是 =unsigned short= 类型，只用来记录变量的索引。
索引数组 =f->locvars= 中的元素，其中元素类型为 =struct LocVar *= 。

#+caption: lobject.h
#+INCLUDE: ../lua-5.1.5/src/lobject.h src c -n 262 :lines "262-267"

LocVar 主要记录变量的名字， =startpc endpc= 在字节码层面记录其活动范围。

宏 getlocvar 精确描述了图示过程。

#+caption: lparser.c
#+INCLUDE: ../lua-5.1.5/src/lparser.c src c -n 32 :lines "32-33"

*** upvalue
    :LOGBOOK:
    - Note taken on [2021-01-12 二 09:41] \\
      在分析时，如何使用 f fs 中的数组？
    :END:

upvalue 在本文翻译为上值，它即非 local，又不是 global。
直观从代码上看，即引用作用域之外的变量。

lua 将 function 作为基础类型之一，可以作为普通变量，参数，返回值，赋值，而四处流转。
又因为 local 变量的作用域限定于词法，这便是 upvalue 机制发挥作用的地方。

如下示例代码，

#+begin_src lua :results output :exports both
local function outer()
   local a = 0

   local function inner()
      a = a + 1
      print(a)
   end

   inner()
   
   return inner
end

local f = outer()

f()
f()
#+end_src

#+RESULTS:
: 1
: 2
: 3

内部第 1 次调用 inner() 时，输出 1 。
当调用 outer()，将 inner 赋值与 f，调用两次 f() 得到 2 3 。

第 1 次调用 inner() 时，依然在 a 的作用域内，输出 1 是符合直觉的。

问题在于调用 f() 时，因为 a 只作用在 outer 的作用域，而 f 在 outer 作用域外部，
已经离开了 a 的作用域，这种情况下为何还可以访问 a ？

这便是闭包机制的由来，a 对于 inner 而言是 upvalue 类型。
这也是 lua 中为何 function 不是 function 而是 closure 的原因，function 及 upvalue 组成了 closure，
所有 func 在运行时都封装为 closure 来运行，其中重要的原因就在于单独分配 upvalue 空间并管理。

详细的说，第 1 次调用 inner() 时，local a 依然存活，称 upvalue a 为 open 状态。
当离开 outer() 作用域，upvalue a 为 close 状态。

*** global
    :LOGBOOK:
    - Note taken on [2021-01-12 二 10:11] \\
      在运行时，global 是单独于基层的 closure 存在的，是运行状态的一部分
      Gbl 表
    - Note taken on [2021-01-12 二 10:01] \\
      global at runtime？
    :END:

如果依然说，global 变量是除 local 变量和 upvalue 变量的变量，读者肯定不信服。

之所以存在 upvalue 和 global，隐含的一点是，在 lua 中外层变量对于内层是可见的，
既然是可见的，对于外层变量引用自然有一个查找的过程，变量类型正是在查找的过程中确定的。

- 在当前作用域中可以找到的，为 local 类型
- 在当前作用域之外的作用域可以找到的，为 upvalue 类型
- 所有作用域都无法找到的，为 global 类型

按照这个逻辑，顶层的 chunk 是没有 upvalue 的，在当前作用域中查找不到的变量，
只能是 global 类型。

setfenv 影响的就是函数的 global 环境，
设定不同的 global 表，可以影响内部对 global 的引用，
实现不同的运行效果，类似于封装成一个小沙盒，

比如如下代码，变量 a 对 outer inner 都是全局变量，所以全部修改都影响到 global a 的值。

#+begin_src lua :results output :exports both
local function outer()
  a = 10

  local function inner()
    a = a + 1
    return a
  end

  return inner
end

local f = outer()

print(f(), a)
print(f(), a)
print(f(), a)
#+end_src

#+RESULTS:
: 11	11
: 12	12
: 13	13

** register
   :LOGBOOK:
   - Note taken on [2020-12-07 一 14:01] \\
   如何调度寄存器？
   :END:

寄存器的主要作用是，存取 local 变量和存取中间结果。

寄存器在编译时是一个抽象的概念，没有具体的分配空间，编译器只知晓存在这块区域，
并且按照自己的需要来使用和调试。

而在实际运行时，寄存器存储在 vm 的栈中。

** TODO how freereg & freeexp works

#+CAPTION: page 19 & 20

freereg 的作用

在栈的特性上，更深入的理解

何时分配，何时回收

根据抽象栈演算的顺序来

和 nactvar 的关系


* statement

本节开始从实例具体分析代码生成的过程，和实例一起来探求其中的生成模式。

因为语法元素的递归性，其中的组合是无限的，所以本节只挑选讲解部分重要的“原子性”的部分，
至于各种组合的变数读者可自由探索。

** tool

在开始以实例为基础的探索之前，先详细介绍相应工具的使用。

以交互式启动 chunkspy，用于临时检验一些想法。

#+begin_example
$ make spy
#+end_example

分析特定 lua 文件，输出相应的编译结果。

#+begin_example
$ make -s inspect source=lua_file_path
#+end_example

比如分析如下代码，

#+begin_src lua
local a = 1
#+end_src

会输出如下结果，

#+begin_example -n 1
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  "a"  ; 0
.const  1  ; 0
[1] loadk      0   0        ; 1
[2] return     0   1      
; end of function
#+end_example

逐行来看，

line 1

level 1 指的是第一层级，即 chunk；
function [0] 表明是当前层级的第 1 个函数（以 0 开始索引）

line 2

函数有 0 个 upvalue，0 个参数，按 =0b010= 模式接收可变参数，需要分配栈容量 2。

line 3

意义和 line 2 相同，line 2 是 line 3 的注释

line 4 5

.local 列出所有局部变量的名称及索引，即 f->locvars 的内容
.const 列出 k 表的内容及索引

line 6 7

详细打印 f->code 指令，最终一行总是默认生成一条 return 指令

line 8

注释，表明 function 结束

读者结合 opcode 章节对各个指令功能的理解，不难理解 lua 代码和字节码的同义关系。

** local

先来观察 local 语句。

语法描述如下，

#+begin_src bnf
stat      ::= localstat
localstat ::= LOCAL NAME {`,' NAME} [`=' explist]
localstat ::= LOCAL FUNCTION NAME body
#+end_src

localstat 可用于定义局部变量和局部函数。

函数部分到后面小节再讨论，对于局部变量，根据是否赋值可分为两种情况。

*** no assignment

如下简单的代码示例，定义局部变量，无赋值，

#+begin_src lua
local a, b, c
#+end_src

分析得到如下结果，

#+begin_example
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 3 stacks
.function  0 0 2 3
.local  "a"  ; 0
.local  "b"  ; 1
.local  "c"  ; 2
[1] return     0   1      
; end of function
#+end_example

示例代码只是单纯进行了局部变量的声明，最终没有生成任何字节码。

分析的过程，就是递归向下的函数过程， =chunk -> stat -> localstat= 。

#+caption: lparser.c
#+begin_src C -n 1179 -r
static void localstat (LexState *ls) {
  /* stat -> LOCAL NAME {`,' NAME} [`=' explist1] */
  int nvars = 0;
  int nexps;
  expdesc e;
  do {
    new_localvar(ls, str_checkname(ls), nvars++);   (ref:new_localvar)
  } while (testnext(ls, ','));
  if (testnext(ls, '='))
    nexps = explist1(ls, &e);
  else {
    e.k = VVOID;
    nexps = 0;
  }
  adjust_assign(ls, nvars, nexps, &e);
  adjustlocalvars(ls, nvars);
}
#+end_src

关键在于 [[(new_localvar)][new_localvar]] 函数，在循环中读入 a b c，并进行变量分析。

#+caption: lparser.c
#+begin_src C -n 160 -r
static void new_localvar (LexState *ls, TString *name, int n) {
  FuncState *fs = ls->fs;
  luaY_checklimit(fs, fs->nactvar+n+1, LUAI_MAXVARS, "local variables");
  fs->actvar[fs->nactvar+n] = cast(unsigned short, registerlocalvar(ls, name));
}
#+end_src

#+caption: lparser.c
#+begin_src C -n 143 -r
static int registerlocalvar (LexState *ls, TString *varname) {
  FuncState *fs = ls->fs;
  Proto *f = fs->f;
  int oldsize = f->sizelocvars;
  luaM_growvector(ls->L, f->locvars, fs->nlocvars, f->sizelocvars,
                  LocVar, SHRT_MAX, "too many local variables");
  while (oldsize < f->sizelocvars) f->locvars[oldsize++].varname = NULL;
  f->locvars[fs->nlocvars].varname = varname;
  luaC_objbarrier(ls->L, f, varname);
  return fs->nlocvars++;
}
#+end_src

其中根据变量出现的顺序，依次使用 registerlocalvar 得到变量索引，再记录到 =fs->actvar= 中。

这就是前面讨论过的，局部变量的存储方式，使用 =fs->actvar= 记录索引， =f->locvars= 记录变量名称。

#+CAPTION: local no assign
#+begin_src dot :file generator-local-no-assign.png
digraph {
	rankdir = LR;
	ranksep = 1;

	actvar[shape=record, label="
	      |<n> | <n3> 2 | <n2> 1 | <n1> 0
	      ", xlabel="fs->actvar"];

	node[shape=plain];
	
	n[label="fs->nactvar = 3"];
	nn[label="fs->nlocvars = 3"];

	n -> actvar:n;
	locvars:n -> nn[dir="back"];
	
	locvars[shape=record, label="
               |<n>  | <n3> \"c\" | <n2> \"b\" | <n1> \"a\"
	      ", xlabel="f->locvars"];

	actvar:n1 -> locvars:n1;
	actvar:n2 -> locvars:n2;
	actvar:n3 -> locvars:n3;
}
#+end_src

#+RESULTS:
[[file:generator-local-no-assign.png]]

[[(new_localvar)][new_locvar]] 完成的就是这个过程。

这也对应了 chunkspy 分析结果中的 .local 部分。

*** with assignment

再来看 local 变量赋值的情况。

分析示例代码，得到如下结果，
    
#+begin_src lua
local a, b, c, d, e = 10, "second", nil, true, false
#+end_src

#+begin_example
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 5 stacks
.function  0 0 2 5
.local  "a"  ; 0
.local  "b"  ; 1
.local  "c"  ; 2
.local  "d"  ; 3
.local  "e"  ; 4
.const  10  ; 0
.const  "second"  ; 1
[1] loadk      0   0        ; 10
[2] loadk      1   1        ; "second"
[3] loadnil    2   2      
[4] loadbool   3   1   0    ; true
[5] loadbool   4   0   0    ; false
[6] return     0   1      
; end of function
#+end_example

除了 .local 条目变多了，也增加了 .const 部分，意味着 k 表多出了 2 项记录。

依旧从 localstat 来分析，

#+caption: lparser.c
#+begin_src C -n 1179 -r
static void localstat (LexState *ls) {
  /* stat -> LOCAL NAME {`,' NAME} [`=' explist1] */
  int nvars = 0;
  int nexps;
  expdesc e;
  do {
    new_localvar(ls, str_checkname(ls), nvars++);
  } while (testnext(ls, ','));
  if (testnext(ls, '='))
    nexps = explist1(ls, &e);           (ref:localstat_explist)
  else {
    e.k = VVOID;
    nexps = 0;
  }
  adjust_assign(ls, nvars, nexps, &e);
  adjustlocalvars(ls, nvars);
}
#+end_src

在记录变量信息之后，遇到 ~=~ ，开始分析 ~=~ 后的 [[(localstat_explist)][表达式列表]] ，作为变量的赋值内容。

后面的表达式都是简单表达式，最终会调用 simpleexp 进行解析。

#+begin_src bnf
explist      ::= expr {`,' expr}
expr         ::= subexpr
subexpr      ::= (simpleexp | unop subexpr) {binop subexpr}

simpleexp    ::= NUMBER | STRING | NIL | TRUE | FALSE | DOTS |
                 constructor | FUNCTION body | primaryexp
#+end_src

下面有趣的地方来了，字节码和 k 表中的元素是何时生成的？
这就和代码生成的方式紧密相关了。

parser 模块中代码生成的强大在于，它是流式生成的。
意思即一边读入 token，分析状态，就直接生成代码！

从代码具体来看，

#+begin_src C -r -n 596
static int explist1 (LexState *ls, expdesc *v) {
  /* explist1 -> expr { `,' expr } */
  int n = 1;  /* at least one expression */
  expr(ls, v);                         (ref:fir_exp)
  while (testnext(ls, ',')) {
    luaK_exp2nextreg(ls->fs, v);       (ref:fir_gen)
    expr(ls, v);                       (ref:sec_exp)
    n++;
  }
  return n;
}
#+end_src

在[[(fir_exp)][第 1 次分析表达式]] 时，读入并分析了 10，并在 [[(sec_exp)][第 2 次分析表达式 "second"]] 之前，已经[[(fir_gen)][生成代码并更新了 k 表]]。

先来看 expr()，由于分析的是简单表达式，最终会调用 simpleexp 进行分析，

#+begin_src C -n 727 -r
static void simpleexp (LexState *ls, expdesc *v) {
  /* simpleexp -> NUMBER | STRING | NIL | true | false | ... |
                  constructor | FUNCTION body | primaryexp */
  switch (ls->t.token) {
    case TK_NUMBER: {
      init_exp(v, VKNUM, 0);
      v->u.nval = ls->t.seminfo.r;
      break;
    }
    case TK_STRING: {
      codestring(ls, v, ls->t.seminfo.ts);
      break;
    }
    case TK_NIL: {
      init_exp(v, VNIL, 0);
      break;
    }
    case TK_TRUE: {
      init_exp(v, VTRUE, 0);
      break;
    }
    case TK_FALSE: {
      init_exp(v, VFALSE, 0);
      break;
    }
    case TK_DOTS: {  /* vararg */
      FuncState *fs = ls->fs;
      check_condition(ls, fs->f->is_vararg,
                      "cannot use " LUA_QL("...") " outside a vararg function");
      fs->f->is_vararg &= ~VARARG_NEEDSARG;  /* don't need 'arg' */
      init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 1, 0));
      break;
    }
    case '{': {  /* constructor */
      constructor(ls, v);
      return;
    }
    case TK_FUNCTION: {
      luaX_next(ls);
      body(ls, v, 0, ls->linenumber);
      return;
    }
    default: {
      primaryexp(ls, v);
      return;
    }
  }
  luaX_next(ls);
}
#+end_src

第 1 次分析 10 时，token 类型是 =TK_NUMBER= ，直接填充 expdesc 即可，
然后调用 luaK_exp2nextreg 生成代码。

luaK_exp2nextreg 是一个综合过程，由更基础的几个函数组成。

深入分析之前，先来补充之前 FuncState 未描述的一个字段，freereg。

字节码被 vm 运行时，vm 维持一个栈，来存放寄存器和中间结果。
编译器只知晓这个栈的存在，但是在编译时，这个栈并没有真实存在，
只能凭借想象去操作它。

freereg 就是用来记录栈顶的变量。

当存储新的寄存器值时，freereg 就会自增，为寄存器开出空间；

#+caption: lcode.c
#+include: ../lua-5.1.5/src/lcode.c src c -n 209 :lines "209-213"

相应的，如果寄存器不再使用，freereg 会自减，回收相应的空间。

#+caption: lcode.c
#+include: ../lua-5.1.5/src/lcode.c src c -n 215 :lines "215-221"

从中可以看出，freereg 将栈分为两部分，在栈底为 local 变量保留空间（reg >= fs->nactvar），
上层用于计算中间结果。

#+caption: freereg and stack
#+begin_src dot :file generator-freereg-stack.png
digraph {
	rankdir = LR;
	
	fir[shape=record, label="
	    ||||<n> | a
	    ", xlabel="vm stack"];

	node[shape=plain];
	
	n1[label="fs->freereg = 1"];

	n1 -> fir:n;
}
#+end_src

#+RESULTS:
[[file:generator-freereg-stack.png]]


#+caption: lcode.c
#+include: ../lua-5.1.5/src/lcode.c src c -n 414 :lines "414-420"

在 luaK_exp2nextreg 中，先找出下一个可用的栈/寄存器空间，然后将表达式的值解析到寄存器中，
即生成字节码。

最终在 discharge2reg 函数生成相应指令 loadk。

这里出现了第二个重点，对 k 表的操作。

因为其类型为数字，所以调用的是 luaK_numberK。

#+caption: lcode.c
#+include: ../lua-5.1.5/src/lcode.c src c -n 229 :lines "229-278"

所有操作 k 表的方法，最终都使用 addk 操作，其作用也很简单，
在 k 表中搜索，如果存在，则直接返回相应索引，其中使用 table fs->h 做 k 表元素的反向索引，加快搜索过程；
若不存在，则自增，并返回相应的索引。

#+caption: number k
#+begin_src dot :file generator-numberk-10.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	rankdir = LR;
	
	fk[shape=record, label="
	      | | | | <n> |10
	      ", xlabel="f->k"];

	fsizek[label="f->sizek", shape=plain];
	
	fsnk[label="fs->nk", shape=plain];

	fsnk -> fk:n;
}
#+end_src

#+RESULTS:
[[file:generator-numberk-10.png]]

将数字 10 存储入 k 表之后，生成 loadk 指令，将 freereg 和 k 索引作为其操作数。

至此，parser 只读入了 token 10，便已经完成了操作 k 表，记录常数，并生成对应的指令，令人惊奇。

对于第 2 个表达式 "second"，在 simpleexp 时，提前调用 codestring 加入了 k 表，
将其作为 VK 类型来对待。

#+caption: lparser.c
#+include: ../lua-5.1.5/src/lparser.c src c -n 133 :lines "133-136"

#+begin_src dot :file generator-stringk-second.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	rankdir = LR;
	
	fk[shape=record, label="
	      | | | <n>|\"second\" | 10
	      ", xlabel="f->k"];

	fsizek[label="f->sizek", shape=plain];
	
	fsnk[label="fs->nk", shape=plain];

	fsnk -> fk:n;
}
#+end_src

#+RESULTS:
[[file:generator-stringk-second.png]]

同样的生成 loadk 指令。

回到 localstat()，前面对变量和表达式进行解析之后，记录了 ~=~ 两边的数量 nvars nexps，
=adjust_assign()= 进行左右数量的调整，多余的 var 空间置为 nil，多余的 exp 则省略。

最终调用 =adjustlocalvars()= 调整 fs->nactvar 的值。

**** TODO multret

TODO 有 multret 的再讨论

下面的情况是合法的，只不过前面的 multret 只返回一个值，而最后的可利用多个值

#+begin_src lua
local a, b, c = ..., ..., ...
#+end_src


** expdesc

从 localstat 的示例中，已经看到代码生成的逻辑是别具一格的。

结合递归下降，语法制导，后缀顺序，vm opcode 语义，得以以线性顺序生成字节码。

其中 expdesc 的作用是非常重要的，将一些属性附加到文法符号上，辅助代码生成过程。

#+caption: lparser.h
#+INCLUDE: ../lua-5.1.5/src/lparser.h src c :lines "15-46"

expdesc 用于记录 exp 表达式的相关信息。

和 token 类型类似，expdesc 内部有字段记录类型，其它字段记录附加信息。

所有类型用 enum expkind 表示，相应类型后的注释描述了对应其它字段需要记录的信息。

其中重点的函数是 discharge2reg 和 dischargevars，用于解析相应的 expdesc，生成代码并更新状态。

| expkind    | u                                               | discharge                                                            |
|------------+-------------------------------------------------+----------------------------------------------------------------------|
| VVOID      |                                                 |                                                                      |
| VNIL       |                                                 | 生成指令 loadnil，重置为 VNONRELOC                                   |
| VTRUE      |                                                 | 生成指令 loadbool，重置为 VNONRELOC                                  |
| VFALSE     |                                                 | 生成指令 loadbool，重置为 VNONRELOC                                  |
| VK         | info 记录 k 表索引                              | 生成指令 loadk，重置为 VNONRELOC                                     |
| VKNUM      | nval 记录数值                                   | 生成指令 loadk，重置为 VNONRELOC                                     |
| VLOCAL     | info 记录寄存器索引                             | 重置为 VNONRELOC                                                     |
| VUPVAL     | info 记录 upvalues 数组中的索引                 | 生成指令 GETUPVAL, 重置为 VRELOCABLE，info 记录指令索引              |
| VGLOBAL    | info 全局表的索引，aux 全局名称的 k 表索引      | 生成指令 GETGLOBAL, 重置为 VRELOCABLE，info 记录指令索引             |
| VINDEXED   | info table 所在寄存器的索引，aux 索引值的 RK 值 | 生成指令 GETTABLE, 重置为 VRELOCABLE，info 记录指令索引              |
| VJMP       | info 当前指令索引                               |                                                                      |
| VRELOCABLE | info 当前指令索引                               | 定位到指令位置，修改 A 参数为 reg                                    |
| VNONRELOC  | info 最终解析得到的寄存器位置                   | 如果当前寄存器位置与目标位置不同，则生成 move 指令；相同则什么都不做 |
| VCALL      | info 当前指令索引                               | 重置为 VNONRELOC，info 记录指令的 A 参数                             |
| VVARARG    | info 当前指令索引                               | 重置为 VRELOCABLE                                                    |

具体如此设计的原因及作用，还需要读者在不同情况下再尝试领会。

** assign

本节来探讨赋值语句

#+begin_src bnf
stat         ::= exprstat
exprstat     ::= assignstat

assignstat   ::= (prefixexp | primaryexp (`.' NAME | `[' expr `]')) assignment
assignment   ::= `,' assignstat | `=' explist

primaryexp   ::= prefixexp {`.' NAME | `[' expr `]' | `:' NAME funcargs | funcargs}
prefixexp    ::= NAME | `(' expr `)'
#+end_src

赋值语句根据变量的类型不同，分为 global upvalue local indexed 几种情况，
对应 expdesc 中的 VGLOBAL VUPVAL VLOCAL VINDEXED。

*** global

先来看 global 的赋值情况。

分析如下代码，

#+begin_src lua
a, b, c = 10, 20, 30
#+end_src

#+begin_example
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 3 stacks
.function  0 0 2 3
.const  "a"  ; 0
.const  "b"  ; 1
.const  "c"  ; 2
.const  10  ; 3
.const  20  ; 4
.const  30  ; 5
[1] loadk      0   3        ; 10
[2] loadk      1   4        ; 20
[3] loadk      2   5        ; 30
[4] setglobal  2   2        ; c
[5] setglobal  1   1        ; b
[6] setglobal  0   0        ; a
[7] return     0   1      
; end of function
#+end_example

从 chunk 递归向下，最终到达 assignment 函数。

从 ebnf 描述中可以看出，assignment 是一个递归的过程。

#+caption: lparser.c
#+include: ../lua-5.1.5/src/lparser.c src c -n 931 :lines "931-963"

在遇到 ~=~ 之前，执行 if 语句块，递归调用 primaryexp 分析变量；
遇到 ~=~ 之后，执行 else 语句块，分析表达式。
在递归的终点，将表达式得到的值赋值给变量。

因为示例代码中变量都很简单，primaryexp 主要调用 prefixexp 进行分析。

#+caption: lparser.c
#+include: ../lua-5.1.5/src/lparser.c src c -n 667 :lines "667-688"

对应其中的 =TK_NAME= 类型，调用 singlevar 确定变量的类型，内容调用 singlevaraux 来实现。

#+caption: lparser.c
#+include: ../lua-5.1.5/src/lparser.c src c -n 224 :lines "224-254"

singlevaraux 是非常关键的过程，回忆之前在分析过程中，关于嵌套的 function 定义和 fs->prev 的链条，
singlevaraux 就顺着 fs->prev 不断向上层作用域寻找变量。

如果 ~fs == NULL~ ，说明已经到顶层，变量只能为 global 类型；
如果在当前作用域可找到，说明是 local 变量；其它为 upval 变量。

示例中 a b c 都为全局变量，所以 singlevaraux 返回 VGLOBAL，
将相应 expdesc 类型赋值为 VGLOBAL，且 info 存储了变量名对应的 k 表索引。

表达式分析阶段，将 10 20 30 加入 k 表，同时载入寄存器。

最终赋值阶段，在每个递归层次，用 luaK_storevar 来存储。

#+caption: lcode.c
#+include: ../lua-5.1.5/src/lcode.c src c -n 472 :lines "472-501"

对应 case VGLOBAL，生成 setglobal 指令。

*** upvalue

分析如下代码，

#+begin_src lua
local a

function f()
  a = 10
end
#+end_src

#+begin_example
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  "a"  ; 0
.const  "f"  ; 0

  ; function [0] definition (level 2)
  ; 1 upvalues, 0 params, 0 is_vararg, 2 stacks
  .function  1 0 0 2
  .upvalue  "a"  ; 0
  .const  10  ; 0
  [1] loadk      0   0        ; 10
  [2] setupval   0   0        ; a
  [3] return     0   1      
  ; end of function

[1] closure    1   0        ; 1 upvalues
[2] move       0   0      
[3] setglobal  1   0        ; f
[4] return     0   1      
; end of function
#+end_example

对于外层函数，a 是 local 变量，而对应内层函数，a 为 upval 变量。

基本过程同 global，不过 singlevaraux 搜索得到 VUPVAL，生成 setupval 指令。

*** local

#+begin_src lua -n 1
local a = 1

local b
b = 1
#+end_src

line 1 为 local 赋值语句，而 line 4 为普通赋值语句，不过恰巧赋值给 local 变量。

分析如下示例，

#+begin_src lua
local a, b

b = 10
#+end_src

#+begin_example
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  "a"  ; 0
.local  "b"  ; 1
.const  10  ; 0
[1] loadk      1   0        ; 10
[2] return     0   1      
; end of function
#+end_example

分析过程与上相同，singlevaraux 确定为 VLOCAL，针对寄存器位置，直接生成 loadk。

*** indexed

#+begin_src lua
local t = {}

t['a'] = 10
#+end_src

#+begin_example
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  "t"  ; 0
.const  "a"  ; 0
.const  10  ; 1
[1] newtable   0   0   0    ; array=0, hash=0
[2] settable   0   256 257  ; "a" 10
[3] return     0   1      
; end of function
#+end_example

VINDEXED 的分析分为两部分，singlevar 分析 t 为 local 变量，
同时在 primaryexp 中继续分析 'a' 为字符串值，存储在 k 表直接引用。
最终使用 =luaK_indexed= 确定 expdesc 的类型及相关数据。

#+caption: lcode.c
#+include: ../lua-5.1.5/src/lcode.c src c -n 621 :lines "621-625"

在最终赋值时，生成 gettable 指令。

之所以使用 RK(C) 作为索引，是因为索引值未必是常数，也可能是一个表，一个函数等其它值，
这里由 table 的特性决定的，这种通用的值只能由寄存器存储。

** function

这个小节关注 function 分析的过程。

语法描述中，涉及函数定义的地方，主要有 3 处，

#+begin_src bnf
funcstat     ::= FUNCTION funcname body
funcname     ::= NAME {`.' NAME} [`:' NAME]
body         ::= `(' parlist `)' chunk END
parlist      ::= [ DOTS | NAME {`,' NAME} [`,' DOTS] ]

localstat    ::= LOCAL FUNCTION NAME body

simpleexp    ::= NUMBER | STRING | NIL | TRUE | FALSE | DOTS |
                 constructor | FUNCTION body | primaryexp
#+end_src

第 1 种对应全局函数定义，第 2 种对应 local 函数定义，第 3 种对应函数函数定义。

#+begin_src lua
function f()
end

local function f()
end

local f = function ()
end
#+end_src

但无论哪一种形式，函数分析的核心函数在于 body，通过 chunk 生成 Proto，
最终赋值予 global/local 变量。

*** param

先来看参数部分。

#+begin_src lua
local function f(a, b, ...)
end
#+end_src

#+begin_example
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  "f"  ; 0

  ; function [0] definition (level 2)
  ; 0 upvalues, 2 params, 7 is_vararg, 3 stacks
  .function  0 2 7 3
  .local  "a"  ; 0
  .local  "b"  ; 1
  .local  "arg"  ; 2
  [1] return     0   1      
  ; end of function

[1] closure    0   0        ; 0 upvalues
[2] return     0   1      
; end of function
#+end_example

参数部分由 parlist 处理，分为固定参数和可变参数。

#+caption: lparser.c
#+include: ../lua-5.1.5/src/lparser.c src c -n 543 :lines "543-574"

固定参数的处理方法，和 local 变量相同，不再赘述。

对于可变参数，即参数列表的最后定义中出现 =...= ，表明函数接收可变数量的参数，
全部收纳入 =...= 中。

在 lua5.0 中，可以在参数定义时使用 =...= ， 但是没有 =...= 表达式，
意味着在函数体中使用传入的参数时，通过变量 arg 来引用。

arg 是一个 table，以数组形式存储了所有可变参数，同时 arg.n 存储了数组的长度。

下面是 lua5.1 的同义描述，

#+begin_src lua
local function f(a, b, ...)
  local arg = {...}
  arg.n = select("#", ...)
end
#+end_src

lua5.1 默认提供了对变量 arg 的兼容性，所以才会出现注册 arg 变量的情况。

=fs->is_vararg= 是用来记录可变参数状态的变量，含义由 3 个二进制位综合表示。

#+caption: lobject.h
#+include: ../lua-5.1.5/src/lobject.h src c -n 256 :lines "256-260"

| macro              | number | desc                                                |
|--------------------+--------+-----------------------------------------------------|
| =VARARG_HASARG=    | 0b001  | 方便计算参数数量，直接使用 & 运算就可以             |
| =VARARG_ISVARARG=  | 0b010  | 是否存在可变参数                                    |
| =VARARG_NEEDSARG=  | 0b100  | 是否需要 arg，当函数内部出现 =...= 表达式时，置为 0 |

内部有如下几种模式

| cond            | =is_vararg= |
|-----------------+-------------|
| 无可变参数      | 0b000       |
| chunk           | 0b010       |
| 不需要 arg 变量 | 0b011       |
| 默认的兼容情况  | 0b111       |

*** upval

函数体就是 chunk 过程，作为分析的入口，在内部被递归调用，这里不再多做解释。

这里想重点说明的是，函数对 upvalue 的引用过程。

#+begin_src lua -n 1
local a

local function f()
   local b

   local function g()
      b = 20
      a = 10
   end
end
#+end_src

#+begin_example -n 1
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  "a"  ; 0
.local  "f"  ; 1

  ; function [0] definition (level 2)
  ; 1 upvalues, 0 params, 0 is_vararg, 2 stacks
  .function  1 0 0 2
  .local  "b"  ; 0
  .local  "g"  ; 1
  .upvalue  "a"  ; 0

    ; function [0] definition (level 3)
    ; 2 upvalues, 0 params, 0 is_vararg, 2 stacks
    .function  2 0 0 2
    .upvalue  "b"  ; 0
    .upvalue  "a"  ; 1
    .const  20  ; 0
    .const  10  ; 1
    [1] loadk      0   0        ; 20
    [2] setupval   0   0        ; b
    [3] loadk      0   1        ; 10
    [4] setupval   0   1        ; a
    [5] return     0   1      
    ; end of function

  [1] closure    1   0        ; 2 upvalues
  [2] move       0   0      
  [3] getupval   0   0        ; a
  [4] return     0   1      
  ; end of function

[1] closure    1   0        ; 1 upvalues
[2] move       0   0      
[3] return     0   1      
; end of function
#+end_example

示例代码存在 3 层函数嵌套，chunk f g。

g 中引用的变量 a b 对于 g 而言都是 upvalue 类型。

当分析到 line 7 时，fs 的链接关系如下，

#+caption: 3 fs level
#+begin_src dot :file generator-f-g-upval.png
digraph {
	node[shape=box];
	rankdir=LR;

	ls;
	c[label="fs (chunk)"];
	cp[label="f"];

	f[label="fs (f)"];
	fp[label="f"];

	g[label="fs (g)"];
	gp[label="f"];

	ls -> g;
	c -> cp;

	f -> fp;
	f -> c[label="prev"];

	g -> gp;
	g -> f[label="prev"];

	{rank=same; c; f; g;}
}
#+end_src

#+RESULTS:
[[file:generator-f-g-upval.png]]

首先分析变量 b，

#+caption: lparser.c
#+include: ../lua-5.1.5/src/lparser.c src c -n 183 :lines "224-246"

在 fs g() 中搜索无果，搜索上层 fs f()，在 fs f() 的 local 变量中找到 b，
调用 indexupvalue，然后标识为 VUPVAL 类型返回。

#+caption: lparser.c
#+include: ../lua-5.1.5/src/lparser.c src c -n 183 :lines "183-205"

在 indexupvalue 中，先搜索是否已经存在 upvalue b，若没有则存储到 upvalues 数组中。

f->upvalues 记录变量名，fs->upvalues 记录 upval 信息。

#+begin_src dot :file generator-f-g-upvalues-0.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fupval[shape=record, label="
	      \"b\"|<n> | | |  | | |
	      ", xlabel="f->upvalues"];

	fsizeupval[label="f->sizeupvalues", shape=plain];
	
	fnups[label="f->nups = 1", shape=plain];

	fnups -> fupval:n;
}
#+end_src

#+RESULTS:
[[file:generator-f-g-upvalues-0.png]]

#+begin_src dot :file generator-f-g-upvalues-1.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fsupval[shape=record, label="
	      {VLOCAL|0}|<n> | | |  | | |
	      ", xlabel="fs->upvalues"];

	fssizeupval[label="LUAI_MAXUPVALUES", shape=plain];
	
	fnups[label="f->nups = 1", shape=plain];

	fnups -> fsupval:n;
}
#+end_src

#+RESULTS:
[[file:generator-f-g-upvalues-1.png]]

upvalue 其实可分为两种情况，一种是 VLOCAL，一种是 VUPVAL。

b 属于 VLOCAL 的情况，因为 b 和 g() 在一个层级，g() 内部只需要向上查找一个层级便可定位 b。

#+caption: lparser.h
#+include: ../lua-5.1.5/src/lparser.h src c -n 48 :lines "48-52"

fs->upvalues 在记录 VLOCAL 的同时，也记录其对应的寄存器位置。


再来搜索变量 a，不存在于 g()，也不存在于 f() 中，在 chunk() 中找到。

此时 upvalues 数组的情况如下。

#+begin_src dot :file generator-f-g-upvalues-2.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fupval[shape=record, label="
	      \"b\"|\"a\"|<n> | | |  | | |
	      ", xlabel="f->upvalues"];

	fsizeupval[label="f->sizeupvalues", shape=plain];
	
	fnups[label="f->nups = 2", shape=plain];

	fnups -> fupval:n;
}
#+end_src

#+RESULTS:
[[file:generator-f-g-upvalues-2.png]]


#+begin_src dot :file generator-f-g-upvalues-3.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fsupval[shape=record, label="
	      {VLOCAL|0}|{VUPVAL|0}|<n> | | |  | | |
	      ", xlabel="fs->upvalues"];

	fssizeupval[label="LUAI_MAXUPVALUES", shape=plain];
	
	fnups[label="f->nups = 2", shape=plain];

	fnups -> fsupval:n;
}
#+end_src

#+RESULTS:
[[file:generator-f-g-upvalues-3.png]]

a 对于 g() 属于 VUPVAL 的情况，对于 f() 属于 VLOCAL 的情况。

值得注意，在搜索变量 a 的时候，indexupvalue 调用了两次，一次从 fs g() 出发，一次从 fs f() 出发。
这也解释了，为什么 f() 没有直接使用 a，但是其 upvalues 表中依然记录了 a。

当函数 g() 解析结束之后，将 Proto 结果链接到上层。

#+begin_src dot :file generator-f-g-upvalues-4.png
digraph {
	node[shape=box];
	rankdir=LR;

	ls;
	c[label="fs (chunk)"];
	cp[label="f"];

	f[label="fs (f)"];
	fp[label="f"];

	g[label="fs (g)", style=dashed];
	gp[label="f"];

	ls -> f;
	c -> cp;

	f -> fp;
	f -> c[label="prev"];

	g -> gp;
	g -> f[label="prev"];

	{rank=same; c; f; g;}

	fp -> gp[label="p[0]"];
}
#+end_src

#+RESULTS:
[[file:generator-f-g-upvalues-4.png]]

得到 Proto 之后，生成 closure 指令将其赋值予变量 g。

同时在 closure 指令之后，生成了额外的两条指令，按顺序表明当前 closure 的 upvalue 的类型和索引信息。

#+begin_example
  [2] move       0   0      
  [3] getupval   0   0        ; a
#+end_example

move 指令此时不表示普通的 move 含义，参数 A 无用，参数 B 指代 VLOCAL 的栈索引。
表示新建的 closure 第 1 个 upvalue 是 VLOCAL 类型，
指向当前作用域索引为 0 的寄存器。

getupval 指令同样，参数 A 无用，参数 B 表示上层 closure 中 upvalues 表中的序号。
表示第 2 个 upvalue 是 VUPVAL 类型，指向上个作用域索引为 0 的 upvalue。 

使用这种方式，将 upvalue 的类型和索引存储到 code 中，
所以 f->upvalues 只需要单纯记录变量名称就足够了。

vm 在执行的时候，自然会理会其中的含义并做出相应处理。

** do

- block vs chunk
  - 整体文件按照 chunk 来解析，chunk 是入口
  - block ::= chunk，但具体使用方式要根据语句的类型来分析
    并非所有引用 chunk 的地方都会像 function 结构使用 chunk 会影响 fs 结构，
    更多依赖 chunk 递归处理语句的便利
- 分类
  - loop 中
  - 非 loop 中

blockCnt
- previous
- nactvar，进入 block 前 nactvar 的个数
- isbreakable，是否用在循环中，从 bnf 中可看到
- breaklist，chain of jump out of the loop，在 while 时深入
- upval，bool，当前作用域中是否有 local var 作为 upval，在 for 时深入

明显的作用域分隔作用

enterblock
leaveblock

在进入时，nactvar 记录 active local var 的数量，
block 内新的 local var 会在离开时，全部释放
符合作用域的原则
内部使用，销毁，不污染外部

#+CAPTION: 24 do block

作用域记录在 fs 中，最终要体现到 f 中
最终在 do 之外，使用 b，会顺着 a 0 的顺序向后，b 1
说明前面的所有变量已回收

虽然有多个 block 相隔，但是在最内层进行变量查找的时候，上层的所有 act local var 都
属于同一个 fs，查找 a 的时候，a 的类型为 local，直接进行了修改
a 并不是 upval，可见 upval 只针对 function 而言

非 loop 只有 nactvar 起作用

loop 情况，到 while for 具体分析。

** if
   :LOGBOOK:
   - Note taken on [2021-01-08 五 13:51] \\
     因为分析从左向右，从前至后的，所以对于一些结构需要特别的方法来处理
     比如 if 分支的处理，回填 jmp 地址
   :END:

顺序解析的难题之一
分支

- jump chain resolve

#+CAPTION: 25 if else code pattern


concat

patch

patch to here, concat

patch to list, discharge right now to target

they are the same

dischargejpc




luaK_jump 时，使用 jpc 重置的技巧，防止在生成 jump 时，触发 dischargejpc

*** if

dischargejpc
负责从当前 pc 解析 jump chain

隐藏在 luaK_code 中


问题添加 return 0 1 的原因

#+CAPTION: 26 if chain

*** if else

#+CAPTION: 27 if else chain

*** if elseif

#+CAPTION: 28 if elseif chain

*** if elseif else

#+CAPTION: 29 if elseif else chain

** while

#+CAPTION: 30 while pattern

block

breakable  1
这样其中才可以生成 break 语句

breaklist
用于记录 break 语句，chain 到 block 外的第一条语句

enterblock 自然生成 0 block

相当于有双层 block

*** break

#+CAPTION: 30 break in while
     
** repeat

repeat    

#+CAPTION: 31 repeat

break 同 while 时的表现相同


不过对于 upval，有自己的处理方式


因为 while 在 cond 中不能定义新的 local var
而 repeat 的 block 中可能先定义 local var
再被其中的 func 引用，而 i 在不断变化，就需要及时 close




#+begin_src lua :results output
local t = {}

local c = 0

repeat
   c = c + 1

   local i = c

   t[i] = function ()
      return i
   end
until i > 10

for i, f in ipairs(t) do
   print(f())
end
#+end_src

#+RESULTS:
#+begin_example
1
2
3
4
5
6
7
8
9
10
11
#+end_example

进行 upval 判断的原因

每个 func 记录的都是 i，但是每次 loop 结束都进行了 close，


#+CAPTION: 31 repeat upval


** for

for loop 特别开发了底层指令来处理，而 repeat 和 while 则没有相应的指令。
依然是通过 jmp 来实现的。

分为两种

数字迭代 fornum

#+begin_src lua
for i = 1, 10, 2 do
  print(i)
end
#+end_src

通用迭代 forlist

#+begin_src lua
for k, v in pairs(t) do
  print(k, v)
end
#+end_src

*** fornum

隐式生成的变量，用 ( 来标识，是不会与正常 lua 代码中分析得到的 NAME 冲突的
因为 lex 规则的限定

#+begin_example
.local  "(for generator)"  ; 0
.local  "(for state)"  ; 1
.local  "(for control)"  ; 2
#+end_example

#+CAPTION: 32 for and upval

*** forlist

#+begin_src lua :results output
local g, s = pairs({1,2,3})

for k, v in g, s, nil do
  print(k, v)
end
#+end_src

#+RESULTS:
: 1	1
: 2	2
: 3	3

#+CAPTION: 33 for and upval

upvalue 同 fornum

** function call

function call

func 在栈的底部，参数向上累加

调用结果，返回值，从栈的 func 处开始向上覆盖

#+CAPTION: 34 func call

funcargs()
lparser.c:609

并不复杂

*** self

#+begin_src lua :results output
local o = {}

function o.f(self)
  print(self)
end

function o:f()
  print(self)
end

o.f(o)

o:f()
#+end_src

#+RESULTS:
: table: 0x55bb5b89d270
: table: 0x55bb5b89d270

self 指令，只是一种优化方式



luaK_self()

lcode.c:503

结合 op self 的语义，并不复杂

#+CAPTION: 35 self

self 只是为 call 做准备，将对象提前放到相应位置


** ret

return 在 chunk 中发挥作用
从当前 closure 中返回

return 必须是 chunk 的最后一个语句

按语句含义返回值，至于有多少值被利用，则根据 opcode 生成过程中决定的

opcode 容易理解

retstat()
lparser.c:1238

*** tailcall

#+begin_src lua
-- tail call
return f()
-- not tail call
return a, b, f()
#+end_src

ret 中只有单独的 function call

进行栈优化

lparser.c:1249

tailcall 本身已经有了 return 的语义


* practice

理想的 vm
独立，lua 实现对 vm 做了协同的妥协

** arithmetic

- 优先级

lua 在进行解析时，没有进行关系运算的实时解析，但是对 constant 算法运算有编译时执行

如 `local a = 5 > 2` 和 `local a = 1 + 2` 的区别

前者需要生成 jmp 指令，但是后者，直接是 loadk 0 0 ; 3

** logic

- and or

** constructor

- setlist always consistent, diff with settable

