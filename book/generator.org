#+SETUPFILE: setup.org

#+TITLE: generator
#+DATE: <2021-01-08 五 11:34>

上一章尝试单独解析语法分析过程，本章关注具体的代码生成过程。

#+begin_src dot :file generator-feature.png
digraph {
	rankdir = TB;
	node[shape=box];

	lua[label="Lua Code"];
	tk[label="Token"];

	subgraph cluster_0 {
	ast[label="AST", style="dotted"];
	op[label="Opcode"];
	style=filled;
	color=lightblue;
}
	vm[label="VM"];

	lua -> tk[label="lex"];
	tk -> ast[label="parse"];
	ast -> op[label="generate"];
	op -> vm[label="executed"];
}
#+end_src

#+RESULTS:
[[file:generator-feature.png]]

* function vs proto vs closure

在具体深入代码生成之前，先来区分三个概念，function proto 和 closure。

function，是 lua 语言中定义的概念，是 8 种基础类型之一，表示函数，
具体在 lua 代码中用关键字 =function= 来定义。

如同 string 概念在底层由 TString 结构来实现一样，
function 在底层用 Proto 结构来实现，是 function 整体编译之后得到的同语义结构。

编译得到的 Proto 是静态的，在实际运行的时候，需要封装为 Closure 结构，交由 vm 来执行。
Closure 为 upvalue 分配了空间，并统一表示了 c function 和 lua function。

这也是为什么在 object 章节，提到基础类型对应的实现结构时，用 Closure 而不是用 Proto 来表示 function。

所以在编译时期，我们关注 Proto，而在运行时期，才关注 Closure。

** chunk

lua 内部使用了一种巧妙的实现，在编译时，将整个文件当做一个匿名 function 来对待。
相当于文件头加了 =function ()= ，文件尾加了 =end= 。

#+caption: lparser.c
#+INCLUDE: ../lua-5.1.5/src/lparser.c src c -n 383 :lines "383-399"

可以看到， =luaY_parser= 读取文件，最终生成并返回 =Proto *= 。

因为整体分析的入口是 chunk，lua 又将文件当做匿名函数来对待，
这也是很多 lua 书籍中提到 chunk 的原因，表示文件编译得到的结果。

** embeded

如果按照 function 和 Proto 一一对应的关系，会出现函数层级的问题。

比如下面的示例代码，

#+begin_src lua
function a()
   function b()
   end
end

function c()
   function d()
   end

   function e()
   end
end
#+end_src

如果将 lua 代码文件看作 Proto chunk，代码中定义的 a b c d 同样是 function 且编译为 Proto。
但是 function a b c d e 是 lua 代码的一部分，所以其 Proto 也应该被包含在 Proto chunk 中。

lua 内部根据 function 定义的位置，来记录这种包含关系。

#+begin_src dot :file generator-function-level.png
digraph {
	node[shape=box];
	
	subgraph cluster_0 {
		label="chunk()";

		subgraph cluster_2 {
			label="c()";

			e[label="e()"];
			d[label="d()"];
		}

		subgraph cluster_1 {
			label="a()";

			b[label="b()"];
		}
	}
}
#+end_src

#+RESULTS:
[[file:generator-function-level.png]]

function a c 直接定义在代码文件（顶层匿名函数）中，
b d e 则直接定义在 a 和 c 中。

#+begin_src dot :file generator-proto-level.png
digraph {
	node[shape=box];

	rankdir = LR;

	ac[shape=record, label=" <a> a | <c> c "];
	de[shape=record, label=" <d> d | <e> e "];

	chunk -> ac:a[label="p"];
	ac:a -> b[label="p"];
	ac:c -> de:d[label="p"];
}
#+end_src

#+RESULTS:
[[file:generator-proto-level.png]]

Proto 结构中使用 struct Proto * 数组 p（Line 235）来记录其直接包含的 Proto。

#+caption: lobject.h
#+INCLUDE: ../lua-5.1.5/src/lobject.h src C -n 228 :lines "228-254"

** FuncState

在 lua 的语法分析中，function 解析是一个重要的部分。

EBNF 和 regex 的区别在于，EBNF 可以描述一种递归过程，而 regex 则不能。

chunk 作为解析 function 的入口，得到 Proto，这个过程在遇到 function 定义时，不断的递归调用，生成 Proto，
并按照层级链接起来。

在了解这个过程之前，要先介绍另一个重要的结构 FuncState 。

#+caption: lparser.h
#+INCLUDE: ../lua-5.1.5/src/lparser.h src c -n 57 :lines "57-76"

从名称可以看出，和 LexState 相似，也用于记录中间状态。
FuncState 用于记录 function 分析过程中的状态，和 function 定义一一对应，
每遇到一个 function 定义时，lua 都会新建一个 FuncState，记录当下解析 function 的中间状态。

** big picture

LexState FuncState Proto 这三者在分析过程中协同生成最终的 Proto。

比如解析如下示例代码，

#+begin_src lua -n 1
function a()
   function b()
   end
end
#+end_src

在整体文件分析开始之前，parser 已经准备好 FuncState，通过 LexState.ls 索引，
FuncState.f 指向相应要生成的 Proto。

#+CAPTION: ls fs f big picture
#+begin_src dot :file generator-big-picture-0.png
digraph {
	node[shape=box];
	rankdir=LR;

	ls;
	c[label="fs"];
	cp[label="f"];

	ls -> c -> cp;
}
#+end_src


#+RESULTS:
[[file:generator-big-picture-0.png]]

解析第 1 行之后，需要函数定义 a，parser 生成新的 FuncState，并更新 ls.fs 的指向。
同时，fs a 通过 prev 指向 fs chunk，表示层级关系。

#+begin_src dot :file generator-big-picture-1.png
digraph {
	node[shape=box];
	rankdir=LR;

	ls;
	c[label="fs"];
	cp[label="f"];

	f[label="fs"];
	fp[label="f"];

	ls -> f;
	c -> cp;

	f -> fp;
	f -> c[label="prev"];

	{rank=same; c; f;}
}
#+end_src

#+RESULTS:
[[file:generator-big-picture-1.png]]


第 2 行，遇到函数 b 定义，同样的，生成 FuncState 并更新 ls.fs 的指向。

#+begin_src dot :file generator-big-picture-2.png
digraph {
	node[shape=box];
	rankdir=LR;

	ls;
	c[label="fs"];
	cp[label="f"];

	f[label="fs"];
	fp[label="f"];

	g[label="fs"];
	gp[label="f"];

	ls -> g;
	c -> cp;

	f -> fp;
	f -> c[label="prev"];

	g -> gp;
	g -> f[label="prev"];

	{rank=same; c; f; g;}
}
#+end_src

#+RESULTS:
[[file:generator-big-picture-2.png]]

第 3 行，函数 b 定义结束，此时 ls.fs 指向 fs b 的 prev，回到上个函数定义层级。
并将函数 b 生成的 Proto 链接到上层函数 a 的 Proto。

此时，fs b 已经结束其作用。

#+begin_src dot :file generator-big-picture-3.png
digraph {
	node[shape=box];
	rankdir=LR;

	ls;
	c[label="fs"];
	cp[label="f"];

	f[label="fs"];
	fp[label="f"];

	g[label="fs", style=dashed];
	gp[label="f"];

	ls -> f;
	c -> cp;

	f -> fp;
	f -> c[label="prev"];

	g -> gp;
	g -> f[label="prev"];

	{rank=same; c; f; g;}

	fp -> gp[label="p[0]"];
}
#+end_src

#+RESULTS:
[[file:generator-big-picture-3.png]]

#+begin_src dot :file generator-big-picture-4.png
digraph {
	node[shape=box];
	rankdir=LR;

	ls;
	c[label="fs"];
	cp[label="f"];

	f[label="fs", style=dashed];
	fp[label="f"];

	g[label="fs", style=dashed];
	gp[label="f"];

	ls -> c -> cp;

	f -> fp;
	f -> c[label="prev"];

	g -> gp;
	g -> f[label="prev"];

	{rank=same; c; f; g;}

	fp -> gp[label="p[0]"];
	cp -> fp[label="p[0]"];
}
#+end_src

#+RESULTS:
[[file:generator-big-picture-4.png]]

第 4 行，函数 a 定义结束，同上，更新 ls.fs 指向，并链接 Proto a 到 Proto chunk。

#+begin_src dot :file generator-big-picture-5.png
digraph {
	node[shape=box];
	rankdir=LR;

	ls[label="ls", style=dashed];
	c[label="fs", style=dashed];
	cp[label="f", style=filled, color=lightblue];

	f[label="fs", style=dashed];
	fp[label="f"];

	g[label="fs", style=dashed];
	gp[label="f"];

	ls -> c -> cp;

	f -> fp;
	f -> c[label="prev"];

	g -> gp;
	g -> f[label="prev"];

	{rank=same; c; f; g;}

	fp -> gp[label="p[0]"];
	cp -> fp[label="p[0]"];
}
#+end_src

#+RESULTS:
[[file:generator-big-picture-5.png]]

最终返回 Proto chunk，ls 和 fs 都已经结束其使命，毕竟它们的作用只用于记录中间状态

在 parser 内部，上面描述的过程发生在 =open_func() close_func()= 中，读者可仔细体会其细节。

#+caption: lparser.c
#+INCLUDE: ../lua-5.1.5/src/lparser.c src c -n 328 :lines "328-381"

** FuncState vs Proto
   :LOGBOOK:
   - Note taken on [2021-01-11 一 14:06] \\
     为什么 local var 和 active local var 存储在两个部分？
     
     因为相应的索引，在生成 code 之后，相当于信息已经存储于 code 的参数中，不需要另行存储
     且 active 只记录一种状态而已，辅助生成正确的代码，在不同阶段是不同的。
     
     因为 active 状态只能在 parse 过程分辨。
     离开作用域自然不是 active 的。
     而是否 active 对于 bytecode 并不重要。
     active 状态用于辅助 funcstate 生成 bytecode。
   - Note taken on [2021-01-11 一 14:06] \\
     关于 upval 的信息，隐藏在了 code 中
   :END:

FuncState 和 Proto 作为分析过程中两个最重要的结构，值得详细做一番了解。

仔细观察两个结构内部的字段，会发现两者之间有紧密的联系，界限很模糊，
都些许记录了分析过程的结果。
关键的差异在于，Proto 只保留最终结果，而 FuncState 记录中间状态。

对应这个原则，来详细探究下两个结构的内部。

先来看 Proto。

#+caption: lobject.h
#+INCLUDE: ../lua-5.1.5/src/lobject.h src C -n 228 :lines "228-254"

其中字段分为 3 部分来看

暂不讨论
- =int *lineinfo=
- =TString *source=
- =int linedefined=
- =int lastlinedefined=
- =GCObject *gclist=

元信息
- =lu_byte numparams= ，函数的固定参数个数
- =lu_byte is_vararg= ，函数的可变参数
- =lu_byte maxstacksize= ，函数运行时，最大使用的栈空间

数组结果
- =TValue *k= ，常量表
- =Instruction *code= ，字节码
- =struct Proto **p= ，内部其它函数定义
- =struct LocVar *locvars= ，局部变量信息
- =TString **upvalues= ，upvalue 信息
- 与 len size 相关的字段

对照之前对 vm 执行模型的讨论，code 和 k 就与之对应。

这里一个有意思的区别，在于 size 和 n。

上面提到的 5 个数组，都对应一个 size 字段，用于记录数组的大小。
同时，也对应一个 n 字段，用于记录当前数组已使用的大小（下一个空闲的位置）。

在分析的过程中，数组 size 值记录空间总长度，当空间不足时，会继续扩大分配。
而数组 n 值用于时刻标识下一个空闲索引，记录分析结果并自增，它的值比 size 小。

当最终分析结束时，将 n 值赋值给相应的 size 值，省略多余不用的空间，此时两者才会相同。

如此看来，n 值应该存放在 FuncState 中，但是存在例外的是 =lu_byte nups= 。

#+begin_src dot :file generator-fcode.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fcode[shape=record, label="
	      | | | | <n> | | |
	      ", xlabel="f->code"];

	fsizecode[label="f->sizecode", shape=plain];
	
	fspc[label="fs->pc", shape=plain];

	fspc -> fcode:n;
}
#+end_src

#+RESULTS:
[[file:generator-fcode.png]]

#+begin_src dot :file generator-fk.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fk[shape=record, label="
	      | | | | <n> | | |
	      ", xlabel="f->k"];

	fsizek[label="f->sizek", shape=plain];
	
	fsnk[label="fs->nk", shape=plain];

	fsnk -> fk:n;
}
#+end_src

#+RESULTS:
[[file:generator-fk.png]]

#+begin_src dot :file generator-fp.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fp[shape=record, label="
	      | | | | <n> | | |
	      ", xlabel="f->p"];

	fsizep[label="f->sizep", shape=plain];
	
	fsnp[label="fs->np", shape=plain];

	fsnp -> fp:n;
}
#+end_src

#+RESULTS:
[[file:generator-fp.png]]


#+begin_src dot :file generator-fupval.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fupval[shape=record, label="
	      | | | | <n> | | |
	      ", xlabel="f->upvalues"];

	fsizeupval[label="f->sizeupvalues", shape=plain];
	
	fnups[label="f->nups", shape=plain];

	fnups -> fupval:n;
}
#+end_src

#+RESULTS:
[[file:generator-fupval.png]]

#+begin_src dot :file generator-flocvars.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	flocvars[shape=record, label="
	      | | | | <n> | | |
	      ", xlabel="f->locvars"];

	fsizelocvars[label="f->sizelocvars", shape=plain];
	
	fsnlocvars[label="fs->nlocvars", shape=plain];

	fsnlocvars -> flocvars:n;
}
#+end_src

#+RESULTS:
[[file:generator-flocvars.png]]

相同的视角，来观察 FuncState。

#+caption: lparser.h
#+INCLUDE: ../lua-5.1.5/src/lparser.h src c -n 57 :lines "57-76"

暂不讨论
- =Proto *f=
- =struct FuncState *prev=
- =struct LexState *ls=
- =struct lua_State *L=

后续讨论
- =struct BlockCnt *bl=
- =int lasttarget=
- =int jpc=
- =int freereg=

中间结果
- =upvaldesc upvalues[LUAI_MAXUPVALUES]=
- =unsigned short actvar[LUAI_MAXVARS]=
- 其它 n 字段

两个数组是定长的，即 size 是固定的， =f->nups= =fs->nactvar= 用于对应其 n 字段。

#+begin_src dot :file generator-fsupval.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fsupval[shape=record, label="
	      | | | | <n> | | |
	      ", xlabel="fs->upvalues"];

	fssizeupval[label="LUAI_MAXUPVALUES", shape=plain];
	
	fnups[label="f->nups", shape=plain];

	fnups -> fsupval:n;
}
#+end_src

#+RESULTS:
[[file:generator-fsupval.png]]

#+begin_src dot :file generator-fsactvar.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fsactvar[shape=record, label="
	      | | | | <n> | | |
	      ", xlabel="fs->actvar"];

	fssizeactvar[label="LUAI_MAXVARS", shape=plain];
	
	fsnactvar[label="fs->nactvar", shape=plain];

	fsnactvar -> fsactvar:n;
}
#+end_src

#+RESULTS:
[[file:generator-fsactvar.png]]

在编译过程中，所得到的结果会不断的存储入上述数组及其它字段中。

* generate

从某种角度看，编译过程就是规则间的同义转换过程。

代码生成，最终将符合语法规则的 lua 代码，生成为 vm 可执行的同义字节码，
这个过程是隐藏在语法分析下的艺术。

两个规则间可以进行同义转换的连接点，在于对 vm 的共识，
正因为编译器"懂得" vm，知晓字节码的格式与功能，知晓运行时的栈结构，
知晓 k 表 Gbl 表的读取方式，才能生成 vm 可执行的同义字节码。

这种共识贯穿在整个代码生成的过程中。

但是无论编译器如何了解 vm，编译时和运行时还是存在区别的。
代码生成时，只是想象存在一个假想的 vm，它在执行生成的所有结果。

所以代码生成这个过程是最为繁杂的，到 vm 真正运行时反而轻松了，只需要读指令，执行指令就可以了。

阅读代码生成相关的代码，笔者还没有精确地把握住其中的原理，只能提供几个原则给读者参考，
- 总体是语法制导翻译的过程
- 使用后缀方式的生成顺序，比如 a + b 按照 a b + 的顺序来转换生成
- 精确模拟 vm 的运行方式，包括栈运算，Gbl 表及其它

章节结束之后，读者可以多使用调试器分析示例代码，探索其中的奥妙。

* key concept

在仔细探索代码生成之前，先明确几个在生成过程中的重点。
  
** variable

从作用域来看，lua 中的变量有 3 类，分别为 =local upvalue global= ，
三者在底层的实现方式各不相同。

*** local
    :LOGBOOK:
    - Note taken on [2021-01-11 一 17:06] \\
      如何和运行时的栈关联起来？
    - Note taken on [2020-12-15 二 11:14] \\
    变量逆序查找，比如出现 local 覆盖的情况
    searchvar() lparser.c:207
    :END:

local 变量的活动范围（active），开始于在作用域中出现的那一刻，一直到作用域结束，
而作用域是有明显的栈特性的，新开辟作用域时入栈，离开作用域时出栈。

在一个作用域内，local 变量按照声明顺序入栈，离开作用域时全部出栈，变为 inactive 状态。

利用这个特性，lua 在编译时，在 fs 中用 actvar 和 nactvar 时刻记录着当前 active local 变量的状态。

比如如下示例代码，

#+begin_src lua
local a

do
   local b
   do
      local c
   end
end

do
   local d
   do
      local e
   end
end
#+end_src

在代码分析的不同时刻， =fs->actvar= 记录的栈状态是这样的，

#+CAPTION: active local scope & fs->actvar nactvar
#+begin_src dot :file generator-active-local-scope.png
digraph {
	rankdir = LR;
	
	code[shape=none, label=<
	      <table border="0" cellspacing="0">
	        <tr><td align="left" border="1" bgcolor="white">local a</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">do</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">    local b</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">    do</td></tr>
	        <tr><td port="fir" align="left" border="1" bgcolor="white">        local c</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">    end</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">end</td></tr>
	        <tr><td port="sec" align="left" border="1" bgcolor="white"> </td></tr>
	        <tr><td align="left" border="1" bgcolor="white">do</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">    local d</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">    do</td></tr>
	        <tr><td port="trd" align="left" border="1" bgcolor="white">        local e</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">    end</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">end</td></tr>
	      </table>
	     >];

	fir[shape=record, label="
	      |<n>| c | b | a
	      ", xlabel="fs->actvar"];

	sec[shape=record, label="
	      || |<n> | a
	      ", xlabel="fs->actvar"];

	trd[shape=record, label="
	      |<n>| e | d | a
	      ", xlabel="fs->actvar"];

	fir -> code:fir;
	sec -> code:sec;
	trd -> code:trd;

	node[shape=plain];

	n1[label="fs->nactvar = 3"];
	n2[label="fs->nactvar = 1"];
	n3[label="fs->nactvar = 3"];

	n1 -> fir:n;
	n2 -> sec:n;
	n3 -> trd:n;

	nodesep = 1;
}
#+end_src

#+RESULTS:
[[file:generator-active-local-scope.png]]

上面只是粗略描述了 active local 变量的栈状态，而实际在 parser 内部，是通过两个数组来存储的。

#+CAPTION: actvar & locvars
#+begin_src dot :file generator-actvar-locvars.png
digraph {
	rankdir = LR;
	ranksep = 1;

	actvar[shape=record, label="
	      |<n> | <n3> 4 | <n2> 3 | <n1> 0
	      ", xlabel="fs->actvar"];

	node[shape=plain];
	
	n[label="fs->nactvar = 3"];
	nn[label="fs->nlocvars = 5"];

	n -> actvar:n;
	locvars:n -> nn[dir="back"];
	
	locvars[shape=record, label="
               |<n>  | <n3> \"e\" | <n2> \"d\" | \"c\" | \"b\" | <n1> \"a\"
	      ", xlabel="f->locvars"];

	actvar:n1 -> locvars:n1;
	actvar:n2 -> locvars:n2;
	actvar:n3 -> locvars:n3;
}
#+end_src

#+RESULTS:
[[file:generator-actvar-locvars.png]]

数组 =fs->actvar= 的元素是 =unsigned short= 类型，只用来记录变量的索引。
索引数组 =f->locvars= 中的元素，其中元素类型为 =struct LocVar *= 。

#+caption: lobject.h
#+INCLUDE: ../lua-5.1.5/src/lobject.h src c -n 262 :lines "262-267"

LocVar 主要记录变量的名字， =startpc endpc= 在字节码层面记录其活动范围。

宏 getlocvar 精确描述了图示过程。

#+caption: lparser.c
#+INCLUDE: ../lua-5.1.5/src/lparser.c src c -n 32 :lines "32-33"

*** upvalue
    :LOGBOOK:
    - Note taken on [2021-01-12 二 09:41] \\
      在分析时，如何使用 f fs 中的数组？
    :END:

upvalue 在本文翻译为上值，它即非 local，又不是 global。
直观从代码上看，即引用作用域之外的变量。

lua 将 function 作为基础类型之一，可以作为普通变量，参数，返回值，赋值，而四处流转。
又因为 local 变量的作用域限定于词法，这便是 upvalue 机制发挥作用的地方。

如下示例代码，

#+begin_src lua :results output :exports both
local function outer()
   local a = 0

   local function inner()
      a = a + 1
      print(a)
   end

   inner()
   
   return inner
end

local f = outer()

f()
f()
#+end_src

#+RESULTS:
: 1
: 2
: 3

内部第 1 次调用 inner() 时，输出 1 。
当调用 outer()，将 inner 赋值与 f，调用两次 f() 得到 2 3 。

第 1 次调用 inner() 时，依然在 a 的作用域内，输出 1 是符合直觉的。

问题在于调用 f() 时，因为 a 只作用在 outer 的作用域，而 f 在 outer 作用域外部，
已经离开了 a 的作用域，这种情况下为何还可以访问 a ？

这便是闭包机制的由来，a 对于 inner 而言是 upvalue 类型。
这也是 lua 中为何 function 不是 function 而是 closure 的原因，function 及 upvalue 组成了 closure，
所有 func 在运行时都封装为 closure 来运行，其中重要的原因就在于单独分配 upvalue 空间并管理。

详细的说，第 1 次调用 inner() 时，local a 依然存活，称 upvalue a 为 open 状态。
当离开 outer() 作用域，upvalue a 为 close 状态。

*** global
    :LOGBOOK:
    - Note taken on [2021-01-12 二 10:11] \\
      在运行时，global 是单独于基层的 closure 存在的，是运行状态的一部分
      Gbl 表
    - Note taken on [2021-01-12 二 10:01] \\
      global at runtime？
    :END:

如果依然说，global 变量是除 local 变量和 upvalue 变量的变量，读者肯定不信服。

之所以存在 upvalue 和 global，隐含的一点是，在 lua 中外层变量对于内层是可见的，
既然是可见的，对于外层变量引用自然有一个查找的过程，变量类型正是在查找的过程中确定的。

- 在当前作用域中可以找到的，为 local 类型
- 在当前作用域之外的作用域可以找到的，为 upvalue 类型
- 所有作用域都无法找到的，为 global 类型

按照这个逻辑，顶层的 chunk 是没有 upvalue 的，在当前作用域中查找不到的变量，
只能是 global 类型。

setfenv 影响的就是函数的 global 环境，
设定不同的 global 表，可以影响内部对 global 的引用，
实现不同的运行效果，类似于封装成一个小沙盒，

比如如下代码，变量 a 对 outer inner 都是全局变量，所以全部修改都影响到 global a 的值。

#+begin_src lua :results output :exports both
local function outer()
  a = 10

  local function inner()
    a = a + 1
    return a
  end

  return inner
end

local f = outer()

print(f(), a)
print(f(), a)
print(f(), a)
#+end_src

#+RESULTS:
: 11	11
: 12	12
: 13	13

** register
   :LOGBOOK:
   - Note taken on [2020-12-07 一 14:01] \\
   如何调度寄存器？
   :END:

寄存器的主要作用是，存取 local 变量和存取中间结果。

寄存器在编译时是一个抽象的概念，没有具体的分配空间，编译器只知晓存在这块区域，
并且按照自己的需要来使用和调试。

而在实际运行时，寄存器存储在 vm 的栈中。

** TODO expdesc
    :LOGBOOK:
    - Note taken on [2021-01-11 一 15:42] \\
      把一些属性附加到代表语言构造的文法符号上，从而把信息和一个语言的构造联系起来
    - Note taken on [2020-12-07 一 17:34] \\
    各个状态如何发生作用？
    :END:

递归下降
语法制导
后缀顺序
配合 vm opcode 共同作用的结果

 exp 基本运作单元
 desc 描述其属性，是 ast 到 code 的纽带

 #+INCLUDE: ../lua-5.1.5/src/lparser.h src c :lines "19-46"

 - VVOID 什么都不做
 - VNIL  nil 值
 - VTRUE
 - VFALSE bool
 - VK    在 k 表中的值  没有 string 类型，因为在读取的过程中，直接将其放入 k 表中，变成 VK 类型了
 - VKNUM 数字字面量


 discharge2reg
 lcode.c:343

 操作的只是 exp 相关的类型

 exp 需要解析到值，而 var 需要解析到位置？

 reg 是目的地

 VRELOCABLE 说明 A 本身还不确定，在 discharge 的时候，补全到 A 位置

 VNONRELOC 则说明本身已经解析到栈中 或 A 已经正确

discharge2reg

 | exp desc   | gen code                                 |
 |------------+------------------------------------------|
 | VNIL       | loadnil                                  |
 | VTRUE      | loadbool                                 |
 | VFALSE     | loadbool                                 |
 | VK         | loadk                                    |
 | VKNUM      | loadk                                    |
 | VRELOCABLE | get its code and change A to reg         |
 | VNONRELOC  | reg != self reg, move; otherwise nothing |
 | VVOID      | nothing                                  |
 | VJMP       | nothing                                  |

 dischargevars

 | exp desc | discharge                                            |
 |----------+------------------------------------------------------|
 | VLOCAL   | to VNONRELOC                                         |
 | VUPVAL   | gen code GETUPVAL, A is uncertain, to VRELOCABLE     |
 | VGLOBAL  | gen code GETGLOBAL, A is uncertain, to VRELOCABLE    |
 | VINDEXED | free table and idx, gen code GETTABLE, to VRELOCABLE |
 | VCALL    | to VNONRELOC, store call code A value                |
 | VVARARG  | set B to 2? to VRELOCABLE                            |

** TODO how freereg & freeexp works

#+CAPTION: page 19 & 20

freereg 的作用

在栈的特性上，更深入的理解

何时分配，何时回收

根据抽象栈演算的顺序来

和 nactvar 的关系


* statement

本节开始从实例具体分析代码生成的过程，和实例一起来探求其中的生成模式。

因为语法元素的递归性，其中的组合是无限的，所以本节只挑选讲解部分重要的“原子性”的部分，
至于各种组合的变数读者可自由探索。

** tool

在开始以实例为基础的探索之前，先详细介绍相应工具的使用。

以交互式启动 chunkspy，用于临时检验一些想法。

#+begin_example
$ make spy
#+end_example

分析特定 lua 文件，输出相应的编译结果。

#+begin_example
$ make -s inspect source=lua_file_path
#+end_example

比如分析如下代码，

#+begin_src lua
local a = 1
#+end_src

会输出如下结果，

#+begin_example -n 1
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 2 stacks
.function  0 0 2 2
.local  "a"  ; 0
.const  1  ; 0
[1] loadk      0   0        ; 1
[2] return     0   1      
; end of function
#+end_example

逐行来看，

line 1

level 1 指的是第一层级，即 chunk；
function [0] 表明是当前层级的第 1 个函数（以 0 开始索引）

line 2

函数有 0 个 upvalue，0 个参数，按 =0b010= 模式接收可变参数，需要分配栈容量 2。

line 3

意义和 line 2 相同，line 2 是 line 3 的注释

line 4 5

.local 列出所有局部变量的名称及索引，即 f->locvars 的内容
.const 列出 k 表的内容及索引

line 6 7

详细打印 f->code 指令，最终一行总是默认生成一条 return 指令

line 8

注释，表明 function 结束

读者结合 opcode 章节对各个指令功能的理解，不难理解 lua 代码和字节码的同义关系。

** local

先来观察 local 语句。

语法描述如下，

#+begin_src bnf
stat      ::= localstat
localstat ::= LOCAL NAME {`,' NAME} [`=' explist]
localstat ::= LOCAL FUNCTION NAME body
#+end_src

localstat 可用于定义局部变量和局部函数。

函数部分到后面小节再讨论，对于局部变量，根据是否赋值可分为两种情况。

*** no assignment

如下简单的代码示例，定义局部变量，无赋值，

#+begin_src lua
local a, b, c
#+end_src

分析得到如下结果，

#+begin_example
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 3 stacks
.function  0 0 2 3
.local  "a"  ; 0
.local  "b"  ; 1
.local  "c"  ; 2
[1] return     0   1      
; end of function
#+end_example

示例代码只是单纯进行了局部变量的声明，最终没有生成任何字节码。

分析的过程，就是递归向下的函数过程， =chunk -> stat -> localstat= 。

#+caption: lparser.c
#+begin_src C -n 1179 -r
static void localstat (LexState *ls) {
  /* stat -> LOCAL NAME {`,' NAME} [`=' explist1] */
  int nvars = 0;
  int nexps;
  expdesc e;
  do {
    new_localvar(ls, str_checkname(ls), nvars++);   (ref:new_localvar)
  } while (testnext(ls, ','));
  if (testnext(ls, '='))
    nexps = explist1(ls, &e);
  else {
    e.k = VVOID;
    nexps = 0;
  }
  adjust_assign(ls, nvars, nexps, &e);
  adjustlocalvars(ls, nvars);
}
#+end_src

关键在于 [[(new_localvar)][new_localvar]] 函数，在循环中读入 a b c，并进行变量分析。

#+caption: lparser.c
#+begin_src C -n 160 -r
static void new_localvar (LexState *ls, TString *name, int n) {
  FuncState *fs = ls->fs;
  luaY_checklimit(fs, fs->nactvar+n+1, LUAI_MAXVARS, "local variables");
  fs->actvar[fs->nactvar+n] = cast(unsigned short, registerlocalvar(ls, name));
}
#+end_src

#+caption: lparser.c
#+begin_src C -n 143 -r
static int registerlocalvar (LexState *ls, TString *varname) {
  FuncState *fs = ls->fs;
  Proto *f = fs->f;
  int oldsize = f->sizelocvars;
  luaM_growvector(ls->L, f->locvars, fs->nlocvars, f->sizelocvars,
                  LocVar, SHRT_MAX, "too many local variables");
  while (oldsize < f->sizelocvars) f->locvars[oldsize++].varname = NULL;
  f->locvars[fs->nlocvars].varname = varname;
  luaC_objbarrier(ls->L, f, varname);
  return fs->nlocvars++;
}
#+end_src

其中根据变量出现的顺序，依次使用 registerlocalvar 得到变量索引，再记录到 =fs->actvar= 中。

这就是前面讨论过的，局部变量的存储方式，使用 =fs->actvar= 记录索引， =f->locvars= 记录变量名称。

#+CAPTION: local no assign
#+begin_src dot :file generator-local-no-assign.png
digraph {
	rankdir = LR;
	ranksep = 1;

	actvar[shape=record, label="
	      |<n> | <n3> 2 | <n2> 1 | <n1> 0
	      ", xlabel="fs->actvar"];

	node[shape=plain];
	
	n[label="fs->nactvar = 3"];
	nn[label="fs->nlocvars = 3"];

	n -> actvar:n;
	locvars:n -> nn[dir="back"];
	
	locvars[shape=record, label="
               |<n>  | <n3> \"c\" | <n2> \"b\" | <n1> \"a\"
	      ", xlabel="f->locvars"];

	actvar:n1 -> locvars:n1;
	actvar:n2 -> locvars:n2;
	actvar:n3 -> locvars:n3;
}
#+end_src

#+RESULTS:
[[file:generator-local-no-assign.png]]

[[(new_localvar)][new_locvar]] 完成的就是这个过程。

这也对应了 chunkspy 分析结果中的 .local 部分。

*** with assignment

再来看 local 变量赋值的情况。

分析示例代码，得到如下结果，
    
#+begin_src lua
local a, b, c, d, e = 10, "second", nil, true, false
#+end_src

#+begin_example
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 5 stacks
.function  0 0 2 5
.local  "a"  ; 0
.local  "b"  ; 1
.local  "c"  ; 2
.local  "d"  ; 3
.local  "e"  ; 4
.const  10  ; 0
.const  "second"  ; 1
[1] loadk      0   0        ; 10
[2] loadk      1   1        ; "second"
[3] loadnil    2   2      
[4] loadbool   3   1   0    ; true
[5] loadbool   4   0   0    ; false
[6] return     0   1      
; end of function
#+end_example

除了 .local 条目变多了，也增加了 .const 部分，意味着 k 表多出了 2 项记录。

依旧从 localstat 来分析，

#+caption: lparser.c
#+begin_src C -n 1179 -r
static void localstat (LexState *ls) {
  /* stat -> LOCAL NAME {`,' NAME} [`=' explist1] */
  int nvars = 0;
  int nexps;
  expdesc e;
  do {
    new_localvar(ls, str_checkname(ls), nvars++);
  } while (testnext(ls, ','));
  if (testnext(ls, '='))
    nexps = explist1(ls, &e);           (ref:localstat_explist)
  else {
    e.k = VVOID;
    nexps = 0;
  }
  adjust_assign(ls, nvars, nexps, &e);
  adjustlocalvars(ls, nvars);
}
#+end_src

在记录变量信息之后，遇到 ~=~ ，开始分析 ~=~ 后的 [[(localstat_explist)][表达式列表]] ，作为变量的赋值内容。

后面的表达式都是简单表达式，最终会调用 simpleexp 进行解析。

#+begin_src bnf
explist      ::= expr {`,' expr}
expr         ::= subexpr
subexpr      ::= (simpleexp | unop subexpr) {binop subexpr}

simpleexp    ::= NUMBER | STRING | NIL | TRUE | FALSE | DOTS |
                 constructor | FUNCTION body | primaryexp
#+end_src

下面有趣的地方来了，字节码和 k 表中的元素是何时生成的？
这就和代码生成的方式紧密相关了。

parser 模块中代码生成的强大在于，它是流式生成的。
意思即一边读入 token，分析状态，就直接生成代码！

从代码具体来看，

#+begin_src C -r -n 596
static int explist1 (LexState *ls, expdesc *v) {
  /* explist1 -> expr { `,' expr } */
  int n = 1;  /* at least one expression */
  expr(ls, v);                         (ref:fir_exp)
  while (testnext(ls, ',')) {
    luaK_exp2nextreg(ls->fs, v);       (ref:fir_gen)
    expr(ls, v);                       (ref:sec_exp)
    n++;
  }
  return n;
}
#+end_src

在[[(fir_exp)][第 1 次分析表达式]] 时，读入并分析了 10，并在 [[(sec_exp)][第 2 次分析表达式 "second"]] 之前，已经[[(fir_gen)][生成代码并更新了 k 表]]。

先来看 expr()，由于分析的是简单表达式，最终会调用 simpleexp 进行分析，

#+begin_src C -n 727 -r
static void simpleexp (LexState *ls, expdesc *v) {
  /* simpleexp -> NUMBER | STRING | NIL | true | false | ... |
                  constructor | FUNCTION body | primaryexp */
  switch (ls->t.token) {
    case TK_NUMBER: {
      init_exp(v, VKNUM, 0);
      v->u.nval = ls->t.seminfo.r;
      break;
    }
    case TK_STRING: {
      codestring(ls, v, ls->t.seminfo.ts);
      break;
    }
    case TK_NIL: {
      init_exp(v, VNIL, 0);
      break;
    }
    case TK_TRUE: {
      init_exp(v, VTRUE, 0);
      break;
    }
    case TK_FALSE: {
      init_exp(v, VFALSE, 0);
      break;
    }
    case TK_DOTS: {  /* vararg */
      FuncState *fs = ls->fs;
      check_condition(ls, fs->f->is_vararg,
                      "cannot use " LUA_QL("...") " outside a vararg function");
      fs->f->is_vararg &= ~VARARG_NEEDSARG;  /* don't need 'arg' */
      init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 1, 0));
      break;
    }
    case '{': {  /* constructor */
      constructor(ls, v);
      return;
    }
    case TK_FUNCTION: {
      luaX_next(ls);
      body(ls, v, 0, ls->linenumber);
      return;
    }
    default: {
      primaryexp(ls, v);
      return;
    }
  }
  luaX_next(ls);
}
#+end_src

第 1 次分析 10 时，token 类型是 =TK_NUMBER= ，直接填充 expdesc 即可，
然后调用 luaK_exp2nextreg 生成代码。

luaK_exp2nextreg 是一个综合过程，由更基础的几个函数组成。

深入分析之前，先来补充之前 FuncState 未描述的一个字段，freereg。

字节码被 vm 运行时，vm 维持一个栈，来存放寄存器和中间结果。
编译器只知晓这个栈的存在，但是在编译时，这个栈并没有真实存在，
只能凭借想象去操作它。

freereg 就是用来记录栈顶的变量。

当存储新的寄存器值时，freereg 就会自增，为寄存器开出空间；

#+caption: lcode.c
#+include: ../lua-5.1.5/src/lcode.c src c -n 209 :lines "209-213"

相应的，如果寄存器不再使用，freereg 会自减，回收相应的空间。

#+caption: lcode.c
#+include: ../lua-5.1.5/src/lcode.c src c -n 215 :lines "215-221"

从中可以看出，freereg 将栈分为两部分，在栈底为 local 变量保留空间（reg >= fs->nactvar），
上层用于计算中间结果。

#+caption: freereg and stack
#+begin_src dot :file generator-freereg-stack.png
digraph {
	rankdir = LR;
	
	fir[shape=record, label="
	    ||||<n> | a
	    ", xlabel="vm stack"];

	node[shape=plain];
	
	n1[label="fs->freereg = 1"];

	n1 -> fir:n;
}
#+end_src

#+RESULTS:
[[file:generator-freereg-stack.png]]


#+caption: lcode.c
#+include: ../lua-5.1.5/src/lcode.c src c -n 414 :lines "414-420"

在 luaK_exp2nextreg 中，先找出下一个可用的栈/寄存器空间，然后将表达式的值解析到寄存器中，
即生成字节码。

最终在 discharge2reg 函数生成相应指令 loadk。

这里出现了第二个重点，对 k 表的操作。

因为其类型为数字，所以调用的是 luaK_numberK。

#+caption: lcode.c
#+include: ../lua-5.1.5/src/lcode.c src c -n 229 :lines "229-278"

所有操作 k 表的方法，最终都使用 addk 操作，其作用也很简单，
在 k 表中搜索，如果存在，则直接返回相应索引，其中使用 table fs->h 做 k 表元素的反向索引，加快搜索过程；
若不存在，则自增，并返回相应的索引。

#+caption: number k
#+begin_src dot :file generator-numberk-10.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	rankdir = LR;
	
	fk[shape=record, label="
	      | | | | <n> |10
	      ", xlabel="f->k"];

	fsizek[label="f->sizek", shape=plain];
	
	fsnk[label="fs->nk", shape=plain];

	fsnk -> fk:n;
}
#+end_src

#+RESULTS:
[[file:generator-numberk-10.png]]

将数字 10 存储入 k 表之后，生成 loadk 指令，将 freereg 和 k 索引作为其操作数。

至此，parser 只读入了 token 10，便已经完成了操作 k 表，记录常数，并生成对应的指令，令人惊奇。

对于第 2 个表达式 "second"，在 simpleexp 时，提前调用 codestring 加入了 k 表，
将其作为 VK 类型来对待。

#+caption: lparser.c
#+include: ../lua-5.1.5/src/lparser.c src c -n 133 :lines "133-136"

#+begin_src dot :file generator-stringk-second.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	rankdir = LR;
	
	fk[shape=record, label="
	      | | | <n>|\"second\" | 10
	      ", xlabel="f->k"];

	fsizek[label="f->sizek", shape=plain];
	
	fsnk[label="fs->nk", shape=plain];

	fsnk -> fk:n;
}
#+end_src

#+RESULTS:
[[file:generator-stringk-second.png]]

同样的生成 loadk 指令。

回到 localstat()，前面对变量和表达式进行解析之后，记录了 ~=~ 两边的数量 nvars nexps，
=adjust_assign()= 进行左右数量的调整，多余的 var 空间置为 nil，多余的 exp 则省略。

最终调用 =adjustlocalvars()= 调整 fs->nactvar 的值。

**** TODO multret

TODO 有 multret 的再讨论

下面的情况是合法的，只不过前面的 multret 只返回一个值，而最后的可利用多个值

#+begin_src lua
local a, b, c = ..., ..., ...
#+end_src

** assign

exprstat -> assignstat

*** global

#+begin_src lua
a, b, c = 10, 20, 30
#+end_src

进入 primaryexp prefixexp 查找的时候，TK NAME 要进行 singlevar 查找

赋值为 VGLOBAL，且 info 存储了名字对应的 k 表索引
和 expkind 的注释不符合？



进入 assignment，按照 ebnf ，本身是嵌套的
进入之前，先将 v prev 设置为 NULL，后面全部链接起来


LHS_assign 结构，在 expdesc 的基础上，添加了 prev 指针

在 多个 , 之间的 var 全部链接起来

其中可赋值的类型为
VLOCAL VUPVAL VGLOBAL VINDEXED
由 primaryexp 决定


赋值阶段，在每个递归层次，用 luaK_storevar 来存储



var ex

先 discharge ex
再生成 SETGLOBAL，使用 info 中存储的 k 索引
gbl[kst[info]] = R(A)




luaK_exp2anyreg

只需要解析到 reg 就可以，临时使用，赋值之后就废弃


exp 可能是 var，也可能是 值
但是通过 dis var 是保险的

默认依然使用 exp2nextreg，只不过在之前，添加了解析 jump 的部分

exp2nextreg，存储在 freereg 之后

exp2reg，存储到指定 reg

其中解析了 jump 相关的内容

最终成为 VNONRELOC

*** upvalue

#+begin_src lua
local a = 10

function f()
  a = 20
end
#+end_src

和 global 相似

*** indexed

a.b   a['b']
是相同语义

a 必须是 table，语义才正确


gettable 中，之所以使用 RK(C) 这种方法，是因为索引值未必是 constant，也可能是
一个表，一个函数，等其它值，这种值只能由 寄存器 存储

同时，加上了 k，也可以节省临时寄存器的使用

如果超出了 k 表的范围，大于 256，需要临时先加载入 寄存器

** function

#+begin_src lua
local function f()
end

local f = function ()
end
#+end_src


compile time

enf 结构

body 方便定义匿名函数

func 有同名和匿名两种
从 ebnf 中可以看出，两者只差在 NAME
几乎全部由 body 处理
包含了参数，函数体等全部
动态类型，名称与值的绑定，所以由 body 来处理全部

#+CAPTION: 29 function

body 过程不过是参数和 chunk 的递归过程

*** upval
    :LOGBOOK:
    - Note taken on [2020-12-15 二 14:08] \\
    需要更明显的图示
    :END:

和 closure 同一级的变量被引用，使用 move 指令
>= 级的变量，使用 getupval 指令


move A B

A 无用，B 指代 local 的 active 栈索引

getupval A B

A 无用，B 指代上层 closure 中 upval 表的序号

getupval 一直向上链，总会找到 local 对应的位置


Q: f 没有明显引用 a，但是但 a 却存在于 f 的 upval 数组中？

A:

singlevar
singlevaraux

从底层向上寻找，从 f 向上找到 a，调用 indexupvalue (lparser.c:183)
作为 upval 使用，而非 local，在 index upval 的过程中，
添加到 f 的 upval 表中

新增 upval 并返回 upval 对应的索引

*** vararg
    :LOGBOOK:
    - Note taken on [2020-12-15 二 13:38] \\
    在 vm 运行时，再详细深入栈过程
    :END:

lobject.h:256

|        4 |        2 |      1 |
|----------+----------+--------|
| NEEDSARG | ISVARARG | HASARG |


在 lua5.0 中，没有 ... 的表达式，只能在参数定义时使用

而在内部引用 vararg 时，通过变量 arg 来使用

arg 是一个 table，内部以数组形式存储了 vararg

arg.n 是数组的长度

#+begin_src lua
function foo(a, b, ...)
  local arg = {...}
  arg.n = select("#", ...)
end
#+end_src


lua5.1 默认有对上面形式的兼容性

NEEDSARG 表明是否在内部构造 arg 的值

ldo.c:215

lua5.1 判断，如果内部出现了 ... exp，就不使用 arg，
NEEDSARG = 0

lparser.c:756

HASARG 用于在计算 nparam 时很方便，直接使用 & 运算就可以

lparser.c:571

ISVARARG 和 HASARG 应该是相同的？
chunk main func 只有 ISVARARG 标志


无即是 0
chunk func 是 2
不引用 arg 是 3
引用 arg 是 7


存储在 proto
- numparams，vararg 不算一个参数
- is_vararg

** do

- block vs chunk
  - 整体文件按照 chunk 来解析，chunk 是入口
  - block ::= chunk，但具体使用方式要根据语句的类型来分析
    并非所有引用 chunk 的地方都会像 function 结构使用 chunk 会影响 fs 结构，
    更多依赖 chunk 递归处理语句的便利
- 分类
  - loop 中
  - 非 loop 中

blockCnt
- previous
- nactvar，进入 block 前 nactvar 的个数
- isbreakable，是否用在循环中，从 bnf 中可看到
- breaklist，chain of jump out of the loop，在 while 时深入
- upval，bool，当前作用域中是否有 local var 作为 upval，在 for 时深入

明显的作用域分隔作用

enterblock
leaveblock

在进入时，nactvar 记录 active local var 的数量，
block 内新的 local var 会在离开时，全部释放
符合作用域的原则
内部使用，销毁，不污染外部

#+CAPTION: 24 do block

作用域记录在 fs 中，最终要体现到 f 中
最终在 do 之外，使用 b，会顺着 a 0 的顺序向后，b 1
说明前面的所有变量已回收

虽然有多个 block 相隔，但是在最内层进行变量查找的时候，上层的所有 act local var 都
属于同一个 fs，查找 a 的时候，a 的类型为 local，直接进行了修改
a 并不是 upval，可见 upval 只针对 function 而言

非 loop 只有 nactvar 起作用

loop 情况，到 while for 具体分析。

** if
   :LOGBOOK:
   - Note taken on [2021-01-08 五 13:51] \\
     因为分析从左向右，从前至后的，所以对于一些结构需要特别的方法来处理
     比如 if 分支的处理，回填 jmp 地址
   :END:

顺序解析的难题之一
分支

- jump chain resolve

#+CAPTION: 25 if else code pattern


concat

patch

patch to here, concat

patch to list, discharge right now to target

they are the same

dischargejpc




luaK_jump 时，使用 jpc 重置的技巧，防止在生成 jump 时，触发 dischargejpc

*** if

dischargejpc
负责从当前 pc 解析 jump chain

隐藏在 luaK_code 中


问题添加 return 0 1 的原因

#+CAPTION: 26 if chain

*** if else

#+CAPTION: 27 if else chain

*** if elseif

#+CAPTION: 28 if elseif chain

*** if elseif else

#+CAPTION: 29 if elseif else chain

** while

#+CAPTION: 30 while pattern

block

breakable  1
这样其中才可以生成 break 语句

breaklist
用于记录 break 语句，chain 到 block 外的第一条语句

enterblock 自然生成 0 block

相当于有双层 block

*** break

#+CAPTION: 30 break in while
     
** repeat

repeat    

#+CAPTION: 31 repeat

break 同 while 时的表现相同


不过对于 upval，有自己的处理方式


因为 while 在 cond 中不能定义新的 local var
而 repeat 的 block 中可能先定义 local var
再被其中的 func 引用，而 i 在不断变化，就需要及时 close




#+begin_src lua :results output
local t = {}

local c = 0

repeat
   c = c + 1

   local i = c

   t[i] = function ()
      return i
   end
until i > 10

for i, f in ipairs(t) do
   print(f())
end
#+end_src

#+RESULTS:
#+begin_example
1
2
3
4
5
6
7
8
9
10
11
#+end_example

进行 upval 判断的原因

每个 func 记录的都是 i，但是每次 loop 结束都进行了 close，


#+CAPTION: 31 repeat upval


** for

for loop 特别开发了底层指令来处理，而 repeat 和 while 则没有相应的指令。
依然是通过 jmp 来实现的。

分为两种

数字迭代 fornum

#+begin_src lua
for i = 1, 10, 2 do
  print(i)
end
#+end_src

通用迭代 forlist

#+begin_src lua
for k, v in pairs(t) do
  print(k, v)
end
#+end_src

*** fornum

隐式生成的变量，用 ( 来标识，是不会与正常 lua 代码中分析得到的 NAME 冲突的
因为 lex 规则的限定

#+begin_example
.local  "(for generator)"  ; 0
.local  "(for state)"  ; 1
.local  "(for control)"  ; 2
#+end_example

#+CAPTION: 32 for and upval

*** forlist

#+begin_src lua :results output
local g, s = pairs({1,2,3})

for k, v in g, s, nil do
  print(k, v)
end
#+end_src

#+RESULTS:
: 1	1
: 2	2
: 3	3

#+CAPTION: 33 for and upval

upvalue 同 fornum

** function call

function call

func 在栈的底部，参数向上累加

调用结果，返回值，从栈的 func 处开始向上覆盖

#+CAPTION: 34 func call

funcargs()
lparser.c:609

并不复杂

*** self

#+begin_src lua :results output
local o = {}

function o.f(self)
  print(self)
end

function o:f()
  print(self)
end

o.f(o)

o:f()
#+end_src

#+RESULTS:
: table: 0x55bb5b89d270
: table: 0x55bb5b89d270

self 指令，只是一种优化方式



luaK_self()

lcode.c:503

结合 op self 的语义，并不复杂

#+CAPTION: 35 self

self 只是为 call 做准备，将对象提前放到相应位置


** ret

return 在 chunk 中发挥作用
从当前 closure 中返回

return 必须是 chunk 的最后一个语句

按语句含义返回值，至于有多少值被利用，则根据 opcode 生成过程中决定的

opcode 容易理解

retstat()
lparser.c:1238

*** tailcall

#+begin_src lua
-- tail call
return f()
-- not tail call
return a, b, f()
#+end_src

ret 中只有单独的 function call

进行栈优化

lparser.c:1249

tailcall 本身已经有了 return 的语义


* practice

理想的 vm
独立，lua 实现对 vm 做了协同的妥协

** arithmetic

- 优先级

lua 在进行解析时，没有进行关系运算的实时解析，但是对 constant 算法运算有编译时执行

如 `local a = 5 > 2` 和 `local a = 1 + 2` 的区别

前者需要生成 jmp 指令，但是后者，直接是 loadk 0 0 ; 3

** logic

- and or

** constructor

- setlist always consistent, diff with settable

