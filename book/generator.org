#+SETUPFILE: setup.org

#+TITLE: generator
#+DATE: <2021-01-08 五 11:34>

上一章尝试单独解析语法分析过程，本章关注具体的代码生成过程。

#+begin_src dot :file generator-feature.png
digraph {
	rankdir = TB;
	node[shape=box];

	lua[label="Lua Code"];
	tk[label="Token"];

	subgraph cluster_0 {
	ast[label="AST", style="dotted"];
	op[label="Opcode"];
	style=filled;
	color=lightblue;
}
	vm[label="VM"];

	lua -> tk[label="lex"];
	tk -> ast[label="parse"];
	ast -> op[label="generate"];
	op -> vm[label="executed"];
}
#+end_src

#+RESULTS:
[[file:generator-feature.png]]

* function vs proto vs closure

在具体深入代码生成之前，先来区分三个概念，function proto 和 closure。

function，是 lua 语言中定义的概念，是 8 种基础类型之一，表示函数，
具体在 lua 代码中用关键字 =function= 来定义。

如同 string 概念在底层由 TString 结构来实现一样，
function 在底层用 Proto 结构来实现，是 function 整体编译之后得到的同语义结构。

编译得到的 Proto 是静态的，在实际运行的时候，需要封装为 Closure 结构，交由 vm 来执行。
Closure 为 upvalue 分配了空间，并统一表示了 c function 和 lua function。

这也是为什么在 object 章节，提到基础类型对应的实现结构时，用 Closure 而不是用 Proto 来表示 function。

所以在编译时期，我们关注 Proto，而在运行时期，才关注 Closure。

** chunk

lua 内部使用了一种巧妙的实现，在编译时，将整个文件当做一个匿名 function 来对待。
相当于文件头加了 =function ()= ，文件尾加了 =end= 。

#+caption: lparser.c
#+INCLUDE: ../lua-5.1.5/src/lparser.c src c -n 383 :lines "383-399"

可以看到， =luaY_parser= 读取文件，最终生成并返回 =Proto *= 。

因为整体分析的入口是 chunk，lua 又将文件当做匿名函数来对待，
这也是很多 lua 书籍中提到 chunk 的原因，表示文件编译得到的结果。

** embeded

如果按照 function 和 Proto 一一对应的关系，会出现函数层级的问题。

比如下面的示例代码，

#+begin_src lua
function a()
   function b()
   end
end

function c()
   function d()
   end

   function e()
   end
end
#+end_src

如果将 lua 代码文件看作 Proto chunk，代码中定义的 a b c d 同样是 function 且编译为 Proto。
但是 function a b c d e 是 lua 代码的一部分，所以其 Proto 也应该被包含在 Proto chunk 中。

lua 内部根据 function 定义的位置，来记录这种包含关系。

#+begin_src dot :file generator-function-level.png
digraph {
	node[shape=box];
	
	subgraph cluster_0 {
		label="chunk()";

		subgraph cluster_2 {
			label="c()";

			e[label="e()"];
			d[label="d()"];
		}

		subgraph cluster_1 {
			label="a()";

			b[label="b()"];
		}
	}
}
#+end_src

#+RESULTS:
[[file:generator-function-level.png]]

function a c 直接定义在代码文件（顶层匿名函数）中，
b d e 则直接定义在 a 和 c 中。

#+begin_src dot :file generator-proto-level.png
digraph {
	node[shape=box];

	rankdir = LR;

	ac[shape=record, label=" <a> a | <c> c "];
	de[shape=record, label=" <d> d | <e> e "];

	chunk -> ac:a[label="p"];
	ac:a -> b[label="p"];
	ac:c -> de:d[label="p"];
}
#+end_src

#+RESULTS:
[[file:generator-proto-level.png]]

Proto 结构中使用 struct Proto * 数组 p（Line 235）来记录其直接包含的 Proto。

#+caption: lobject.h
#+INCLUDE: ../lua-5.1.5/src/lobject.h src C -n 228 :lines "228-254"

** FuncState

在 lua 的语法分析中，function 解析是一个重要的部分。

EBNF 和 regex 的区别在于，EBNF 可以描述一种递归过程，而 regex 则不能。

chunk 作为解析 function 的入口，得到 Proto，这个过程在遇到 function 定义时，不断的递归调用，生成 Proto，
并按照层级链接起来。

在了解这个过程之前，要先介绍另一个重要的结构 FuncState 。

#+caption: lparser.h
#+INCLUDE: ../lua-5.1.5/src/lparser.h src c -n 57 :lines "57-76"

从名称可以看出，和 LexState 相似，也用于记录中间状态。
FuncState 用于记录 function 分析过程中的状态，和 function 定义一一对应，
每遇到一个 function 定义时，lua 都会新建一个 FuncState，记录当下解析 function 的中间状态。

** big picture

LexState FuncState Proto 这三者在分析过程中协同生成最终的 Proto。

比如解析如下示例代码，

#+begin_src lua -n 1
function a()
   function b()
   end
end
#+end_src

在整体文件分析开始之前，parser 已经准备好 FuncState，通过 LexState.ls 索引，
FuncState.f 指向相应要生成的 Proto。

#+CAPTION: ls fs f big picture
#+begin_src dot :file generator-big-picture-0.png
digraph {
	node[shape=box];
	rankdir=LR;

	ls;
	c[label="fs"];
	cp[label="f"];

	ls -> c -> cp;
}
#+end_src


#+RESULTS:
[[file:generator-big-picture-0.png]]

解析第 1 行之后，需要函数定义 a，parser 生成新的 FuncState，并更新 ls.fs 的指向。
同时，fs a 通过 prev 指向 fs chunk，表示层级关系。

#+begin_src dot :file generator-big-picture-1.png
digraph {
	node[shape=box];
	rankdir=LR;

	ls;
	c[label="fs"];
	cp[label="f"];

	f[label="fs"];
	fp[label="f"];

	ls -> f;
	c -> cp;

	f -> fp;
	f -> c[label="prev"];

	{rank=same; c; f;}
}
#+end_src

#+RESULTS:
[[file:generator-big-picture-1.png]]


第 2 行，遇到函数 b 定义，同样的，生成 FuncState 并更新 ls.fs 的指向。

#+begin_src dot :file generator-big-picture-2.png
digraph {
	node[shape=box];
	rankdir=LR;

	ls;
	c[label="fs"];
	cp[label="f"];

	f[label="fs"];
	fp[label="f"];

	g[label="fs"];
	gp[label="f"];

	ls -> g;
	c -> cp;

	f -> fp;
	f -> c[label="prev"];

	g -> gp;
	g -> f[label="prev"];

	{rank=same; c; f; g;}
}
#+end_src

#+RESULTS:
[[file:generator-big-picture-2.png]]

第 3 行，函数 b 定义结束，此时 ls.fs 指向 fs b 的 prev，回到上个函数定义层级。
并将函数 b 生成的 Proto 链接到上层函数 a 的 Proto。

此时，fs b 已经结束其作用。

#+begin_src dot :file generator-big-picture-3.png
digraph {
	node[shape=box];
	rankdir=LR;

	ls;
	c[label="fs"];
	cp[label="f"];

	f[label="fs"];
	fp[label="f"];

	g[label="fs", style=dashed];
	gp[label="f"];

	ls -> f;
	c -> cp;

	f -> fp;
	f -> c[label="prev"];

	g -> gp;
	g -> f[label="prev"];

	{rank=same; c; f; g;}

	fp -> gp[label="p[0]"];
}
#+end_src

#+RESULTS:
[[file:generator-big-picture-3.png]]

#+begin_src dot :file generator-big-picture-4.png
digraph {
	node[shape=box];
	rankdir=LR;

	ls;
	c[label="fs"];
	cp[label="f"];

	f[label="fs", style=dashed];
	fp[label="f"];

	g[label="fs", style=dashed];
	gp[label="f"];

	ls -> c -> cp;

	f -> fp;
	f -> c[label="prev"];

	g -> gp;
	g -> f[label="prev"];

	{rank=same; c; f; g;}

	fp -> gp[label="p[0]"];
	cp -> fp[label="p[0]"];
}
#+end_src

#+RESULTS:
[[file:generator-big-picture-4.png]]

第 4 行，函数 a 定义结束，同上，更新 ls.fs 指向，并链接 Proto a 到 Proto chunk。

#+begin_src dot :file generator-big-picture-5.png
digraph {
	node[shape=box];
	rankdir=LR;

	ls[label="ls", style=dashed];
	c[label="fs", style=dashed];
	cp[label="f", style=filled, color=lightblue];

	f[label="fs", style=dashed];
	fp[label="f"];

	g[label="fs", style=dashed];
	gp[label="f"];

	ls -> c -> cp;

	f -> fp;
	f -> c[label="prev"];

	g -> gp;
	g -> f[label="prev"];

	{rank=same; c; f; g;}

	fp -> gp[label="p[0]"];
	cp -> fp[label="p[0]"];
}
#+end_src

#+RESULTS:
[[file:generator-big-picture-5.png]]

最终返回 Proto chunk，ls 和 fs 都已经结束其使命，毕竟它们的作用只用于记录中间状态

在 parser 内部，上面描述的过程发生在 =open_func() close_func()= 中，读者可仔细体会其细节。

#+caption: lparser.c
#+INCLUDE: ../lua-5.1.5/src/lparser.c src c -n 328 :lines "328-381"

** FuncState vs Proto
   :LOGBOOK:
   - Note taken on [2021-01-11 一 14:06] \\
     为什么 local var 和 active local var 存储在两个部分？
     
     因为相应的索引，在生成 code 之后，相当于信息已经存储于 code 的参数中，不需要另行存储
     且 active 只记录一种状态而已，辅助生成正确的代码，在不同阶段是不同的。
     
     因为 active 状态只能在 parse 过程分辨。
     离开作用域自然不是 active 的。
     而是否 active 对于 bytecode 并不重要。
     active 状态用于辅助 funcstate 生成 bytecode。
   - Note taken on [2021-01-11 一 14:06] \\
     关于 upval 的信息，隐藏在了 code 中
   :END:

FuncState 和 Proto 作为分析过程中两个最重要的结构，值得详细做一番了解。

仔细观察两个结构内部的字段，会发现两者之间有紧密的联系，界限很模糊，
都些许记录了分析过程的结果。
关键的差异在于，Proto 只保留最终结果，而 FuncState 记录中间状态。

对应这个原则，来详细探究下两个结构的内部。

先来看 Proto。

#+caption: lobject.h
#+INCLUDE: ../lua-5.1.5/src/lobject.h src C -n 228 :lines "228-254"

其中字段分为 3 部分来看

暂不讨论
- =int *lineinfo=
- =TString *source=
- =int linedefined=
- =int lastlinedefined=
- =GCObject *gclist=

元信息
- =lu_byte numparams= ，函数的固定参数个数
- =lu_byte is_vararg= ，函数的可变参数
- =lu_byte maxstacksize= ，函数运行时，最大使用的栈空间

数组结果
- =TValue *k= ，常量表
- =Instruction *code= ，字节码
- =struct Proto **p= ，内部其它函数定义
- =struct LocVar *locvars= ，局部变量信息
- =TString **upvalues= ，upvalue 信息
- 与 len size 相关的字段

对照之前对 vm 执行模型的讨论，code 和 k 就与之对应。

这里一个有意思的区别，在于 size 和 n。

上面提到的 5 个数组，都对应一个 size 字段，用于记录数组的大小。
同时，也对应一个 n 字段，用于记录当前数组已使用的大小（下一个空闲的位置）。

在分析的过程中，数组 size 值记录空间总长度，当空间不足时，会继续扩大分配。
而数组 n 值用于时刻标识下一个空闲索引，记录分析结果并自增，它的值比 size 小。

当最终分析结束时，将 n 值赋值给相应的 size 值，省略多余不用的空间，此时两者才会相同。

如此看来，n 值应该存放在 FuncState 中，但是存在例外的是 =lu_byte nups= 。

#+begin_src dot :file generator-fcode.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fcode[shape=record, label="
	      | | | | <n> | | |
	      ", xlabel="f->code"];

	fsizecode[label="f->sizecode", shape=plain];
	
	fspc[label="fs->pc", shape=plain];

	fspc -> fcode:n;
}
#+end_src

#+RESULTS:
[[file:generator-fcode.png]]

#+begin_src dot :file generator-fk.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fk[shape=record, label="
	      | | | | <n> | | |
	      ", xlabel="f->k"];

	fsizek[label="f->sizek", shape=plain];
	
	fsnk[label="fs->nk", shape=plain];

	fsnk -> fk:n;
}
#+end_src

#+RESULTS:
[[file:generator-fk.png]]

#+begin_src dot :file generator-fp.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fp[shape=record, label="
	      | | | | <n> | | |
	      ", xlabel="f->p"];

	fsizep[label="f->sizep", shape=plain];
	
	fsnp[label="fs->np", shape=plain];

	fsnp -> fp:n;
}
#+end_src

#+RESULTS:
[[file:generator-fp.png]]


#+begin_src dot :file generator-fupval.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fupval[shape=record, label="
	      | | | | <n> | | |
	      ", xlabel="f->upvalues"];

	fsizeupval[label="f->sizeupvalues", shape=plain];
	
	fnups[label="f->nups", shape=plain];

	fnups -> fupval:n;
}
#+end_src

#+RESULTS:
[[file:generator-fupval.png]]

#+begin_src dot :file generator-flocvars.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	flocvars[shape=record, label="
	      | | | | <n> | | |
	      ", xlabel="f->locvars"];

	fsizelocvars[label="f->sizelocvars", shape=plain];
	
	fsnlocvars[label="fs->nlocvars", shape=plain];

	fsnlocvars -> flocvars:n;
}
#+end_src

#+RESULTS:
[[file:generator-flocvars.png]]

相同的视角，来观察 FuncState。

#+caption: lparser.h
#+INCLUDE: ../lua-5.1.5/src/lparser.h src c -n 57 :lines "57-76"

暂不讨论
- =Proto *f=
- =struct FuncState *prev=
- =struct LexState *ls=
- =struct lua_State *L=

后续讨论
- =struct BlockCnt *bl=
- =int lasttarget=
- =int jpc=
- =int freereg=

中间结果
- =upvaldesc upvalues[LUAI_MAXUPVALUES]=
- =unsigned short actvar[LUAI_MAXVARS]=
- 其它 n 字段

两个数组是定长的，即 size 是固定的， =f->nups= =fs->nactvar= 用于对应其 n 字段。

#+begin_src dot :file generator-fsupval.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fsupval[shape=record, label="
	      | | | | <n> | | |
	      ", xlabel="fs->upvalues"];

	fssizeupval[label="LUAI_MAXUPVALUES", shape=plain];
	
	fnups[label="f->nups", shape=plain];

	fnups -> fsupval:n;
}
#+end_src

#+RESULTS:
[[file:generator-fsupval.png]]

#+begin_src dot :file generator-fsactvar.png
digraph  {
	node[shape=box];
	nodesep = 1.0;
	ranksep = .5;
	
	fsactvar[shape=record, label="
	      | | | | <n> | | |
	      ", xlabel="fs->actvar"];

	fssizeactvar[label="LUAI_MAXVARS", shape=plain];
	
	fsnactvar[label="fs->nactvar", shape=plain];

	fsnactvar -> fsactvar:n;
}
#+end_src

#+RESULTS:
[[file:generator-fsactvar.png]]

在编译过程中，所得到的结果会不断的存储入上述数组及其它字段中。

* generate

从某种角度看，编译过程就是规则间的同义转换过程。

代码生成，最终将符合语法规则的 lua 代码，生成为 vm 可执行的同义字节码，
这个过程是隐藏在语法分析下的艺术。

两个规则间可以进行同义转换的连接点，在于对 vm 的共识，
正因为编译器"懂得" vm，知晓字节码的格式与功能，知晓运行时的栈结构，
知晓 k 表 Gbl 表的读取方式，才能生成 vm 可执行的同义字节码。

这种共识贯穿在整个代码生成的过程中。

但是无论编译器如何了解 vm，编译时和运行时还是存在区别的。
代码生成时，只是想象存在一个假想的 vm，它在执行生成的所有结果。

所以代码生成这个过程是最为繁杂的，到 vm 真正运行时反而轻松了，只需要读指令，执行指令就可以了。

阅读代码生成相关的代码，笔者还没有精确地把握住其中的原理，只能提供几个原则给读者参考，
- 总体是语法制导翻译的过程
- 使用后缀方式的生成顺序，比如 a + b 按照 a b + 的顺序来转换生成
- 精确模拟 vm 的运行方式，包括栈运算，Gbl 表及其它

章节结束之后，读者可以多使用调试器分析示例代码，探索其中的奥妙。

* key concept

在仔细探索代码生成之前，先明确几个在生成过程中的重点。
  
** variable

从作用域来看，lua 中的变量有 3 类，分别为 =local upvalue global= ，
三者在底层的实现方式各不相同。

*** local
    :LOGBOOK:
    - Note taken on [2021-01-11 一 17:06] \\
      如何和运行时的栈关联起来？
    - Note taken on [2020-12-15 二 11:14] \\
    变量逆序查找，比如出现 local 覆盖的情况
    searchvar() lparser.c:207
    :END:

local 变量的活动范围（active），开始于在作用域中出现的那一刻，一直到作用域结束，
而作用域是有明显的栈特性的，新开辟作用域时入栈，离开作用域时出栈。

在一个作用域内，local 变量按照声明顺序入栈，离开作用域时全部出栈，变为 inactive 状态。

利用这个特性，lua 在编译时，在 fs 中用 actvar 和 nactvar 时刻记录着当前 active local 变量的状态。

比如如下示例代码，

#+begin_src lua
local a

do
   local b
   do
      local c
   end
end

do
   local d
   do
      local e
   end
end
#+end_src

在代码分析的不同时刻， =fs->actvar= 记录的栈状态是这样的，

#+CAPTION: active local scope & fs->actvar nactvar
#+begin_src dot :file generator-active-local-scope.png
digraph {
	rankdir = LR;
	
	code[shape=none, label=<
	      <table border="0" cellspacing="0">
	        <tr><td align="left" border="1" bgcolor="white">local a</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">do</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">    local b</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">    do</td></tr>
	        <tr><td port="fir" align="left" border="1" bgcolor="white">        local c</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">    end</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">end</td></tr>
	        <tr><td port="sec" align="left" border="1" bgcolor="white"> </td></tr>
	        <tr><td align="left" border="1" bgcolor="white">do</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">    local d</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">    do</td></tr>
	        <tr><td port="trd" align="left" border="1" bgcolor="white">        local e</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">    end</td></tr>
	        <tr><td align="left" border="1" bgcolor="white">end</td></tr>
	      </table>
	     >];

	fir[shape=record, label="
	      |<n>| c | b | a
	      ", xlabel="fs->actvar"];

	sec[shape=record, label="
	      || |<n> | a
	      ", xlabel="fs->actvar"];

	trd[shape=record, label="
	      |<n>| e | d | a
	      ", xlabel="fs->actvar"];

	fir -> code:fir;
	sec -> code:sec;
	trd -> code:trd;

	node[shape=plain];

	n1[label="fs->nactvar = 3"];
	n2[label="fs->nactvar = 1"];
	n3[label="fs->nactvar = 3"];

	n1 -> fir:n;
	n2 -> sec:n;
	n3 -> trd:n;

	nodesep = 1;
}
#+end_src

#+RESULTS:
[[file:generator-active-local-scope.png]]

上面只是粗略描述了 active local 变量的栈状态，而实际在 parser 内部，是通过两个数组来存储的。

#+CAPTION: actvar & locvars
#+begin_src dot :file generator-actvar-locvars.png
digraph {
	rankdir = LR;
	ranksep = 1;

	actvar[shape=record, label="
	      |<n> | <n3> 4 | <n2> 3 | <n1> 0
	      ", xlabel="fs->actvar"];

	node[shape=plain];
	
	n[label="fs->nactvar = 3"];
	nn[label="fs->nlocvars = 5"];

	n -> actvar:n;
	locvars:n -> nn[dir="back"];
	
	locvars[shape=record, label="
               |<n>  | <n3> \"e\" | <n2> \"d\" | \"c\" | \"b\" | <n1> \"a\"
	      ", xlabel="f->locvars"];

	actvar:n1 -> locvars:n1;
	actvar:n2 -> locvars:n2;
	actvar:n3 -> locvars:n3;
}
#+end_src

#+RESULTS:
[[file:generator-actvar-locvars.png]]

数组 =fs->actvar= 的元素是 =unsigned short= 类型，只用来记录变量的索引。
索引数组 =f->locvars= 中的元素，其中元素类型为 =struct LocVar *= 。

#+caption: lobject.h
#+INCLUDE: ../lua-5.1.5/src/lobject.h src c -n 262 :lines "262-267"

LocVar 主要记录变量的名字， =startpc endpc= 在字节码层面记录其活动范围。

*** upvalue

在 pascal 中，在 outer scope 的变量，可以通过 frame stack 去查找

但是在 lua 中，函数也是一种值，可以四处流转，说不定在什么地方调用
所以其 upvalue 不一定出现在 stack frame 上


#+begin_quote
对象是带函数的值
闭包是带值的函数
#+end_quote

#+begin_src lua :results output
local function outer()
   local a = 0

   local function inner()
      local b = 0

      a = a + 1
      return a
   end

   inner()

   return inner
end

local f = outer()

print(f())
print(f())
print(f())

local g = outer()

print(g())
print(g())
print(g())
#+end_src

#+RESULTS:
: 2
: 3
: 4
: 2
: 3
: 4

function 作为基础类型之一，可以作为普通变量，参数，返回值，赋值，而四处流转

这种情况下，和 local 作用域机制在一起，就会出现问题

a 的作用域在 outer 内部，同时被 inner 引用并修改，最终 outer 返回 inner

调用 outer，赋值给 f

按照语义，f 应该是内部的 inner func，每次调用都得到 a 的自增值

调用 3 次，得到 1 2 3

问题在于，a 只作用在 outer 内部，而 f 在 outer 外部，已经离开了 a 的作用域，
在这种情况下如何保证语义的正确？

这便是闭包机制的由来，a 对于 inner 而言，不是 local，而是 upvalue 类型。

这也是 lua 中为何 func 不是 func 而是 closure 的原因，func 及 upvalue 组成了 closure，
所有 func 在运行时都封装为 closure 来运行，其中重要的原因就在于分配 upvalue 空间。

#+CAPTION: 17 upvalue at runtime

再调用 outer，赋值给 g，调用 3 次，得到一样的结果，从中可以得到 upvalue 作用于 active 和
dead 状态的区别。

*** global

前面提到了 local 变量的作用域，以及 upvalue 出现的原因及解决方法。

其中隐含的一点，外层变量对于内层可见，假如强制设定外层对于内部不可见，便不会有 upvalue 的问题。

对于可见的情况，对于当前引用的变量，自然有一个查找的过程。
和嵌套相反，是层层向上寻找的过程。

变量
在本层可以找到的，为 local
在本层之外可以找到的，为 upvalue
所有层都无法找到的，为 global

global 的概念解决了两个细节问题
为什么顶层的 function 是没有 upvalue 的？
因为在本层找不到的变量，向上已经没有层级，只能是 global

setfenv 的概念
函数的运行环境，即是 global，在编译的 chunk 运行之前，设定 global 的值，
可以影响内部对 global 值的引用，从而实现不同的运行效果。


在实现中，global 是单独于基层的 closure 存在的，是运行状态的一部分
所以不存在作用域的问题，始终在顶层。


#+begin_src lua :results output
local function outer()
  a = 10

  local function inner()
    a = a + 1
    return a
  end

  return inner
end

local f = outer()

print(f(), a)
print(f(), a)
print(f(), a)
#+end_src

#+RESULTS:
: 11	11
: 12	12
: 13	13

#+CAPTION: 18 global at runtime

** register
   :LOGBOOK:
   - Note taken on [2020-12-07 一 14:01] \\
   如何调度寄存器？
   :END:

register is stack

parse 生成 bytecode，关于寄存器的使用，只是从表面上生成相应的索引
因为 parser 知道自己使用了哪些寄存器，还有哪些可以使用，这些信息是 运行时的 vm 所不知道的

move a b

但是并不分配寄存器的空间，只是用来调度使用哪个寄存器
因为这是编译时，而不是运行时

local 变量 和 中间结果

** expdesc
    :LOGBOOK:
    - Note taken on [2021-01-11 一 15:42] \\
      把一些属性附加到代表语言构造的文法符号上，从而把信息和一个语言的构造联系起来
    - Note taken on [2020-12-07 一 17:34] \\
    各个状态如何发生作用？
    :END:

递归下降
语法制导
后缀方法
配合 vm opcode 共同作用的结果


 exp desc

 exp 基本运作单元

 desc 描述其属性，是 ast 到 code 的纽带

 #+INCLUDE: ../lua-5.1.5/src/lparser.h src c :lines "19-46"



 - VVOID 什么都不做
 - VNIL  nil 值
 - VTRUE
 - VFALSE bool
 - VK    在 k 表中的值
 - VKNUM 数字字面量

 没有 string 类型，因为在读取的过程中，直接将其放入 k 表中，变成 VK 类型了


 TODO desc 到 reg 的轨迹追踪？


 discharge2reg
 lcode.c:343

 操作的只是 exp 相关的类型

 exp 需要解析到值，而 var 需要解析到位置

 reg 是目的地

 VRELOCABLE 说明 A 本身还不确定，在 discharge 的时候，补全到 A 位置

 VNONRELOC 则说明本身已经解析到栈中 或 A 已经正确

 | exp desc   | gen code                                 |
 |------------+------------------------------------------|
 | VNIL       | loadnil                                  |
 | VTRUE      | loadbool                                 |
 | VFALSE     | loadbool                                 |
 | VK         | loadk                                    |
 | VKNUM      | loadk                                    |
 | VRELOCABLE | get its code and change A to reg         |
 | VNONRELOC  | reg != self reg, move; otherwise nothing |
 | VVOID      | nothing                                  |
 | VJMP       | nothing                                  |


 dischargevars

 | exp desc | discharge                                            |
 |----------+------------------------------------------------------|
 | VLOCAL   | to VNONRELOC                                         |
 | VUPVAL   | gen code GETUPVAL, A is uncertain, to VRELOCABLE     |
 | VGLOBAL  | gen code GETGLOBAL, A is uncertain, to VRELOCABLE    |
 | VINDEXED | free table and idx, gen code GETTABLE, to VRELOCABLE |
 | VCALL    | to VNONRELOC, store call code A value                |
 | VVARARG  | set B to 2? to VRELOCABLE                            |

** how freereg & freeexp works

#+CAPTION: page 19 & 20

freereg 的作用

在栈的特性上，更深入的理解

何时分配，何时回收

根据抽象栈演算的顺序来

和 nactvar 的关系


* ChunkSpy

以实例为基础的探索
基础方法
   
make spy

make inspect

chunkspy 中 .local .const 的概念对应

#+begin_example
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 3 stacks
.function  0 0 2 3
.local  "a"  ; 0
.local  "b"  ; 1
.local  "c"  ; 2
[1] return     0   1      
; end of function
#+end_example

line 1
level 1 指的是第一层级
function [0] 表明是当前层级的第 1 个函数（以 0 开始索引）

line 2
0 个 upvalue
0 个参数
0b010 接收可变参数
3 需要分配栈容量，2 是最小值，来源于在不断的运算过程中，栈增长减少，遇到的最大值

line 3
和 line 2 相同，2 是 3 的注释

line 4 5 6
.local f->locvars 内容

line 7
f->code 指令
最终一行总是默认生成一条 return 指令
这里只有一条 return，说明代码并没有生成代码

line 8
function 结束注释



* statement
  :LOGBOOK:
  - Note taken on [2020-12-09 三 13:35] \\
  先从 stat 开始分析，将得到的经验抽象为内容。
  :END:

- 原子性
- 依赖性
- 实例分析
- 生成模式

递归结合是无限的
只讲解 atom ，组合交由读者探索


** function

compile time

enf 结构

body 方便定义匿名函数

func 有同名和匿名两种
从 ebnf 中可以看出，两者只差在 NAME
几乎全部由 body 处理
包含了参数，函数体等全部
动态类型，名称与值的绑定，所以由 body 来处理全部

#+CAPTION: 29 function


body 过程不过是参数和 chunk 的递归过程

*** upval
    :LOGBOOK:
    - Note taken on [2020-12-15 二 14:08] \\
    需要更明显的图示
    :END:

和 closure 同一级的变量被引用，使用 move 指令
>= 级的变量，使用 getupval 指令


move A B

A 无用，B 指代 local 的 active 栈索引

getupval A B

A 无用，B 指代上层 closure 中 upval 表的序号

getupval 一直向上链，总会找到 local 对应的位置


Q: f 没有明显引用 a，但是但 a 却存在于 f 的 upval 数组中？

A:

singlevar
singlevaraux

从底层向上寻找，从 f 向上找到 a，调用 indexupvalue (lparser.c:183)
作为 upval 使用，而非 local，在 index upval 的过程中，
添加到 f 的 upval 表中

新增 upval 并返回 upval 对应的索引

*** vararg
    :LOGBOOK:
    - Note taken on [2020-12-15 二 13:38] \\
    在 vm 运行时，再详细深入栈过程
    :END:

lobject.h:256

|        4 |        2 |      1 |
|----------+----------+--------|
| NEEDSARG | ISVARARG | HASARG |


在 lua5.0 中，没有 ... 的表达式，只能在参数定义时使用

而在内部引用 vararg 时，通过变量 arg 来使用

arg 是一个 table，内部以数组形式存储了 vararg

arg.n 是数组的长度

#+begin_src lua
function foo(a, b, ...)
  local arg = {...}
  arg.n = select("#", ...)
end
#+end_src


lua5.1 默认有对上面形式的兼容性

NEEDSARG 表明是否在内部构造 arg 的值

ldo.c:215

lua5.1 判断，如果内部出现了 ... exp，就不使用 arg，
NEEDSARG = 0

lparser.c:756

HASARG 用于在计算 nparam 时很方便，直接使用 & 运算就可以

lparser.c:571

ISVARARG 和 HASARG 应该是相同的？
chunk main func 只有 ISVARARG 标志


无即是 0
chunk func 是 2
不引用 arg 是 3
引用 arg 是 7


存储在 proto
- numparams，vararg 不算一个参数
- is_vararg

** local assignment

#+begin_src bnf
localstat ::= LOCAL NAME {`,' NAME} [`=' explist]
localstat ::= LOCAL FUNCTION NAME body
#+end_src


#+begin_src lua
local function f()
end

local f = function ()
end
#+end_src

localstat 有两种情况，func 的情况之后到 function 部分再讨论。
另一种情况是局部变量声明，分为是否赋值两种情况。

localstat vs localfunc

*** no assignment

#+begin_src lua
local a, b, c
#+end_src

#+begin_example
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 3 stacks
.function  0 0 2 3
.local  "a"  ; 0
.local  "b"  ; 1
.local  "c"  ; 2
[1] return     0   1      
; end of function
#+end_example

考虑如上代码，声明局部变量 a。

没有生成代码，毕竟没有任何运算或者操作

所以只存储了 local 变量的信息

#+CAPTION: 18 local no assignment

lparser.c:143
=registerlocalvar= 是操作 f->locvars 的过程

lparser.c:163
=new_localvar= 是操作 fs->actvar 的过程

先注册，再存储相应的索引


expdesc 为 VVOID，因为没有 exp，没有赋值
e 记录的是最后一个 expr 的属性



nvars = nexps


=adjust_assign= 进行左右数量的调整

多余空间置为 nil

TODO 因为 luaK_nil 的优化过程，没有生成代码

调整了 freereg 的值，是进行中间运算的安排的



=adjustlocalvars= 调整 nactvar 的值，并设置相应的 startpc

*** with assignment

**** TODO multret

TODO 有 multret 的再讨论

下面的情况是合法的，只不过前面的 multret 只返回一个值，而最后的可利用多个值

#+begin_src lua
local a, b, c = ..., ..., ...
#+end_src

**** normal

没有赋值，等于 nexps = 0 的最小情况

var exp 的数量关系

exp 多则舍弃
var 多则置 nil

#+begin_src lua
local a, b, c, d, e = 10, "second", nil, true, false
#+end_src

#+begin_example
; function [0] definition (level 1)
; 0 upvalues, 0 params, 2 is_vararg, 5 stacks
.function  0 0 2 5
.local  "a"  ; 0
.local  "b"  ; 1
.local  "c"  ; 2
.local  "d"  ; 3
.local  "e"  ; 4
.const  10  ; 0
.const  "second"  ; 1
[1] loadk      0   0        ; 10
[2] loadk      1   1        ; "second"
[3] loadnil    2   2      
[4] loadbool   3   1   0    ; true
[5] loadbool   4   0   0    ; false
[6] return     0   1      
; end of function
#+end_example


下面来看赋值的情况，3 个变量均衡赋值。

根据语法描述，左侧 var 结束之后，右侧部分都作为 explist 来解析，最终再完成赋值

是典型的后缀形式的语法制导。

这里先不重点讲 explist -> expr 的解析过程，只用几个基本类型，在 lex 阶段就可以确定的。

lparser.c:599

可确定 expr 的描述 v




使用 luaK_exp2nextreg

TODO freereg 的指导作用
TODO 为何这样是正确的，什么时候进行回收？

按照 freereg 所指的顺序，依次向上存储

exp2reg freereg

discharge2reg，将 exp 对应到 reg 即 local 中

其中 VKNUM 直接存储入 k 表，生成 loadk 指令，使用 k 索引

TK_STRING 在之前已经变成 VK，加在 k 表中的索引，同样生成 loadk 指令

解析之后，exp 类型变为 VNONRELOC，info 中存储结果所在的寄存器


在这个过程中，已经生成了 相关的 load 指令，到 freereg 的位置
因为 exp 出现的顺序，和 var 出现的顺序对应，巧妙完成了赋值

**** k table

通过 numberK 和 stringK 方法

在 addk 过程，
fs->h 是一个 table，用于对 f->k 进行反向索引
先在 h 中查找，是否已经有相应索引，可以直接返回
如果没有，则新增一项

fs->nk++


lcode.c:229-278

k 表只存储如下几种常量
- nil
- bool
- number
- string

nil bool 在赋值时并没有使用 loadk，而使用 loadnil loadbool 指令
插入 k 表用在别的地方
- index
- binop
- compare


** nonlocal assignment

exprstat -> assignment stat

*** global

#+begin_src lua
a, b, c = 10, 20, 30
#+end_src

进入 primaryexp prefixexp 查找的时候，TK NAME 要进行 singlevar 查找

赋值为 VGLOBAL，且 info 存储了名字对应的 k 表索引
和 expkind 的注释不符合？



进入 assignment，按照 ebnf ，本身是嵌套的
进入之前，先将 v prev 设置为 NULL，后面全部链接起来


LHS_assign 结构，在 expdesc 的基础上，添加了 prev 指针

在 多个 , 之间的 var 全部链接起来

其中可赋值的类型为
VLOCAL VUPVAL VGLOBAL VINDEXED
由 primaryexp 决定


赋值阶段，在每个递归层次，用 luaK_storevar 来存储



var ex

先 discharge ex
再生成 SETGLOBAL，使用 info 中存储的 k 索引
gbl[kst[info]] = R(A)




luaK_exp2anyreg

只需要解析到 reg 就可以，临时使用，赋值之后就废弃


exp 可能是 var，也可能是 值
但是通过 dis var 是保险的

默认依然使用 exp2nextreg，只不过在之前，添加了解析 jump 的部分

exp2nextreg，存储在 freereg 之后

exp2reg，存储到指定 reg

其中解析了 jump 相关的内容

最终成为 VNONRELOC


*** upvalue

#+begin_src lua
local a = 10

function f()
  a = 20
end
#+end_src

和 global 相似

*** indexed

a.b   a['b']
是相同语义

a 必须是 table，语义才正确


gettable 中，之所以使用 RK(C) 这种方法，是因为索引值未必是 constant，也可能是
一个表，一个函数，等其它值，这种值只能由 寄存器 存储

同时，加上了 k，也可以节省临时寄存器的使用

如果超出了 k 表的范围，大于 256，需要临时先加载入 寄存器

** do

- block vs chunk
  - 整体文件按照 chunk 来解析，chunk 是入口
  - block ::= chunk，但具体使用方式要根据语句的类型来分析
    并非所有引用 chunk 的地方都会像 function 结构使用 chunk 会影响 fs 结构，
    更多依赖 chunk 递归处理语句的便利
- 分类
  - loop 中
  - 非 loop 中

blockCnt
- previous
- nactvar，进入 block 前 nactvar 的个数
- isbreakable，是否用在循环中，从 bnf 中可看到
- breaklist，chain of jump out of the loop，在 while 时深入
- upval，bool，当前作用域中是否有 local var 作为 upval，在 for 时深入

明显的作用域分隔作用

enterblock
leaveblock

在进入时，nactvar 记录 active local var 的数量，
block 内新的 local var 会在离开时，全部释放
符合作用域的原则
内部使用，销毁，不污染外部

#+CAPTION: 24 do block

作用域记录在 fs 中，最终要体现到 f 中
最终在 do 之外，使用 b，会顺着 a 0 的顺序向后，b 1
说明前面的所有变量已回收

虽然有多个 block 相隔，但是在最内层进行变量查找的时候，上层的所有 act local var 都
属于同一个 fs，查找 a 的时候，a 的类型为 local，直接进行了修改
a 并不是 upval，可见 upval 只针对 function 而言

非 loop 只有 nactvar 起作用

loop 情况，到 while for 具体分析。

** if
   :LOGBOOK:
   - Note taken on [2021-01-08 五 13:51] \\
     因为分析从左向右，从前至后的，所以对于一些结构需要特别的方法来处理
     比如 if 分支的处理，回填 jmp 地址
   :END:

顺序解析的难题之一
分支

- jump chain resolve

#+CAPTION: 25 if else code pattern


concat

patch

patch to here, concat

patch to list, discharge right now to target

they are the same

dischargejpc




luaK_jump 时，使用 jpc 重置的技巧，防止在生成 jump 时，触发 dischargejpc

*** if

dischargejpc
负责从当前 pc 解析 jump chain

隐藏在 luaK_code 中


问题添加 return 0 1 的原因

#+CAPTION: 26 if chain

*** if else

#+CAPTION: 27 if else chain

*** if elseif

#+CAPTION: 28 if elseif chain

*** if elseif else

#+CAPTION: 29 if elseif else chain

** while

#+CAPTION: 30 while pattern

block

breakable  1
这样其中才可以生成 break 语句

breaklist
用于记录 break 语句，chain 到 block 外的第一条语句

enterblock 自然生成 0 block

相当于有双层 block

*** break

#+CAPTION: 30 break in while
     
** repeat

repeat    

#+CAPTION: 31 repeat

break 同 while 时的表现相同


不过对于 upval，有自己的处理方式


因为 while 在 cond 中不能定义新的 local var
而 repeat 的 block 中可能先定义 local var
再被其中的 func 引用，而 i 在不断变化，就需要及时 close




#+begin_src lua :results output
local t = {}

local c = 0

repeat
   c = c + 1

   local i = c

   t[i] = function ()
      return i
   end
until i > 10

for i, f in ipairs(t) do
   print(f())
end
#+end_src

#+RESULTS:
#+begin_example
1
2
3
4
5
6
7
8
9
10
11
#+end_example

进行 upval 判断的原因

每个 func 记录的都是 i，但是每次 loop 结束都进行了 close，


#+CAPTION: 31 repeat upval


** for

for loop 特别开发了底层指令来处理，而 repeat 和 while 则没有相应的指令。
依然是通过 jmp 来实现的。

分为两种

数字迭代 fornum

#+begin_src lua
for i = 1, 10, 2 do
  print(i)
end
#+end_src

通用迭代 forlist

#+begin_src lua
for k, v in pairs(t) do
  print(k, v)
end
#+end_src

*** fornum

隐式生成的变量，用 ( 来标识，是不会与正常 lua 代码中分析得到的 NAME 冲突的
因为 lex 规则的限定

#+begin_example
.local  "(for generator)"  ; 0
.local  "(for state)"  ; 1
.local  "(for control)"  ; 2
#+end_example

#+CAPTION: 32 for and upval

*** forlist

#+begin_src lua :results output
local g, s = pairs({1,2,3})

for k, v in g, s, nil do
  print(k, v)
end
#+end_src

#+RESULTS:
: 1	1
: 2	2
: 3	3

#+CAPTION: 33 for and upval

upvalue 同 fornum

** function call

function call

func 在栈的底部，参数向上累加

调用结果，返回值，从栈的 func 处开始向上覆盖

#+CAPTION: 34 func call

funcargs()
lparser.c:609

并不复杂

*** self

#+begin_src lua :results output
local o = {}

function o.f(self)
  print(self)
end

function o:f()
  print(self)
end

o.f(o)

o:f()
#+end_src

#+RESULTS:
: table: 0x55bb5b89d270
: table: 0x55bb5b89d270

self 指令，只是一种优化方式



luaK_self()

lcode.c:503

结合 op self 的语义，并不复杂

#+CAPTION: 35 self

self 只是为 call 做准备，将对象提前放到相应位置


** ret

return 在 chunk 中发挥作用
从当前 closure 中返回

return 必须是 chunk 的最后一个语句

按语句含义返回值，至于有多少值被利用，则根据 opcode 生成过程中决定的

opcode 容易理解

retstat()
lparser.c:1238

*** tailcall

#+begin_src lua
-- tail call
return f()
-- not tail call
return a, b, f()
#+end_src

ret 中只有单独的 function call

进行栈优化

lparser.c:1249

tailcall 本身已经有了 return 的语义


* practice

理想的 vm
独立，lua 实现对 vm 做了协同的妥协

** arithmetic

- 优先级

lua 在进行解析时，没有进行关系运算的实时解析，但是对 constant 算法运算有编译时执行

如 `local a = 5 > 2` 和 `local a = 1 + 2` 的区别

前者需要生成 jmp 指令，但是后者，直接是 loadk 0 0 ; 3

** logic

- and or

** constructor

- setlist always consistent, diff with settable

