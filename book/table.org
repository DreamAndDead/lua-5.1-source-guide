#+SETUPFILE: setup.org

#+TITLE: table
#+DATE: <2020-12-30 三 11:53>

初次接触 lua 的人都有困惑，
多数动态语言都会内建 dict 和 array 的概念，而 lua 用 table 同时表示这两个概念。

所谓 dict 不过是 kv 存储，从某种角度来看，可以将 array 看作 k 是整数的一种特殊情况。

本章就来从源码角度认识 lua 中的 table。

* structure

#+begin_src C -n 338 -r
typedef struct Table {
  CommonHeader;
  lu_byte flags;  /* 1<<p means tagmethod(p) is not present */       (ref:flags)
  lu_byte lsizenode;  /* log2 of size of `node' array */             (ref:lsizenode)
  struct Table *metatable;                                           (ref:metatable)
  TValue *array;  /* array part */                                   (ref:array)
  Node *node;                                                        (ref:node)
  Node *lastfree;  /* any free position is before this position */   (ref:lastfree)
  GCObject *gclist;
  int sizearray;  /* size of `array' array */                        (ref:sizearray)
} Table;
#+end_src

table 的结构并不复杂，除去 CommonHeader 和 gclist，剩余的字段可分为 3 部分。

dict 相关
- [[(node)][Node * node]] ，kv 存储的数组
- [[(lsizenode)][=lu_byte= lsizenode]] ，数组的大小，用 log2 表示
- [[(lastfree)][Node * lastfree]] ，在数组中从尾向前，第一个空闲位置的指针

array 相关
- [[(array)][TValue * array]]
- [[(sizearray)][int sizearray]]

metatable 相关
- [[(metatable)][struct Table * metatable]]
- [[(flags)][=lu_byte= flags]]

从结构中可以发现，table 并不只是单纯的 dict 结构，为了效率，在内部也用 array 的方式进行辅助存储。

下面就 3 个部分，分别讨论

* dict

在 lua 中，用 table 表示 dict 概念，有非常大的自由度。

使用 k v 存储时
- k 不能是 nil
- 若 v 是 nil，表示从 dict 中删除 k v
- 除此之外，k v 可以是任意值，无论是 function 还是 string

本质上来看，这就是用 TValue 统一表示所有“值”所带来的好处。
这一点从 Node 结构中可以清楚的看出来。


#+begin_src C -n 323 -r
typedef union TKey {
  struct {
    TValuefields;
    struct Node *next;  /* for chaining */
  } nk;
  TValue tvk;
} TKey;


typedef struct Node {
  TValue i_val;
  TKey i_key;
} Node;
#+end_src

#+caption: dict node
#+begin_src ditaa :file table-node.png :cmdline -E
    Node                                 TKey
+-----------------+               +-- +------------------------+ --+
| TValue i_val    |               |   | Value value            |   |
+-----------------+               |   +------------------------+   | TValue tvk
|  TKey i_key     |            nk |   | int tt                 |   |
+-----------------+               |   +------------------------+ --+
                                  |   |  next cBLK             |
                                  +-- +------------------------+
#+end_src

#+RESULTS:
[[file:table-node.png]]


Node 代表一个 k v 存储，k v 分别用 =i_key= 和 =i_val= 来表示。
=i_val= 本身是 TValue， =i_key= 是 TKey。

TKey 本身是一个 union，其中用 tvk 来索引本身的值，即 TValue。
另一项 nk 则添加了 next 指针，辅助在 Node 数组中做链接。
所以本质上， =i_key= 也是 TValue。


dict 表示的是多个 kv 的集合，在 table 内部，所有 kv 经过相应的安排，存储在 Node 数组中。

比如下面的代码，在 table 内部将可能会如此表示。

#+begin_src lua :results output
local t = {}

t[print] = true
t["name"] = "print"
t["return"] = 0
t[true] = false
t["tool"] = "dot"
#+end_src

#+caption: dict structure
#+begin_src dot :file table-dict.png
digraph {
	node[shape=record, width=.1, height=.1];
	
	nd[label="
	   {<i> index | <v> i_val | <k> i_key} |
	   {<i0> 0| <v0> true | <k0> #f print} |
	   {<i1> 1| <v1>  | <k1> } |
	   {<i2> 2| <v2> \"print\" | <k2> \"name\" } |
	   {<i3> 3| <v3> 0 | <k3> \"return\" } |
	   {<i4> 4| <v4>  | <k4> } |
	   {<i5> 5| <v5>  | <k5> } |
	   {<i6> 6| <v6> false  | <k6> true } |
	   {<i7> 7| <v7> \"dot\"  | <k7> \"tool\" }
	   "];

	sz[label="lsizenode = log(8) = 3", shape=none];

	lf[label="Node * lastfree"];
	n[label="Node * node"];

	n -> nd:i0:nw;

	lf -> nd:i5:n;
}
#+end_src

#+RESULTS:
[[file:table-dict.png]]

至于 kv 存取的方式，在 get set 小节详细讨论。


有了上面的理解，相关的宏也就容易理解了。

#+caption: ltable.h
#+INCLUDE: ../lua-5.1.5/src/ltable.h src c -n 13 :lines "13-19"

** DRAFT main position
   :LOGBOOK:
   - Note taken on [2020-12-03 四 11:53] \\
   - TODO avoid -0?
   :END:

另外，需要一种方法，决定相应的 node 存储在什么位置，这一点通过 hash 来计算。

相应 node 的位置称为 main position。

get 和 set 之前，必须先找到对应的 main position 才能进一步进行下一步操作。

前面提到，除了 nil，其它 7 种类型都可以作为 key

对于相应的类型，分别计算其 hash 值
- bool，直接取 0 1
- string，使用其自身的 hash（复习 string chapter）
- 其实分为两部分处理，在 get 方法中，如果 num 是 int 类型，可直接使用 number 值，使用 getnum 进一步处理
  如果不是，则是浮点，不能作用数组来理解，将 double 从位角度，分拆为 unsigned int 来计算和
- 其它类型，将指针地址强制转换为 int 作为 hash
  其中 mod (size - 1) ，地址一般是对齐的，减小碰撞的概率，
  =| 1= 是避免出现 mod 0 的情况
  - lightudata 和 gc 各自的指针

#+INCLUDE: ../lua-5.1.5/src/ltable.c src c -n 50 :lines "50-64"

#+INCLUDE: ../lua-5.1.5/src/ltable.c src c -n 96 :lines "81-114"

** DRAFT set key
   :LOGBOOK:
   - Note taken on [2020-12-03 四 11:38] \\
   hash use a mix of chained scatter table with brent's variation?
   :END:

~luaH_set~ 中只有 key 参数，而没有 v 参数。
它只返回 key 在 table 中相应 node 的 tvalue *，至于如何修改，则由外部调用者决定

并不是桶的实现，因为如果出现碰撞，则找到一个 freepos，用 next 串联起来，相当于是数组链表

=luaH_set= 进行基本的检测，如果找到位置，直接返回

#+INCLUDE: ../lua-5.1.5/src/ltable.c src c -n 494 :lines "494-506"

若没有，则使用 =newkey= 新建 node，其中 key 为参数，value 则作为返回值

=newkey=
- 先找到 key 的 mp
- 如果 mp 上已经有元素
  - 如果它已经在其位置上，则将 key 放置在 freepos，链接起来
  - 如果它不在位置，则由其 mp 位置，一直 next 找到其 previous 位置
    将 key 放在 mp 位置，另外放在 freepos，并改变指针的指向

#+INCLUDE: ../lua-5.1.5/src/ltable.c src c -n 392 :lines "392-430"

#+CAPTION: new key process

** DRAFT get

get 方法的核心很简单，先计算得到 main pos，再一路 next 寻找相同的 key，
找到则返回其 node 中存在的 v，没有则返回 nil

#+INCLUDE: ../lua-5.1.5/src/ltable.c src c -n 466 :lines "466-492"

* DRAFT array

array 默认的索引从 1 开始。

#+begin_src lua
local a = {1, 2, 3, 4}
assert(a[1] == 1, "index start from 1")
#+end_src

当用 table 来表示 array 的概念，默认索引从 1 开始。

相应的，struct Table 中的 TValue *array 只存储正整数索引（>= 1）对应的值。

首先，在 C 语言中，直接通过数字索引到数组的元素效率是非常高的，

将部分数字索引的 kv 放在 * array 中，将其索引对应起来，提高存取效率。

1 -> 0
2 -> 1

有 1 个位置偏移。

其次，可以节省空间，因为 node 中的 key 和 val 两个部分，但是如果用 array 来存储，
就节省了 key 的空间。


采用这样的安排后，一个主要问题就出现了，使用时候用 array 部分，使用时候用 node 部分？

如果

#+begin_src lua
local t = {1, 2, 3, 4}
#+end_src

这样紧密的情况下，全部使用 array part 来存储，自然效率是最高的，完全看作一个数组。

如果

#+begin_src lua
local t = {1, 2, 3, 4, [1000] = 1000}
#+end_src

其中全部是整数索引，但是最大的索引是 1000，

如果这种情况下，使用 1000 大小的 TValue 来存储就不划算，中间空余所浪费的空间太多了
比如 70， 900，没有明显设置的值，如果直接索引就是 nil 值。


lua 基于这样的思路，使用一种权衡的的方式来决定使用多大的 array 来存储整数索引的 kv。

找到一个最大的整数 n，其中 0 到 n 之前至少有 n/2 个整数是有值的。
这样至少可以保持 50% 的利用率。


array 在 table 中，只是单纯用 TValue 数组来存储，
- TValue * array，存储
- int sizearray，当前 array 的空间大小

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c -n 338 :lines "338-349"


与 dict 部分相同，array 也有 2 个核心方法
- get
- set

** get

本质上，get 返回的是 相应的 key 对应的 v 的存储空间的指针
如果 table 中从没有这个 key，则返回 luaO_nilobject(它是一个指针，而不是值)

在 =luaH_get= 中，对于 number 做了特殊处理
- 如果 key 是 number 和 int，使用 =luaH_getnum=
  是浮点，则正常使用 =hashnum= 来计算

在 =luaH_getnum= 中，在 1 - sizearray 范围内，可以直接索引，即所谓 array part 区域的指针
它是一定不同于 luaO_nilobject 的

否则，还是通过 =hashnum= ，从 dict 部分，顺着 next 进行搜索

如果存在相应的 key，则返回相应的存储空间指针，
没有，则返回 nilobject

** set
   :LOGBOOK:
   - Note taken on [2020-12-03 四 14:44] \\
   nil 应该是删除键来理解，对于 array part 是不可能删除空间的
   对于 dict 部分，是如何处理删除的？可能只是在 rehash 的时候发生
   - Note taken on [2020-12-03 四 14:43] \\
   dummynode 的作用？
   dummynode 用于表明可用的空间，还没有 key 来使用其空间
   与之相对的， deadkey 只是由 gc 来处理的，标识 deadkey 是当值为 nil 的时候
   但是这部分空间仍然是被占据的
   :END:

在 =luaH_set= 中，先通过 get 来寻找存储空间

通过对 get 的理解，

p != luaO_nilobject

就容易判断了

对于 num，假如在 array part ，则一定返回数组位置，
不在，则像 dict 一样查找，返回相应位置

get 只关注位置，而不关注位置上对应的值

如果没有相应的 key，就使用 newkey 来插入 node（在 array part 的 num 是不可能使用 newkey 的）

这样看来，set 和 get 区别，只是多了 newkey 部分，确保一定返回一个 key 的位置。

* DRAFT other method

** next
   :LOGBOOK:
   - Note taken on [2020-12-03 四 15:44] \\
   TODO deadkey?
   deadkey maybe key with nil value?
   :END:

#+INCLUDE: ../lua-5.1.5/src/ltable.c src c -n 116 :lines "116-180"

=luaH_next=

被 lapi.c lua_next 使用，实现 next 功能
遍历所有元素

findindex，意义是返回 key 的下一个位置
- nil，返回 -1，意味着从头开始，其后访问的所有元素都是 k v 非 nil 的值
  回到 next 中，则访问到 0
- 若是整数，且在 sizearray 范围内，直接 -1 返回，因为 C 索引的关系
- 计算 mp node
  - 如果 node 和 key 相同
  - 或者 如果是 deadkey 但是和 key 的 gc 部分相同，则可认为寻找到
    返回 sizearray + node 中的偏移
    否则在 next 链表中寻找
- 未找到，则用 error 处理（TODO 如何不影响继续运行？）


next
- 通过 findindex，一个 key 会返回平铺序列下的索引

  #+begin_example
  aaaaaaaaaaadddddddddddddddd
  -----------+---------------
  #+end_example

- next 通过这个索引，++，以数组的方式，索引下一个非 nil 值
  - key <- 下一个索引对应的 key
  - key+1 <- 当前 key 对应的 value
- TODO detail 从数组过渡到 dict 的时刻
- TODO 在 dict 时刻如何与 ++ 结合起来
- 对于 dict 部分
  - key <- 当前 key index 对应的 key，在下一轮中，会 ++ 递增
  - key+1 <- 当前 key index 对应的 value


对应 next api，next 每次返回两个值，key 和 value
当 key 为 nil 时，TODO 意味着结束？

TODO 当 next 返回 0 时，意味着结束，上层一定进行了封装，以符合 lua 上层封装的 api

这里直接进行了栈操作，参考 c api

** rehash
   :LOGBOOK:
   - Note taken on [2020-12-03 四 17:49] \\
   TODO resize 操作
   - Note taken on [2020-12-03 四 17:46] \\
   TODO 理解 computesizes
   :END:

在 newkey 进行插入的时候，如果发生了空间不足
就会引发 rehash 操作

因为不同于 hash bucket，允许碰撞插入

table 是数组链表的形式，没有空间就没办法了，只能进行扩展。


入口是 rehash 方法
- 先进行 array 部分的统计
  这里的统计很巧妙，使用 log2 数组进行统计，a[i] 表示数组索引在 2^(i-1) - 2^i 的数量
  - 先统计 array part 的数量
  - 再统计 dict part 的数量
  - 不要遗漏最新要添加的值（没有判断去重？和调用 rehash 的时机有关，在 newkey 的时候，必定是不会重复的）

computesizes，计算新的 array part 的大小，需要一些理解

twotoi/2 < *narray 的条件，是因为如果不符合，则 twotoi 一定不符合
因为其中所有元素小于 size 的一半，一定不符合 array size 的选择

if a == *narray break

是一个优化，如果元素出现的非常密集，在前方
继续统计也没有意义，nums[i] 都是 0，（好像不完全正确？）

累计的应该是 1 2 4 8 之类

相当于，如果 a == *narray，则 a 最大为 twotoi

a 统计的是 < 2^i 的个数 == twotoi

既然已经统计结束，则下一轮，twotoi * 2 必定大于 a 的 2 倍

不符合查找条件


得到大小之后，进行 resize 操作

** len

如何确定 table 的长度？

长度是针对 array 的含义而言的

getn，含义针对于数组，因为并没有对 dict 进行搜索，只针对整数索引
- 先取得 sizearray 的大小
  - 如果最后的值是 nil，就要在数组中搜索出一个边界，使用二分法，找到 i j
    i 不是 nil 而 j 是 nil
    i 就是所谓的长度
  - 若数组是满的
    - 没有 dict 部分，直接返回
    - 有 dict 部分，则继续搜索，因为可能有部分整数值，在 dict 部分存储
      - 先 2 倍进行扩张
	- 如果超过最值，bad purpose?
      - 在 i 和 j (2 * i) 中进行 2 分，找到一个边界值




#+begin_src lua :results output
t = {1,2,3,4,5,6}
print(#t)

t[3] = nil
print(#t)

t[6] = nil
print(#t)
#+end_src

#+RESULTS:
: 6
: 6
: 2

=#= 本身的行为，在 array 有空洞的时候，对于不理解底层机制的用户，表现出的行为是“不确定的”

* DRAFT metatable

tagmethod cache

机制不在这里发生作用

* DRAFT weaktable

* DRAFT practice

new/free

get/set num/str

考虑将 rehash 的部分放到这里，非重点

** print table value
