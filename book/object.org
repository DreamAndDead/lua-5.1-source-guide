#+SETUPFILE: setup.org

#+TITLE: object
#+DATE: <2020-12-23 三 11:59>

lua 是一种动态类型语言，类型不存在于变量中，而存在于值本身。

语言中定义了 8 种类型的值
- nil
- bool
- number
- string
- table
- function
- userdata
- thread

虽然章节名称为 object，和源代码的名称相同。
但是通常都翻译为“对象”，容易与 OOP 中的对象概念混杂在一起。
在本章，更乐意将其译为“值”。

从某种角度而言，程序就是“数据”与“操作数据的方法”。
所以第一步，先来了解 lua 中的值。

* TODO review struct & union

- struct memory
- union memory
- how TString alignment? where dummy is smaller than tsv
- struct in union, gcobject hack
- union in array? 如何对齐

* tagged value

章节开始就提到，类型存在于值本身。
在 lua 内部，用 TValue（tagged value）结构表示值的概念。

#+CAPTION: lobject.h
#+include: ../lua-5.1.5/src/lobject.h src c -n 67 :lines "67-76"

tt 表示值的类型，value 表示值的数据。
明显地，类型是值的一部分。

#+begin_src asymptote :file object-tvalue.png
unitsize(1pt);
defaultpen(fontsize(16pt));
defaultpen(font("OT1","cmtt","m","n"));
fill(box((0,0), (140, 100)), white);

path b = box((0, 0), (120, 40));

pair o = (10, 10);
draw(shift(o) * b);
label("int tt", (10, 30), E);

pair offset = (0, 40);
draw(shift(o + offset) * b);
label("Value value", (10, 70), E);
#+end_src

#+RESULTS:
[[file:object-tvalue.png]]


** type

在 TValue 中，类型 tt 用 int 来标识，可以在代码中看到所有基础类型的宏定义

#+CAPTION: lua.h
#+include: ../lua-5.1.5/src/lua.h src c -n 69 :lines "69-83"

完全对应 lua 中的 8 种类型。

同时定义了相应的宏，方便检测值的类型。

#+CAPTION: lobject.h
#+include: ../lua-5.1.5/src/lobject.h src c -n 78 :lines "78-91"

细心如你，一定发现多出了一种 lightuserdata 类型。
这是由 userdata 细分出来的一种类型，目前先不做细致的解释，
之后到相应章节再具体分析。

** value

TValue 中，数据 value 用 union Value 结构来表示，有效利用内存空间。

#+CAPTION: lobject.h
#+include: ../lua-5.1.5/src/lobject.h src c -n 56 :lines "56-65"

不同类型的数据使用不同的键值来存取。


#+begin_example
+------------------------------------------------------------------------+
| Value value                                                            |
| +--------------+-----------------+-----------------+-----------------+ |
| |              |                 |                 |                 | |
| | GCObject* gc | void* p         | lua_Number n    | int b           | |
| |              |                 |                 |                 | |
| +--------------+-----------------+-----------------+-----------------+ |
+------------------------------------------------------------------------+
| int tt                                                                 |
+------------------------------------------------------------------------+
#+end_example


* detail

下面针对不同类型的值，详细分析。  

** nil

nil 是最简单的值，表示没有值。
由于只表示一个含义，故不需要 value，只用 tt 记录类型即可。

#+CAPTION: lobject.c
#+include: ../lua-5.1.5/src/lobject.c src c -n 27 :lines "27-28"

#+CAPTION: lobject.h
#+include: ../lua-5.1.5/src/lobject.h src c -n 363 :lines "363-366"

可以看出，nil 值在内部是一个单例，所有使用 nil 的地方，都通过 ~luaO_nilobject~ 来引用。


fig.nil

** bool

和其它语言一样，bool 值记录 true 和 false。

在存储的安排上，使用 tt 记录类型，用 value 中的 int b = 1/0 表示 true/false。

fig.bool

** light userdata

light userdata 表示 c 和 lua 协同时，由 c 一方传入的数据。
lua 内部只负责引用，而不负责其生命周期管理，什么时候应该释放，lua 不清楚也不过问。

所以内部在用 tt 记录类型之后，只用 value 中 void * p 引用即可。

fig.light userdata

** number

在默认设置下，lua 语言中所有数字都用 double 来表示。

#+CAPTION: luaconf.h
#+include: ../lua-5.1.5/src/luaconf.h src c -n 495 :lines "495-506"

#+CAPTION: lua.h
#+include: ../lua-5.1.5/src/lua.h src c -n 98 :lines "98-100"

类似的，用 tt 记录类型，用 value 中 =lua_Number n= 来记录 number 数值。

fig.number

** collectable

上面几种类型的值，内部表示都相对简单，剩余几种类型的数据就相对复杂一些。
- string
- table
- function
- userdata
- thread

有一点是共通的，它们同属于可 gc 的值（iscollectable）。

#+CAPTION: lobject.h
#+include: ../lua-5.1.5/src/lobject.h src c -n 189 :lines "189-190"


lua 内建了 gc 机制，其中关键的结构是 =GCObject= ，
用于表示所有 iscollectable 的值。

GCObject 是 union 结构，和 Value 结构类似，内部键值用于存取不同类型的数据。

#+CAPTION: lstate.h
#+include: ../lua-5.1.5/src/lstate.h src c -n 133 :lines "133-146"

如果仔细观察内部内存的安排，会发现这种方式是非常巧妙的。

=gch h p uv th= 都是 struct，头部的字段都是 CommonHeader。

#+CAPTION: lobject.h
#+include: ../lua-5.1.5/src/lobject.h src c -n 39 :lines "39-52"
#+include: ../lua-5.1.5/src/lobject.h src c -n 338 :lines "338-349"
#+include: ../lua-5.1.5/src/lobject.h src c -n 228 :lines "228-254"
#+include: ../lua-5.1.5/src/lobject.h src c -n 270 :lines "270-285"

#+CAPTION: lstate.h
#+include: ../lua-5.1.5/src/lstate.h src c -n 97 :lines "97-128"

=ts us cl= 虽然是 union，但是其中多余的字段是用于对齐的，实质还是 struct。

#+CAPTION: lobject.h
#+include: ../lua-5.1.5/src/lobject.h src c -n 196 :lines "196-208"
#+include: ../lua-5.1.5/src/lobject.h src c -n 215 :lines "215-224"
#+include: ../lua-5.1.5/src/lobject.h src c -n 287 :lines "287-313"

fig.gcobject

GCObject 将类型重新备份了一份，GCHeader 中的 tt 和 TValue 中的 tt 是相同的。

#+CAPTION: lobject.h
#+include: ../lua-5.1.5/src/lobject.h src c -n 105 :lines "105-110"

这样的话，GCObject 可以脱离 TValue，使用 GCHeader gch 先来读取 tt，再根据 tt 来使用不同的键值来引用数据。

#+CAPTION: lstate.h
#+include: ../lua-5.1.5/src/lstate.h src c -n 148 :lines "148-160"

至于不同类型的数据如何记录，在后面会分章节讨论。

** internal

细心如你，一定又发现了，GCObject 中除了 gch，多出了 p uv，是 8 种类型之外的。

事实上，在 thread 之后，新定义了 3 个类型，同属于 iscollectable，只用于内部使用
- proto
- upval
- deadkey

#+caption: lobject.h
#+include: ../lua-5.1.5/src/lobject.h src c -n 19 :lines "19-31"

proto 和 upval 就对应 GCObject 中多出的 2 个键值 p uv，
至于 deadkey，到特定章节再讨论。

* practice

阅读练习

| 文件      | 建议     | 描述                                                                         |
|-----------+----------+------------------------------------------------------------------------------|
| lobject.h | 仔细阅读 | 这个文件非常关键，除了定义了关键的数据结构之外，还定义了大量的宏辅助数据操作 |
| lstate.h  | 浏览阅读 | 其中定义了和运行时状态相关的数据结构，尽量理解，加深印象                        |
| lobject.c | 可以阅读 | 实现了 lobject.h 中声明的方法，并非核心内容                                  |


