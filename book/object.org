#+SETUPFILE: setup.org

#+TITLE: object
#+DATE: <2020-12-23 三 11:59>

lua 是一种动态类型语言，类型不存在于变量中，而存在于值本身。

语言中定义了 8 种类型的值
- nil
- bool
- number
- string
- table
- function
- userdata
- thread

虽然章节名称为 object，和源代码的名称相同。
但是通常都翻译为“对象”，容易与 OOP 中的对象概念混杂在一起。
在本章，更乐意将其译为“值”。

从某种角度而言，程序就是“数据”与“操作数据的方法”。
所以第一步，先来了解 lua 中的值。

* TODO review struct & union

- struct memory
- union memory
- how TString alignment? where dummy is smaller than tsv
- struct in union, gcobject hack
- union in array? 如何对齐

* tagged value

章节开始就提到，类型存在于值本身。
在 lua 内部，用 TValue（tagged value）结构表示值的概念。

#+CAPTION: lobject.h
#+INCLUDE: ../lua-5.1.5/src/lobject.h src c -n 67 :lines "67-76"

tt 表示值的类型，value 表示值的数据。
明显地，类型是值的一部分。

#+begin_src asymptote :file object-tvalue.png
unitsize(1pt);
defaultpen(fontsize(16pt));
defaultpen(font("OT1","cmtt","m","n"));

fill(box((0,0), (200, 100)), white);

path b = box((0, 0), (120, 40));

pair o = (10, 10);
draw(shift(o) * b);
label("int tt", (10, 30), E);

pair offset = (0, 40);
draw(shift(o + offset) * b);
label("Value value", (10, 70), E);
#+end_src

#+RESULTS:
[[file:object-tvalue.png]]


** type

在 TValue 中，类型 tt 用 int 来标识，可以在代码中看到所有基础类型的宏定义

#+CAPTION: lua.h
#+INCLUDE: ../lua-5.1.5/src/lua.h src c :lines "69-83"

完全对应 lua 中的 8 种类型。

同时定义了相应的宏，方便类型的检测。

#+CAPTION: lobject.h
#+INCLUDE: ../lua-5.1.5/src/lobject.h src c -n 78 :lines "78-91"

细心如你，一定发现莫名多出一种 lightuserdata 类型。
这是由 userdata 类型细分出来的一种类型定义，目前先不做细致的解释，
之后到相应章节再具体分析。

** value

数据部分，TValue 用一个 union 结构来表示，有效利用内存空间。

#+CAPTION: lobject.h
#+INCLUDE: ../lua-5.1.5/src/lobject.h src c :lines "56-65"

不同类型的数据使用不同的键值来存取。

#+begin_src ditaa :file object-value.png :cmdline

+------------------------------------------------------------------------+
|   Value value                                                          |
| +--------------+-----------------+-----------------+-----------------+ |
| :              :                 :                 :                 : |
| | GCObject*  gc| void *          | lua_Number      | int             | |
| |              | p               | n               | b               | |
| |              |                 |                 |                 | |
| |              |                 |                 |                 | |
| |              |                 |                 |                 | |
| |              |                 |                 |                 | |
| |              |                 |                 |                 | |
| |              |                 |                 |                 | |
| |              |                 |                 |                 | |
| |              |                 |                 |                 | |
| |              |                 |                 |                 | |
| |              |                 |                 |                 | |
| +--------------+-----------------+-----------------+-----------------+ |
+------------------------------------------------------------------------+
|   int tt                                                               |
+------------------------------------------------------------------------+

#+end_src

#+RESULTS:
[[file:object-value.png]]





** detail

*** nil

nil 是最简单的值，表示没有值。由于不需要数据，只需用 tt 表示类型即可。

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c :lines "363-366"

#+INCLUDE: ../lua-5.1.5/src/lobject.c src c :lines "27-28"

重要的是，nil 是一个单例值，所有使用 nil 的地方，都通过 ~luaO_nilobject~ 来引用。

fig.nil

*** bool

lua 中的 bool 值是 true 和 false。

在 tt 记录类型之后，用 int b = 1/0 表示 true/false。

fig.bool

*** TODO light userdata

light userdata 表示 c 和 lua 协同的时候，由 c 语言一方传入的数据。

相应的，lua 内部只负责引用，而不负责其生命周期管理，什么时候释放，lua 并不清楚，也不过问。

所以只用 void * p 引用即可

fig.light userdata

*** number

默认设定下，lua 中所有数字都用 double 来表示。

#+INCLUDE: ../lua-5.1.5/src/luaconf.h src c :lines "495-506"

#+INCLUDE: ../lua-5.1.5/src/lua.h src c :lines "98-100"

相应地，tt 表示数字，用 lua_Number n 来存取数字内容

fig.number

*** collectable

上面的数据表示都相对简单，其余类型的数据就相对复杂一些。
但是有一点是共通的，它们都属于可 gc 的对象。

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c :lines "189-190"

lua 内建了 gc 机制，其中关键的结构是 ~GCObject~ 。
其本身是 union 结构，内部键值表明了可存取其它类型的数据。

#+INCLUDE: ../lua-5.1.5/src/lstate.h src c :lines "133-146"

所有这些数据都有一个共同点，它们都是 struct，且头部的字段都是 CommonHeader。

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c :lines "39-52"

其中 tt 和 TValue 中的 tt 是相同的。

这样就可以利用内存结构的特性，引用 GCHeader gch 来读取 tt，再根据 tt 来引用不同的键值。

fig.gcobject

这一点在取数据的宏定义中可以清晰的看到

#+INCLUDE: ../lua-5.1.5/src/lstate.h src c :lines "148-160"

至于剩下的类型，
- string
- table
- function
- userdata
- thread

其数据管理在后续，单独分拆为独立章节来讲解。这里先略过不表。

*** TODO internal
    :LOGBOOK:
    - Note taken on [2020-12-02 三 15:42] \\
      deadkey 是什么含义？
    :END:

细心如你，一定又发现了，GCObject 中除了 gch，有 7 个键值，而不是 5 个。

事实上，在 thread 之后，新定义了 3 个类型，
- proto
- upval
- deadkey

用于内部实现使用

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c :lines "19-31"

proto 和 upval 就对应 GCObject 中多出的 2 个键值。
至于 deadkey，后续再说（现在还不清楚）。

** TODO practice
   :LOGBOOK:
   - Note taken on [2020-12-02 三 15:43] \\
     所有可关联本章内容一起阅读的代码

     关联性强，容易阅读
   :END:

根据不同类型，从 TValue 中取数据的宏

#+INCLUDE: ../lua-5.1.5/src/lobject.h src c :lines "91-102"
